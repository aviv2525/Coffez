"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/dexie@3.2.7";
exports.ids = ["vendor-chunks/dexie@3.2.7"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/dexie@3.2.7/node_modules/dexie/dist/modern/dexie.mjs":
/*!*************************************************************************************!*\
  !*** ../../node_modules/.pnpm/dexie@3.2.7/node_modules/dexie/dist/modern/dexie.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Dexie: () => (/* binding */ Dexie$1),\n/* harmony export */   RangeSet: () => (/* binding */ RangeSet),\n/* harmony export */   \"default\": () => (/* binding */ Dexie$1),\n/* harmony export */   liveQuery: () => (/* binding */ liveQuery),\n/* harmony export */   mergeRanges: () => (/* binding */ mergeRanges),\n/* harmony export */   rangesOverlap: () => (/* binding */ rangesOverlap)\n/* harmony export */ });\n/*\n * Dexie.js - a minimalistic wrapper for IndexedDB\n * ===============================================\n *\n * By David Fahlander, david.fahlander@gmail.com\n *\n * Version 3.2.7, Wed Mar 20 2024\n *\n * https://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n */ const _global = typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self :  false ? 0 : global;\nconst keys = Object.keys;\nconst isArray = Array.isArray;\nif (typeof Promise !== \"undefined\" && !_global.Promise) {\n    _global.Promise = Promise;\n}\nfunction extend(obj, extension) {\n    if (typeof extension !== \"object\") return obj;\n    keys(extension).forEach(function(key) {\n        obj[key] = extension[key];\n    });\n    return obj;\n}\nconst getProto = Object.getPrototypeOf;\nconst _hasOwn = {}.hasOwnProperty;\nfunction hasOwn(obj, prop) {\n    return _hasOwn.call(obj, prop);\n}\nfunction props(proto, extension) {\n    if (typeof extension === \"function\") extension = extension(getProto(proto));\n    (typeof Reflect === \"undefined\" ? keys : Reflect.ownKeys)(extension).forEach((key)=>{\n        setProp(proto, key, extension[key]);\n    });\n}\nconst defineProperty = Object.defineProperty;\nfunction setProp(obj, prop, functionOrGetSet, options) {\n    defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, \"get\") && typeof functionOrGetSet.get === \"function\" ? {\n        get: functionOrGetSet.get,\n        set: functionOrGetSet.set,\n        configurable: true\n    } : {\n        value: functionOrGetSet,\n        configurable: true,\n        writable: true\n    }, options));\n}\nfunction derive(Child) {\n    return {\n        from: function(Parent) {\n            Child.prototype = Object.create(Parent.prototype);\n            setProp(Child.prototype, \"constructor\", Child);\n            return {\n                extend: props.bind(null, Child.prototype)\n            };\n        }\n    };\n}\nconst getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nfunction getPropertyDescriptor(obj, prop) {\n    const pd = getOwnPropertyDescriptor(obj, prop);\n    let proto;\n    return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);\n}\nconst _slice = [].slice;\nfunction slice(args, start, end) {\n    return _slice.call(args, start, end);\n}\nfunction override(origFunc, overridedFactory) {\n    return overridedFactory(origFunc);\n}\nfunction assert(b) {\n    if (!b) throw new Error(\"Assertion Failed\");\n}\nfunction asap$1(fn) {\n    if (_global.setImmediate) setImmediate(fn);\n    else setTimeout(fn, 0);\n}\nfunction arrayToObject(array, extractor) {\n    return array.reduce((result, item, i)=>{\n        var nameAndValue = extractor(item, i);\n        if (nameAndValue) result[nameAndValue[0]] = nameAndValue[1];\n        return result;\n    }, {});\n}\nfunction tryCatch(fn, onerror, args) {\n    try {\n        fn.apply(null, args);\n    } catch (ex) {\n        onerror && onerror(ex);\n    }\n}\nfunction getByKeyPath(obj, keyPath) {\n    if (typeof keyPath === \"string\" && hasOwn(obj, keyPath)) return obj[keyPath];\n    if (!keyPath) return obj;\n    if (typeof keyPath !== \"string\") {\n        var rv = [];\n        for(var i = 0, l = keyPath.length; i < l; ++i){\n            var val = getByKeyPath(obj, keyPath[i]);\n            rv.push(val);\n        }\n        return rv;\n    }\n    var period = keyPath.indexOf(\".\");\n    if (period !== -1) {\n        var innerObj = obj[keyPath.substr(0, period)];\n        return innerObj == null ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));\n    }\n    return undefined;\n}\nfunction setByKeyPath(obj, keyPath, value) {\n    if (!obj || keyPath === undefined) return;\n    if (\"isFrozen\" in Object && Object.isFrozen(obj)) return;\n    if (typeof keyPath !== \"string\" && \"length\" in keyPath) {\n        assert(typeof value !== \"string\" && \"length\" in value);\n        for(var i = 0, l = keyPath.length; i < l; ++i){\n            setByKeyPath(obj, keyPath[i], value[i]);\n        }\n    } else {\n        var period = keyPath.indexOf(\".\");\n        if (period !== -1) {\n            var currentKeyPath = keyPath.substr(0, period);\n            var remainingKeyPath = keyPath.substr(period + 1);\n            if (remainingKeyPath === \"\") if (value === undefined) {\n                if (isArray(obj) && !isNaN(parseInt(currentKeyPath))) obj.splice(currentKeyPath, 1);\n                else delete obj[currentKeyPath];\n            } else obj[currentKeyPath] = value;\n            else {\n                var innerObj = obj[currentKeyPath];\n                if (!innerObj || !hasOwn(obj, currentKeyPath)) innerObj = obj[currentKeyPath] = {};\n                setByKeyPath(innerObj, remainingKeyPath, value);\n            }\n        } else {\n            if (value === undefined) {\n                if (isArray(obj) && !isNaN(parseInt(keyPath))) obj.splice(keyPath, 1);\n                else delete obj[keyPath];\n            } else obj[keyPath] = value;\n        }\n    }\n}\nfunction delByKeyPath(obj, keyPath) {\n    if (typeof keyPath === \"string\") setByKeyPath(obj, keyPath, undefined);\n    else if (\"length\" in keyPath) [].map.call(keyPath, function(kp) {\n        setByKeyPath(obj, kp, undefined);\n    });\n}\nfunction shallowClone(obj) {\n    var rv = {};\n    for(var m in obj){\n        if (hasOwn(obj, m)) rv[m] = obj[m];\n    }\n    return rv;\n}\nconst concat = [].concat;\nfunction flatten(a) {\n    return concat.apply([], a);\n}\nconst intrinsicTypeNames = \"BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey\".split(\",\").concat(flatten([\n    8,\n    16,\n    32,\n    64\n].map((num)=>[\n        \"Int\",\n        \"Uint\",\n        \"Float\"\n    ].map((t)=>t + num + \"Array\")))).filter((t)=>_global[t]);\nconst intrinsicTypes = intrinsicTypeNames.map((t)=>_global[t]);\narrayToObject(intrinsicTypeNames, (x)=>[\n        x,\n        true\n    ]);\nlet circularRefs = null;\nfunction deepClone(any) {\n    circularRefs = typeof WeakMap !== \"undefined\" && new WeakMap();\n    const rv = innerDeepClone(any);\n    circularRefs = null;\n    return rv;\n}\nfunction innerDeepClone(any) {\n    if (!any || typeof any !== \"object\") return any;\n    let rv = circularRefs && circularRefs.get(any);\n    if (rv) return rv;\n    if (isArray(any)) {\n        rv = [];\n        circularRefs && circularRefs.set(any, rv);\n        for(var i = 0, l = any.length; i < l; ++i){\n            rv.push(innerDeepClone(any[i]));\n        }\n    } else if (intrinsicTypes.indexOf(any.constructor) >= 0) {\n        rv = any;\n    } else {\n        const proto = getProto(any);\n        rv = proto === Object.prototype ? {} : Object.create(proto);\n        circularRefs && circularRefs.set(any, rv);\n        for(var prop in any){\n            if (hasOwn(any, prop)) {\n                rv[prop] = innerDeepClone(any[prop]);\n            }\n        }\n    }\n    return rv;\n}\nconst { toString } = {};\nfunction toStringTag(o) {\n    return toString.call(o).slice(8, -1);\n}\nconst iteratorSymbol = typeof Symbol !== \"undefined\" ? Symbol.iterator : \"@@iterator\";\nconst getIteratorOf = typeof iteratorSymbol === \"symbol\" ? function(x) {\n    var i;\n    return x != null && (i = x[iteratorSymbol]) && i.apply(x);\n} : function() {\n    return null;\n};\nconst NO_CHAR_ARRAY = {};\nfunction getArrayOf(arrayLike) {\n    var i, a, x, it;\n    if (arguments.length === 1) {\n        if (isArray(arrayLike)) return arrayLike.slice();\n        if (this === NO_CHAR_ARRAY && typeof arrayLike === \"string\") return [\n            arrayLike\n        ];\n        if (it = getIteratorOf(arrayLike)) {\n            a = [];\n            while(x = it.next(), !x.done)a.push(x.value);\n            return a;\n        }\n        if (arrayLike == null) return [\n            arrayLike\n        ];\n        i = arrayLike.length;\n        if (typeof i === \"number\") {\n            a = new Array(i);\n            while(i--)a[i] = arrayLike[i];\n            return a;\n        }\n        return [\n            arrayLike\n        ];\n    }\n    i = arguments.length;\n    a = new Array(i);\n    while(i--)a[i] = arguments[i];\n    return a;\n}\nconst isAsyncFunction = typeof Symbol !== \"undefined\" ? (fn)=>fn[Symbol.toStringTag] === \"AsyncFunction\" : ()=>false;\nvar debug = typeof location !== \"undefined\" && /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\nfunction setDebug(value, filter) {\n    debug = value;\n    libraryFilter = filter;\n}\nvar libraryFilter = ()=>true;\nconst NEEDS_THROW_FOR_STACK = !new Error(\"\").stack;\nfunction getErrorWithStack() {\n    if (NEEDS_THROW_FOR_STACK) try {\n        getErrorWithStack.arguments;\n        throw new Error();\n    } catch (e) {\n        return e;\n    }\n    return new Error();\n}\nfunction prettyStack(exception, numIgnoredFrames) {\n    var stack = exception.stack;\n    if (!stack) return \"\";\n    numIgnoredFrames = numIgnoredFrames || 0;\n    if (stack.indexOf(exception.name) === 0) numIgnoredFrames += (exception.name + exception.message).split(\"\\n\").length;\n    return stack.split(\"\\n\").slice(numIgnoredFrames).filter(libraryFilter).map((frame)=>\"\\n\" + frame).join(\"\");\n}\nvar dexieErrorNames = [\n    \"Modify\",\n    \"Bulk\",\n    \"OpenFailed\",\n    \"VersionChange\",\n    \"Schema\",\n    \"Upgrade\",\n    \"InvalidTable\",\n    \"MissingAPI\",\n    \"NoSuchDatabase\",\n    \"InvalidArgument\",\n    \"SubTransaction\",\n    \"Unsupported\",\n    \"Internal\",\n    \"DatabaseClosed\",\n    \"PrematureCommit\",\n    \"ForeignAwait\"\n];\nvar idbDomErrorNames = [\n    \"Unknown\",\n    \"Constraint\",\n    \"Data\",\n    \"TransactionInactive\",\n    \"ReadOnly\",\n    \"Version\",\n    \"NotFound\",\n    \"InvalidState\",\n    \"InvalidAccess\",\n    \"Abort\",\n    \"Timeout\",\n    \"QuotaExceeded\",\n    \"Syntax\",\n    \"DataClone\"\n];\nvar errorList = dexieErrorNames.concat(idbDomErrorNames);\nvar defaultTexts = {\n    VersionChanged: \"Database version changed by other database connection\",\n    DatabaseClosed: \"Database has been closed\",\n    Abort: \"Transaction aborted\",\n    TransactionInactive: \"Transaction has already completed or failed\",\n    MissingAPI: \"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb\"\n};\nfunction DexieError(name, msg) {\n    this._e = getErrorWithStack();\n    this.name = name;\n    this.message = msg;\n}\nderive(DexieError).from(Error).extend({\n    stack: {\n        get: function() {\n            return this._stack || (this._stack = this.name + \": \" + this.message + prettyStack(this._e, 2));\n        }\n    },\n    toString: function() {\n        return this.name + \": \" + this.message;\n    }\n});\nfunction getMultiErrorMessage(msg, failures) {\n    return msg + \". Errors: \" + Object.keys(failures).map((key)=>failures[key].toString()).filter((v, i, s)=>s.indexOf(v) === i).join(\"\\n\");\n}\nfunction ModifyError(msg, failures, successCount, failedKeys) {\n    this._e = getErrorWithStack();\n    this.failures = failures;\n    this.failedKeys = failedKeys;\n    this.successCount = successCount;\n    this.message = getMultiErrorMessage(msg, failures);\n}\nderive(ModifyError).from(DexieError);\nfunction BulkError(msg, failures) {\n    this._e = getErrorWithStack();\n    this.name = \"BulkError\";\n    this.failures = Object.keys(failures).map((pos)=>failures[pos]);\n    this.failuresByPos = failures;\n    this.message = getMultiErrorMessage(msg, failures);\n}\nderive(BulkError).from(DexieError);\nvar errnames = errorList.reduce((obj, name)=>(obj[name] = name + \"Error\", obj), {});\nconst BaseException = DexieError;\nvar exceptions = errorList.reduce((obj, name)=>{\n    var fullName = name + \"Error\";\n    function DexieError(msgOrInner, inner) {\n        this._e = getErrorWithStack();\n        this.name = fullName;\n        if (!msgOrInner) {\n            this.message = defaultTexts[name] || fullName;\n            this.inner = null;\n        } else if (typeof msgOrInner === \"string\") {\n            this.message = `${msgOrInner}${!inner ? \"\" : \"\\n \" + inner}`;\n            this.inner = inner || null;\n        } else if (typeof msgOrInner === \"object\") {\n            this.message = `${msgOrInner.name} ${msgOrInner.message}`;\n            this.inner = msgOrInner;\n        }\n    }\n    derive(DexieError).from(BaseException);\n    obj[name] = DexieError;\n    return obj;\n}, {});\nexceptions.Syntax = SyntaxError;\nexceptions.Type = TypeError;\nexceptions.Range = RangeError;\nvar exceptionMap = idbDomErrorNames.reduce((obj, name)=>{\n    obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\nfunction mapError(domError, message) {\n    if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name]) return domError;\n    var rv = new exceptionMap[domError.name](message || domError.message, domError);\n    if (\"stack\" in domError) {\n        setProp(rv, \"stack\", {\n            get: function() {\n                return this.inner.stack;\n            }\n        });\n    }\n    return rv;\n}\nvar fullNameExceptions = errorList.reduce((obj, name)=>{\n    if ([\n        \"Syntax\",\n        \"Type\",\n        \"Range\"\n    ].indexOf(name) === -1) obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\nfullNameExceptions.ModifyError = ModifyError;\nfullNameExceptions.DexieError = DexieError;\nfullNameExceptions.BulkError = BulkError;\nfunction nop() {}\nfunction mirror(val) {\n    return val;\n}\nfunction pureFunctionChain(f1, f2) {\n    if (f1 == null || f1 === mirror) return f2;\n    return function(val) {\n        return f2(f1(val));\n    };\n}\nfunction callBoth(on1, on2) {\n    return function() {\n        on1.apply(this, arguments);\n        on2.apply(this, arguments);\n    };\n}\nfunction hookCreatingChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function() {\n        var res = f1.apply(this, arguments);\n        if (res !== undefined) arguments[0] = res;\n        var onsuccess = this.onsuccess, onerror = this.onerror;\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res2 !== undefined ? res2 : res;\n    };\n}\nfunction hookDeletingChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function() {\n        f1.apply(this, arguments);\n        var onsuccess = this.onsuccess, onerror = this.onerror;\n        this.onsuccess = this.onerror = null;\n        f2.apply(this, arguments);\n        if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n    };\n}\nfunction hookUpdatingChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function(modifications) {\n        var res = f1.apply(this, arguments);\n        extend(modifications, res);\n        var onsuccess = this.onsuccess, onerror = this.onerror;\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res === undefined ? res2 === undefined ? undefined : res2 : extend(res, res2);\n    };\n}\nfunction reverseStoppableEventChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function() {\n        if (f2.apply(this, arguments) === false) return false;\n        return f1.apply(this, arguments);\n    };\n}\nfunction promisableChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function() {\n        var res = f1.apply(this, arguments);\n        if (res && typeof res.then === \"function\") {\n            var thiz = this, i = arguments.length, args = new Array(i);\n            while(i--)args[i] = arguments[i];\n            return res.then(function() {\n                return f2.apply(thiz, args);\n            });\n        }\n        return f2.apply(this, arguments);\n    };\n}\nvar INTERNAL = {};\nconst LONG_STACKS_CLIP_LIMIT = 100, MAX_LONG_STACKS = 20, ZONE_ECHO_LIMIT = 100, [resolvedNativePromise, nativePromiseProto, resolvedGlobalPromise] = typeof Promise === \"undefined\" ? [] : (()=>{\n    let globalP = Promise.resolve();\n    if (typeof crypto === \"undefined\" || !crypto.subtle) return [\n        globalP,\n        getProto(globalP),\n        globalP\n    ];\n    const nativeP = crypto.subtle.digest(\"SHA-512\", new Uint8Array([\n        0\n    ]));\n    return [\n        nativeP,\n        getProto(nativeP),\n        globalP\n    ];\n})(), nativePromiseThen = nativePromiseProto && nativePromiseProto.then;\nconst NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;\nconst patchGlobalPromise = !!resolvedGlobalPromise;\nvar stack_being_generated = false;\nvar schedulePhysicalTick = resolvedGlobalPromise ? ()=>{\n    resolvedGlobalPromise.then(physicalTick);\n} : _global.setImmediate ? setImmediate.bind(null, physicalTick) : _global.MutationObserver ? ()=>{\n    var hiddenDiv = document.createElement(\"div\");\n    new MutationObserver(()=>{\n        physicalTick();\n        hiddenDiv = null;\n    }).observe(hiddenDiv, {\n        attributes: true\n    });\n    hiddenDiv.setAttribute(\"i\", \"1\");\n} : ()=>{\n    setTimeout(physicalTick, 0);\n};\nvar asap = function(callback, args) {\n    microtickQueue.push([\n        callback,\n        args\n    ]);\n    if (needsNewPhysicalTick) {\n        schedulePhysicalTick();\n        needsNewPhysicalTick = false;\n    }\n};\nvar isOutsideMicroTick = true, needsNewPhysicalTick = true, unhandledErrors = [], rejectingErrors = [], currentFulfiller = null, rejectionMapper = mirror;\nvar globalPSD = {\n    id: \"global\",\n    global: true,\n    ref: 0,\n    unhandleds: [],\n    onunhandled: globalError,\n    pgp: false,\n    env: {},\n    finalize: function() {\n        this.unhandleds.forEach((uh)=>{\n            try {\n                globalError(uh[0], uh[1]);\n            } catch (e) {}\n        });\n    }\n};\nvar PSD = globalPSD;\nvar microtickQueue = [];\nvar numScheduledCalls = 0;\nvar tickFinalizers = [];\nfunction DexiePromise(fn) {\n    if (typeof this !== \"object\") throw new TypeError(\"Promises must be constructed via new\");\n    this._listeners = [];\n    this.onuncatched = nop;\n    this._lib = false;\n    var psd = this._PSD = PSD;\n    if (debug) {\n        this._stackHolder = getErrorWithStack();\n        this._prev = null;\n        this._numPrev = 0;\n    }\n    if (typeof fn !== \"function\") {\n        if (fn !== INTERNAL) throw new TypeError(\"Not a function\");\n        this._state = arguments[1];\n        this._value = arguments[2];\n        if (this._state === false) handleRejection(this, this._value);\n        return;\n    }\n    this._state = null;\n    this._value = null;\n    ++psd.ref;\n    executePromiseTask(this, fn);\n}\nconst thenProp = {\n    get: function() {\n        var psd = PSD, microTaskId = totalEchoes;\n        function then(onFulfilled, onRejected) {\n            var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);\n            const cleanup = possibleAwait && !decrementExpectedAwaits();\n            var rv = new DexiePromise((resolve, reject)=>{\n                propagateToListener(this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));\n            });\n            debug && linkToPreviousPromise(rv, this);\n            return rv;\n        }\n        then.prototype = INTERNAL;\n        return then;\n    },\n    set: function(value) {\n        setProp(this, \"then\", value && value.prototype === INTERNAL ? thenProp : {\n            get: function() {\n                return value;\n            },\n            set: thenProp.set\n        });\n    }\n};\nprops(DexiePromise.prototype, {\n    then: thenProp,\n    _then: function(onFulfilled, onRejected) {\n        propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));\n    },\n    catch: function(onRejected) {\n        if (arguments.length === 1) return this.then(null, onRejected);\n        var type = arguments[0], handler = arguments[1];\n        return typeof type === \"function\" ? this.then(null, (err)=>err instanceof type ? handler(err) : PromiseReject(err)) : this.then(null, (err)=>err && err.name === type ? handler(err) : PromiseReject(err));\n    },\n    finally: function(onFinally) {\n        return this.then((value)=>{\n            onFinally();\n            return value;\n        }, (err)=>{\n            onFinally();\n            return PromiseReject(err);\n        });\n    },\n    stack: {\n        get: function() {\n            if (this._stack) return this._stack;\n            try {\n                stack_being_generated = true;\n                var stacks = getStack(this, [], MAX_LONG_STACKS);\n                var stack = stacks.join(\"\\nFrom previous: \");\n                if (this._state !== null) this._stack = stack;\n                return stack;\n            } finally{\n                stack_being_generated = false;\n            }\n        }\n    },\n    timeout: function(ms, msg) {\n        return ms < Infinity ? new DexiePromise((resolve, reject)=>{\n            var handle = setTimeout(()=>reject(new exceptions.Timeout(msg)), ms);\n            this.then(resolve, reject).finally(clearTimeout.bind(null, handle));\n        }) : this;\n    }\n});\nif (typeof Symbol !== \"undefined\" && Symbol.toStringTag) setProp(DexiePromise.prototype, Symbol.toStringTag, \"Dexie.Promise\");\nglobalPSD.env = snapShot();\nfunction Listener(onFulfilled, onRejected, resolve, reject, zone) {\n    this.onFulfilled = typeof onFulfilled === \"function\" ? onFulfilled : null;\n    this.onRejected = typeof onRejected === \"function\" ? onRejected : null;\n    this.resolve = resolve;\n    this.reject = reject;\n    this.psd = zone;\n}\nprops(DexiePromise, {\n    all: function() {\n        var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n        return new DexiePromise(function(resolve, reject) {\n            if (values.length === 0) resolve([]);\n            var remaining = values.length;\n            values.forEach((a, i)=>DexiePromise.resolve(a).then((x)=>{\n                    values[i] = x;\n                    if (!--remaining) resolve(values);\n                }, reject));\n        });\n    },\n    resolve: (value)=>{\n        if (value instanceof DexiePromise) return value;\n        if (value && typeof value.then === \"function\") return new DexiePromise((resolve, reject)=>{\n            value.then(resolve, reject);\n        });\n        var rv = new DexiePromise(INTERNAL, true, value);\n        linkToPreviousPromise(rv, currentFulfiller);\n        return rv;\n    },\n    reject: PromiseReject,\n    race: function() {\n        var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n        return new DexiePromise((resolve, reject)=>{\n            values.map((value)=>DexiePromise.resolve(value).then(resolve, reject));\n        });\n    },\n    PSD: {\n        get: ()=>PSD,\n        set: (value)=>PSD = value\n    },\n    totalEchoes: {\n        get: ()=>totalEchoes\n    },\n    newPSD: newScope,\n    usePSD: usePSD,\n    scheduler: {\n        get: ()=>asap,\n        set: (value)=>{\n            asap = value;\n        }\n    },\n    rejectionMapper: {\n        get: ()=>rejectionMapper,\n        set: (value)=>{\n            rejectionMapper = value;\n        }\n    },\n    follow: (fn, zoneProps)=>{\n        return new DexiePromise((resolve, reject)=>{\n            return newScope((resolve, reject)=>{\n                var psd = PSD;\n                psd.unhandleds = [];\n                psd.onunhandled = reject;\n                psd.finalize = callBoth(function() {\n                    run_at_end_of_this_or_next_physical_tick(()=>{\n                        this.unhandleds.length === 0 ? resolve() : reject(this.unhandleds[0]);\n                    });\n                }, psd.finalize);\n                fn();\n            }, zoneProps, resolve, reject);\n        });\n    }\n});\nif (NativePromise) {\n    if (NativePromise.allSettled) setProp(DexiePromise, \"allSettled\", function() {\n        const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n        return new DexiePromise((resolve)=>{\n            if (possiblePromises.length === 0) resolve([]);\n            let remaining = possiblePromises.length;\n            const results = new Array(remaining);\n            possiblePromises.forEach((p, i)=>DexiePromise.resolve(p).then((value)=>results[i] = {\n                        status: \"fulfilled\",\n                        value\n                    }, (reason)=>results[i] = {\n                        status: \"rejected\",\n                        reason\n                    }).then(()=>--remaining || resolve(results)));\n        });\n    });\n    if (NativePromise.any && typeof AggregateError !== \"undefined\") setProp(DexiePromise, \"any\", function() {\n        const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n        return new DexiePromise((resolve, reject)=>{\n            if (possiblePromises.length === 0) reject(new AggregateError([]));\n            let remaining = possiblePromises.length;\n            const failures = new Array(remaining);\n            possiblePromises.forEach((p, i)=>DexiePromise.resolve(p).then((value)=>resolve(value), (failure)=>{\n                    failures[i] = failure;\n                    if (!--remaining) reject(new AggregateError(failures));\n                }));\n        });\n    });\n}\nfunction executePromiseTask(promise, fn) {\n    try {\n        fn((value)=>{\n            if (promise._state !== null) return;\n            if (value === promise) throw new TypeError(\"A promise cannot be resolved with itself.\");\n            var shouldExecuteTick = promise._lib && beginMicroTickScope();\n            if (value && typeof value.then === \"function\") {\n                executePromiseTask(promise, (resolve, reject)=>{\n                    value instanceof DexiePromise ? value._then(resolve, reject) : value.then(resolve, reject);\n                });\n            } else {\n                promise._state = true;\n                promise._value = value;\n                propagateAllListeners(promise);\n            }\n            if (shouldExecuteTick) endMicroTickScope();\n        }, handleRejection.bind(null, promise));\n    } catch (ex) {\n        handleRejection(promise, ex);\n    }\n}\nfunction handleRejection(promise, reason) {\n    rejectingErrors.push(reason);\n    if (promise._state !== null) return;\n    var shouldExecuteTick = promise._lib && beginMicroTickScope();\n    reason = rejectionMapper(reason);\n    promise._state = false;\n    promise._value = reason;\n    debug && reason !== null && typeof reason === \"object\" && !reason._promise && tryCatch(()=>{\n        var origProp = getPropertyDescriptor(reason, \"stack\");\n        reason._promise = promise;\n        setProp(reason, \"stack\", {\n            get: ()=>stack_being_generated ? origProp && (origProp.get ? origProp.get.apply(reason) : origProp.value) : promise.stack\n        });\n    });\n    addPossiblyUnhandledError(promise);\n    propagateAllListeners(promise);\n    if (shouldExecuteTick) endMicroTickScope();\n}\nfunction propagateAllListeners(promise) {\n    var listeners = promise._listeners;\n    promise._listeners = [];\n    for(var i = 0, len = listeners.length; i < len; ++i){\n        propagateToListener(promise, listeners[i]);\n    }\n    var psd = promise._PSD;\n    --psd.ref || psd.finalize();\n    if (numScheduledCalls === 0) {\n        ++numScheduledCalls;\n        asap(()=>{\n            if (--numScheduledCalls === 0) finalizePhysicalTick();\n        }, []);\n    }\n}\nfunction propagateToListener(promise, listener) {\n    if (promise._state === null) {\n        promise._listeners.push(listener);\n        return;\n    }\n    var cb = promise._state ? listener.onFulfilled : listener.onRejected;\n    if (cb === null) {\n        return (promise._state ? listener.resolve : listener.reject)(promise._value);\n    }\n    ++listener.psd.ref;\n    ++numScheduledCalls;\n    asap(callListener, [\n        cb,\n        promise,\n        listener\n    ]);\n}\nfunction callListener(cb, promise, listener) {\n    try {\n        currentFulfiller = promise;\n        var ret, value = promise._value;\n        if (promise._state) {\n            ret = cb(value);\n        } else {\n            if (rejectingErrors.length) rejectingErrors = [];\n            ret = cb(value);\n            if (rejectingErrors.indexOf(value) === -1) markErrorAsHandled(promise);\n        }\n        listener.resolve(ret);\n    } catch (e) {\n        listener.reject(e);\n    } finally{\n        currentFulfiller = null;\n        if (--numScheduledCalls === 0) finalizePhysicalTick();\n        --listener.psd.ref || listener.psd.finalize();\n    }\n}\nfunction getStack(promise, stacks, limit) {\n    if (stacks.length === limit) return stacks;\n    var stack = \"\";\n    if (promise._state === false) {\n        var failure = promise._value, errorName, message;\n        if (failure != null) {\n            errorName = failure.name || \"Error\";\n            message = failure.message || failure;\n            stack = prettyStack(failure, 0);\n        } else {\n            errorName = failure;\n            message = \"\";\n        }\n        stacks.push(errorName + (message ? \": \" + message : \"\") + stack);\n    }\n    if (debug) {\n        stack = prettyStack(promise._stackHolder, 2);\n        if (stack && stacks.indexOf(stack) === -1) stacks.push(stack);\n        if (promise._prev) getStack(promise._prev, stacks, limit);\n    }\n    return stacks;\n}\nfunction linkToPreviousPromise(promise, prev) {\n    var numPrev = prev ? prev._numPrev + 1 : 0;\n    if (numPrev < LONG_STACKS_CLIP_LIMIT) {\n        promise._prev = prev;\n        promise._numPrev = numPrev;\n    }\n}\nfunction physicalTick() {\n    beginMicroTickScope() && endMicroTickScope();\n}\nfunction beginMicroTickScope() {\n    var wasRootExec = isOutsideMicroTick;\n    isOutsideMicroTick = false;\n    needsNewPhysicalTick = false;\n    return wasRootExec;\n}\nfunction endMicroTickScope() {\n    var callbacks, i, l;\n    do {\n        while(microtickQueue.length > 0){\n            callbacks = microtickQueue;\n            microtickQueue = [];\n            l = callbacks.length;\n            for(i = 0; i < l; ++i){\n                var item = callbacks[i];\n                item[0].apply(null, item[1]);\n            }\n        }\n    }while (microtickQueue.length > 0);\n    isOutsideMicroTick = true;\n    needsNewPhysicalTick = true;\n}\nfunction finalizePhysicalTick() {\n    var unhandledErrs = unhandledErrors;\n    unhandledErrors = [];\n    unhandledErrs.forEach((p)=>{\n        p._PSD.onunhandled.call(null, p._value, p);\n    });\n    var finalizers = tickFinalizers.slice(0);\n    var i = finalizers.length;\n    while(i)finalizers[--i]();\n}\nfunction run_at_end_of_this_or_next_physical_tick(fn) {\n    function finalizer() {\n        fn();\n        tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);\n    }\n    tickFinalizers.push(finalizer);\n    ++numScheduledCalls;\n    asap(()=>{\n        if (--numScheduledCalls === 0) finalizePhysicalTick();\n    }, []);\n}\nfunction addPossiblyUnhandledError(promise) {\n    if (!unhandledErrors.some((p)=>p._value === promise._value)) unhandledErrors.push(promise);\n}\nfunction markErrorAsHandled(promise) {\n    var i = unhandledErrors.length;\n    while(i)if (unhandledErrors[--i]._value === promise._value) {\n        unhandledErrors.splice(i, 1);\n        return;\n    }\n}\nfunction PromiseReject(reason) {\n    return new DexiePromise(INTERNAL, false, reason);\n}\nfunction wrap(fn, errorCatcher) {\n    var psd = PSD;\n    return function() {\n        var wasRootExec = beginMicroTickScope(), outerScope = PSD;\n        try {\n            switchToZone(psd, true);\n            return fn.apply(this, arguments);\n        } catch (e) {\n            errorCatcher && errorCatcher(e);\n        } finally{\n            switchToZone(outerScope, false);\n            if (wasRootExec) endMicroTickScope();\n        }\n    };\n}\nconst task = {\n    awaits: 0,\n    echoes: 0,\n    id: 0\n};\nvar taskCounter = 0;\nvar zoneStack = [];\nvar zoneEchoes = 0;\nvar totalEchoes = 0;\nvar zone_id_counter = 0;\nfunction newScope(fn, props, a1, a2) {\n    var parent = PSD, psd = Object.create(parent);\n    psd.parent = parent;\n    psd.ref = 0;\n    psd.global = false;\n    psd.id = ++zone_id_counter;\n    var globalEnv = globalPSD.env;\n    psd.env = patchGlobalPromise ? {\n        Promise: DexiePromise,\n        PromiseProp: {\n            value: DexiePromise,\n            configurable: true,\n            writable: true\n        },\n        all: DexiePromise.all,\n        race: DexiePromise.race,\n        allSettled: DexiePromise.allSettled,\n        any: DexiePromise.any,\n        resolve: DexiePromise.resolve,\n        reject: DexiePromise.reject,\n        nthen: getPatchedPromiseThen(globalEnv.nthen, psd),\n        gthen: getPatchedPromiseThen(globalEnv.gthen, psd)\n    } : {};\n    if (props) extend(psd, props);\n    ++parent.ref;\n    psd.finalize = function() {\n        --this.parent.ref || this.parent.finalize();\n    };\n    var rv = usePSD(psd, fn, a1, a2);\n    if (psd.ref === 0) psd.finalize();\n    return rv;\n}\nfunction incrementExpectedAwaits() {\n    if (!task.id) task.id = ++taskCounter;\n    ++task.awaits;\n    task.echoes += ZONE_ECHO_LIMIT;\n    return task.id;\n}\nfunction decrementExpectedAwaits() {\n    if (!task.awaits) return false;\n    if (--task.awaits === 0) task.id = 0;\n    task.echoes = task.awaits * ZONE_ECHO_LIMIT;\n    return true;\n}\nif ((\"\" + nativePromiseThen).indexOf(\"[native code]\") === -1) {\n    incrementExpectedAwaits = decrementExpectedAwaits = nop;\n}\nfunction onPossibleParallellAsync(possiblePromise) {\n    if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {\n        incrementExpectedAwaits();\n        return possiblePromise.then((x)=>{\n            decrementExpectedAwaits();\n            return x;\n        }, (e)=>{\n            decrementExpectedAwaits();\n            return rejection(e);\n        });\n    }\n    return possiblePromise;\n}\nfunction zoneEnterEcho(targetZone) {\n    ++totalEchoes;\n    if (!task.echoes || --task.echoes === 0) {\n        task.echoes = task.id = 0;\n    }\n    zoneStack.push(PSD);\n    switchToZone(targetZone, true);\n}\nfunction zoneLeaveEcho() {\n    var zone = zoneStack[zoneStack.length - 1];\n    zoneStack.pop();\n    switchToZone(zone, false);\n}\nfunction switchToZone(targetZone, bEnteringZone) {\n    var currentZone = PSD;\n    if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {\n        enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);\n    }\n    if (targetZone === PSD) return;\n    PSD = targetZone;\n    if (currentZone === globalPSD) globalPSD.env = snapShot();\n    if (patchGlobalPromise) {\n        var GlobalPromise = globalPSD.env.Promise;\n        var targetEnv = targetZone.env;\n        nativePromiseProto.then = targetEnv.nthen;\n        GlobalPromise.prototype.then = targetEnv.gthen;\n        if (currentZone.global || targetZone.global) {\n            Object.defineProperty(_global, \"Promise\", targetEnv.PromiseProp);\n            GlobalPromise.all = targetEnv.all;\n            GlobalPromise.race = targetEnv.race;\n            GlobalPromise.resolve = targetEnv.resolve;\n            GlobalPromise.reject = targetEnv.reject;\n            if (targetEnv.allSettled) GlobalPromise.allSettled = targetEnv.allSettled;\n            if (targetEnv.any) GlobalPromise.any = targetEnv.any;\n        }\n    }\n}\nfunction snapShot() {\n    var GlobalPromise = _global.Promise;\n    return patchGlobalPromise ? {\n        Promise: GlobalPromise,\n        PromiseProp: Object.getOwnPropertyDescriptor(_global, \"Promise\"),\n        all: GlobalPromise.all,\n        race: GlobalPromise.race,\n        allSettled: GlobalPromise.allSettled,\n        any: GlobalPromise.any,\n        resolve: GlobalPromise.resolve,\n        reject: GlobalPromise.reject,\n        nthen: nativePromiseProto.then,\n        gthen: GlobalPromise.prototype.then\n    } : {};\n}\nfunction usePSD(psd, fn, a1, a2, a3) {\n    var outerScope = PSD;\n    try {\n        switchToZone(psd, true);\n        return fn(a1, a2, a3);\n    } finally{\n        switchToZone(outerScope, false);\n    }\n}\nfunction enqueueNativeMicroTask(job) {\n    nativePromiseThen.call(resolvedNativePromise, job);\n}\nfunction nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {\n    return typeof fn !== \"function\" ? fn : function() {\n        var outerZone = PSD;\n        if (possibleAwait) incrementExpectedAwaits();\n        switchToZone(zone, true);\n        try {\n            return fn.apply(this, arguments);\n        } finally{\n            switchToZone(outerZone, false);\n            if (cleanup) enqueueNativeMicroTask(decrementExpectedAwaits);\n        }\n    };\n}\nfunction getPatchedPromiseThen(origThen, zone) {\n    return function(onResolved, onRejected) {\n        return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));\n    };\n}\nconst UNHANDLEDREJECTION = \"unhandledrejection\";\nfunction globalError(err, promise) {\n    var rv;\n    try {\n        rv = promise.onuncatched(err);\n    } catch (e) {}\n    if (rv !== false) try {\n        var event, eventData = {\n            promise: promise,\n            reason: err\n        };\n        if (_global.document && document.createEvent) {\n            event = document.createEvent(\"Event\");\n            event.initEvent(UNHANDLEDREJECTION, true, true);\n            extend(event, eventData);\n        } else if (_global.CustomEvent) {\n            event = new CustomEvent(UNHANDLEDREJECTION, {\n                detail: eventData\n            });\n            extend(event, eventData);\n        }\n        if (event && _global.dispatchEvent) {\n            dispatchEvent(event);\n            if (!_global.PromiseRejectionEvent && _global.onunhandledrejection) try {\n                _global.onunhandledrejection(event);\n            } catch (_) {}\n        }\n        if (debug && event && !event.defaultPrevented) {\n            console.warn(`Unhandled rejection: ${err.stack || err}`);\n        }\n    } catch (e) {}\n}\nvar rejection = DexiePromise.reject;\nfunction tempTransaction(db, mode, storeNames, fn) {\n    if (!db.idbdb || !db._state.openComplete && !PSD.letThrough && !db._vip) {\n        if (db._state.openComplete) {\n            return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));\n        }\n        if (!db._state.isBeingOpened) {\n            if (!db._options.autoOpen) return rejection(new exceptions.DatabaseClosed());\n            db.open().catch(nop);\n        }\n        return db._state.dbReadyPromise.then(()=>tempTransaction(db, mode, storeNames, fn));\n    } else {\n        var trans = db._createTransaction(mode, storeNames, db._dbSchema);\n        try {\n            trans.create();\n            db._state.PR1398_maxLoop = 3;\n        } catch (ex) {\n            if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n                console.warn(\"Dexie: Need to reopen db\");\n                db._close();\n                return db.open().then(()=>tempTransaction(db, mode, storeNames, fn));\n            }\n            return rejection(ex);\n        }\n        return trans._promise(mode, (resolve, reject)=>{\n            return newScope(()=>{\n                PSD.trans = trans;\n                return fn(resolve, reject, trans);\n            });\n        }).then((result)=>{\n            return trans._completion.then(()=>result);\n        });\n    }\n}\nconst DEXIE_VERSION = \"3.2.7\";\nconst maxString = String.fromCharCode(65535);\nconst minKey = -Infinity;\nconst INVALID_KEY_ARGUMENT = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\";\nconst STRING_EXPECTED = \"String expected.\";\nconst connections = [];\nconst isIEOrEdge = typeof navigator !== \"undefined\" && /(MSIE|Trident|Edge)/.test(navigator.userAgent);\nconst hasIEDeleteObjectStoreBug = isIEOrEdge;\nconst hangsOnDeleteLargeKeyRange = isIEOrEdge;\nconst dexieStackFrameFilter = (frame)=>!/(dexie\\.js|dexie\\.min\\.js)/.test(frame);\nconst DBNAMES_DB = \"__dbnames\";\nconst READONLY = \"readonly\";\nconst READWRITE = \"readwrite\";\nfunction combine(filter1, filter2) {\n    return filter1 ? filter2 ? function() {\n        return filter1.apply(this, arguments) && filter2.apply(this, arguments);\n    } : filter1 : filter2;\n}\nconst AnyRange = {\n    type: 3,\n    lower: -Infinity,\n    lowerOpen: false,\n    upper: [\n        []\n    ],\n    upperOpen: false\n};\nfunction workaroundForUndefinedPrimKey(keyPath) {\n    return typeof keyPath === \"string\" && !/\\./.test(keyPath) ? (obj)=>{\n        if (obj[keyPath] === undefined && keyPath in obj) {\n            obj = deepClone(obj);\n            delete obj[keyPath];\n        }\n        return obj;\n    } : (obj)=>obj;\n}\nclass Table {\n    _trans(mode, fn, writeLocked) {\n        const trans = this._tx || PSD.trans;\n        const tableName = this.name;\n        function checkTableInTransaction(resolve, reject, trans) {\n            if (!trans.schema[tableName]) throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n            return fn(trans.idbtrans, trans);\n        }\n        const wasRootExec = beginMicroTickScope();\n        try {\n            return trans && trans.db === this.db ? trans === PSD.trans ? trans._promise(mode, checkTableInTransaction, writeLocked) : newScope(()=>trans._promise(mode, checkTableInTransaction, writeLocked), {\n                trans: trans,\n                transless: PSD.transless || PSD\n            }) : tempTransaction(this.db, mode, [\n                this.name\n            ], checkTableInTransaction);\n        } finally{\n            if (wasRootExec) endMicroTickScope();\n        }\n    }\n    get(keyOrCrit, cb) {\n        if (keyOrCrit && keyOrCrit.constructor === Object) return this.where(keyOrCrit).first(cb);\n        return this._trans(\"readonly\", (trans)=>{\n            return this.core.get({\n                trans,\n                key: keyOrCrit\n            }).then((res)=>this.hook.reading.fire(res));\n        }).then(cb);\n    }\n    where(indexOrCrit) {\n        if (typeof indexOrCrit === \"string\") return new this.db.WhereClause(this, indexOrCrit);\n        if (isArray(indexOrCrit)) return new this.db.WhereClause(this, `[${indexOrCrit.join(\"+\")}]`);\n        const keyPaths = keys(indexOrCrit);\n        if (keyPaths.length === 1) return this.where(keyPaths[0]).equals(indexOrCrit[keyPaths[0]]);\n        const compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter((ix)=>{\n            if (ix.compound && keyPaths.every((keyPath)=>ix.keyPath.indexOf(keyPath) >= 0)) {\n                for(let i = 0; i < keyPaths.length; ++i){\n                    if (keyPaths.indexOf(ix.keyPath[i]) === -1) return false;\n                }\n                return true;\n            }\n            return false;\n        }).sort((a, b)=>a.keyPath.length - b.keyPath.length)[0];\n        if (compoundIndex && this.db._maxKey !== maxString) {\n            const keyPathsInValidOrder = compoundIndex.keyPath.slice(0, keyPaths.length);\n            return this.where(keyPathsInValidOrder).equals(keyPathsInValidOrder.map((kp)=>indexOrCrit[kp]));\n        }\n        if (!compoundIndex && debug) console.warn(`The query ${JSON.stringify(indexOrCrit)} on ${this.name} would benefit of a ` + `compound index [${keyPaths.join(\"+\")}]`);\n        const { idxByName } = this.schema;\n        const idb = this.db._deps.indexedDB;\n        function equals(a, b) {\n            try {\n                return idb.cmp(a, b) === 0;\n            } catch (e) {\n                return false;\n            }\n        }\n        const [idx, filterFunction] = keyPaths.reduce(([prevIndex, prevFilterFn], keyPath)=>{\n            const index = idxByName[keyPath];\n            const value = indexOrCrit[keyPath];\n            return [\n                prevIndex || index,\n                prevIndex || !index ? combine(prevFilterFn, index && index.multi ? (x)=>{\n                    const prop = getByKeyPath(x, keyPath);\n                    return isArray(prop) && prop.some((item)=>equals(value, item));\n                } : (x)=>equals(value, getByKeyPath(x, keyPath))) : prevFilterFn\n            ];\n        }, [\n            null,\n            null\n        ]);\n        return idx ? this.where(idx.name).equals(indexOrCrit[idx.keyPath]).filter(filterFunction) : compoundIndex ? this.filter(filterFunction) : this.where(keyPaths).equals(\"\");\n    }\n    filter(filterFunction) {\n        return this.toCollection().and(filterFunction);\n    }\n    count(thenShortcut) {\n        return this.toCollection().count(thenShortcut);\n    }\n    offset(offset) {\n        return this.toCollection().offset(offset);\n    }\n    limit(numRows) {\n        return this.toCollection().limit(numRows);\n    }\n    each(callback) {\n        return this.toCollection().each(callback);\n    }\n    toArray(thenShortcut) {\n        return this.toCollection().toArray(thenShortcut);\n    }\n    toCollection() {\n        return new this.db.Collection(new this.db.WhereClause(this));\n    }\n    orderBy(index) {\n        return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ? `[${index.join(\"+\")}]` : index));\n    }\n    reverse() {\n        return this.toCollection().reverse();\n    }\n    mapToClass(constructor) {\n        this.schema.mappedClass = constructor;\n        const readHook = (obj)=>{\n            if (!obj) return obj;\n            const res = Object.create(constructor.prototype);\n            for(var m in obj)if (hasOwn(obj, m)) try {\n                res[m] = obj[m];\n            } catch (_) {}\n            return res;\n        };\n        if (this.schema.readHook) {\n            this.hook.reading.unsubscribe(this.schema.readHook);\n        }\n        this.schema.readHook = readHook;\n        this.hook(\"reading\", readHook);\n        return constructor;\n    }\n    defineClass() {\n        function Class(content) {\n            extend(this, content);\n        }\n        return this.mapToClass(Class);\n    }\n    add(obj, key) {\n        const { auto, keyPath } = this.schema.primKey;\n        let objToAdd = obj;\n        if (keyPath && auto) {\n            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n        }\n        return this._trans(\"readwrite\", (trans)=>{\n            return this.core.mutate({\n                trans,\n                type: \"add\",\n                keys: key != null ? [\n                    key\n                ] : null,\n                values: [\n                    objToAdd\n                ]\n            });\n        }).then((res)=>res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult).then((lastResult)=>{\n            if (keyPath) {\n                try {\n                    setByKeyPath(obj, keyPath, lastResult);\n                } catch (_) {}\n            }\n            return lastResult;\n        });\n    }\n    update(keyOrObject, modifications) {\n        if (typeof keyOrObject === \"object\" && !isArray(keyOrObject)) {\n            const key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);\n            if (key === undefined) return rejection(new exceptions.InvalidArgument(\"Given object does not contain its primary key\"));\n            try {\n                if (typeof modifications !== \"function\") {\n                    keys(modifications).forEach((keyPath)=>{\n                        setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);\n                    });\n                } else {\n                    modifications(keyOrObject, {\n                        value: keyOrObject,\n                        primKey: key\n                    });\n                }\n            } catch (_a) {}\n            return this.where(\":id\").equals(key).modify(modifications);\n        } else {\n            return this.where(\":id\").equals(keyOrObject).modify(modifications);\n        }\n    }\n    put(obj, key) {\n        const { auto, keyPath } = this.schema.primKey;\n        let objToAdd = obj;\n        if (keyPath && auto) {\n            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n        }\n        return this._trans(\"readwrite\", (trans)=>this.core.mutate({\n                trans,\n                type: \"put\",\n                values: [\n                    objToAdd\n                ],\n                keys: key != null ? [\n                    key\n                ] : null\n            })).then((res)=>res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult).then((lastResult)=>{\n            if (keyPath) {\n                try {\n                    setByKeyPath(obj, keyPath, lastResult);\n                } catch (_) {}\n            }\n            return lastResult;\n        });\n    }\n    delete(key) {\n        return this._trans(\"readwrite\", (trans)=>this.core.mutate({\n                trans,\n                type: \"delete\",\n                keys: [\n                    key\n                ]\n            })).then((res)=>res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);\n    }\n    clear() {\n        return this._trans(\"readwrite\", (trans)=>this.core.mutate({\n                trans,\n                type: \"deleteRange\",\n                range: AnyRange\n            })).then((res)=>res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);\n    }\n    bulkGet(keys) {\n        return this._trans(\"readonly\", (trans)=>{\n            return this.core.getMany({\n                keys,\n                trans\n            }).then((result)=>result.map((res)=>this.hook.reading.fire(res)));\n        });\n    }\n    bulkAdd(objects, keysOrOptions, options) {\n        const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n        options = options || (keys ? undefined : keysOrOptions);\n        const wantResults = options ? options.allKeys : undefined;\n        return this._trans(\"readwrite\", (trans)=>{\n            const { auto, keyPath } = this.schema.primKey;\n            if (keyPath && keys) throw new exceptions.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n            if (keys && keys.length !== objects.length) throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n            const numObjects = objects.length;\n            let objectsToAdd = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;\n            return this.core.mutate({\n                trans,\n                type: \"add\",\n                keys: keys,\n                values: objectsToAdd,\n                wantResults\n            }).then(({ numFailures, results, lastResult, failures })=>{\n                const result = wantResults ? results : lastResult;\n                if (numFailures === 0) return result;\n                throw new BulkError(`${this.name}.bulkAdd(): ${numFailures} of ${numObjects} operations failed`, failures);\n            });\n        });\n    }\n    bulkPut(objects, keysOrOptions, options) {\n        const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n        options = options || (keys ? undefined : keysOrOptions);\n        const wantResults = options ? options.allKeys : undefined;\n        return this._trans(\"readwrite\", (trans)=>{\n            const { auto, keyPath } = this.schema.primKey;\n            if (keyPath && keys) throw new exceptions.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n            if (keys && keys.length !== objects.length) throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n            const numObjects = objects.length;\n            let objectsToPut = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;\n            return this.core.mutate({\n                trans,\n                type: \"put\",\n                keys: keys,\n                values: objectsToPut,\n                wantResults\n            }).then(({ numFailures, results, lastResult, failures })=>{\n                const result = wantResults ? results : lastResult;\n                if (numFailures === 0) return result;\n                throw new BulkError(`${this.name}.bulkPut(): ${numFailures} of ${numObjects} operations failed`, failures);\n            });\n        });\n    }\n    bulkDelete(keys) {\n        const numKeys = keys.length;\n        return this._trans(\"readwrite\", (trans)=>{\n            return this.core.mutate({\n                trans,\n                type: \"delete\",\n                keys: keys\n            });\n        }).then(({ numFailures, lastResult, failures })=>{\n            if (numFailures === 0) return lastResult;\n            throw new BulkError(`${this.name}.bulkDelete(): ${numFailures} of ${numKeys} operations failed`, failures);\n        });\n    }\n}\nfunction Events(ctx) {\n    var evs = {};\n    var rv = function(eventName, subscriber) {\n        if (subscriber) {\n            var i = arguments.length, args = new Array(i - 1);\n            while(--i)args[i - 1] = arguments[i];\n            evs[eventName].subscribe.apply(null, args);\n            return ctx;\n        } else if (typeof eventName === \"string\") {\n            return evs[eventName];\n        }\n    };\n    rv.addEventType = add;\n    for(var i = 1, l = arguments.length; i < l; ++i){\n        add(arguments[i]);\n    }\n    return rv;\n    function add(eventName, chainFunction, defaultFunction) {\n        if (typeof eventName === \"object\") return addConfiguredEvents(eventName);\n        if (!chainFunction) chainFunction = reverseStoppableEventChain;\n        if (!defaultFunction) defaultFunction = nop;\n        var context = {\n            subscribers: [],\n            fire: defaultFunction,\n            subscribe: function(cb) {\n                if (context.subscribers.indexOf(cb) === -1) {\n                    context.subscribers.push(cb);\n                    context.fire = chainFunction(context.fire, cb);\n                }\n            },\n            unsubscribe: function(cb) {\n                context.subscribers = context.subscribers.filter(function(fn) {\n                    return fn !== cb;\n                });\n                context.fire = context.subscribers.reduce(chainFunction, defaultFunction);\n            }\n        };\n        evs[eventName] = rv[eventName] = context;\n        return context;\n    }\n    function addConfiguredEvents(cfg) {\n        keys(cfg).forEach(function(eventName) {\n            var args = cfg[eventName];\n            if (isArray(args)) {\n                add(eventName, cfg[eventName][0], cfg[eventName][1]);\n            } else if (args === \"asap\") {\n                var context = add(eventName, mirror, function fire() {\n                    var i = arguments.length, args = new Array(i);\n                    while(i--)args[i] = arguments[i];\n                    context.subscribers.forEach(function(fn) {\n                        asap$1(function fireEvent() {\n                            fn.apply(null, args);\n                        });\n                    });\n                });\n            } else throw new exceptions.InvalidArgument(\"Invalid event config\");\n        });\n    }\n}\nfunction makeClassConstructor(prototype, constructor) {\n    derive(constructor).from({\n        prototype\n    });\n    return constructor;\n}\nfunction createTableConstructor(db) {\n    return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {\n        this.db = db;\n        this._tx = trans;\n        this.name = name;\n        this.schema = tableSchema;\n        this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {\n            \"creating\": [\n                hookCreatingChain,\n                nop\n            ],\n            \"reading\": [\n                pureFunctionChain,\n                mirror\n            ],\n            \"updating\": [\n                hookUpdatingChain,\n                nop\n            ],\n            \"deleting\": [\n                hookDeletingChain,\n                nop\n            ]\n        });\n    });\n}\nfunction isPlainKeyRange(ctx, ignoreLimitFilter) {\n    return !(ctx.filter || ctx.algorithm || ctx.or) && (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);\n}\nfunction addFilter(ctx, fn) {\n    ctx.filter = combine(ctx.filter, fn);\n}\nfunction addReplayFilter(ctx, factory, isLimitFilter) {\n    var curr = ctx.replayFilter;\n    ctx.replayFilter = curr ? ()=>combine(curr(), factory()) : factory;\n    ctx.justLimit = isLimitFilter && !curr;\n}\nfunction addMatchFilter(ctx, fn) {\n    ctx.isMatch = combine(ctx.isMatch, fn);\n}\nfunction getIndexOrStore(ctx, coreSchema) {\n    if (ctx.isPrimKey) return coreSchema.primaryKey;\n    const index = coreSchema.getIndexByKeyPath(ctx.index);\n    if (!index) throw new exceptions.Schema(\"KeyPath \" + ctx.index + \" on object store \" + coreSchema.name + \" is not indexed\");\n    return index;\n}\nfunction openCursor(ctx, coreTable, trans) {\n    const index = getIndexOrStore(ctx, coreTable.schema);\n    return coreTable.openCursor({\n        trans,\n        values: !ctx.keysOnly,\n        reverse: ctx.dir === \"prev\",\n        unique: !!ctx.unique,\n        query: {\n            index,\n            range: ctx.range\n        }\n    });\n}\nfunction iter(ctx, fn, coreTrans, coreTable) {\n    const filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;\n    if (!ctx.or) {\n        return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);\n    } else {\n        const set = {};\n        const union = (item, cursor, advance)=>{\n            if (!filter || filter(cursor, advance, (result)=>cursor.stop(result), (err)=>cursor.fail(err))) {\n                var primaryKey = cursor.primaryKey;\n                var key = \"\" + primaryKey;\n                if (key === \"[object ArrayBuffer]\") key = \"\" + new Uint8Array(primaryKey);\n                if (!hasOwn(set, key)) {\n                    set[key] = true;\n                    fn(item, cursor, advance);\n                }\n            }\n        };\n        return Promise.all([\n            ctx.or._iterate(union, coreTrans),\n            iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)\n        ]);\n    }\n}\nfunction iterate(cursorPromise, filter, fn, valueMapper) {\n    var mappedFn = valueMapper ? (x, c, a)=>fn(valueMapper(x), c, a) : fn;\n    var wrappedFn = wrap(mappedFn);\n    return cursorPromise.then((cursor)=>{\n        if (cursor) {\n            return cursor.start(()=>{\n                var c = ()=>cursor.continue();\n                if (!filter || filter(cursor, (advancer)=>c = advancer, (val)=>{\n                    cursor.stop(val);\n                    c = nop;\n                }, (e)=>{\n                    cursor.fail(e);\n                    c = nop;\n                })) wrappedFn(cursor.value, cursor, (advancer)=>c = advancer);\n                c();\n            });\n        }\n    });\n}\nfunction cmp(a, b) {\n    try {\n        const ta = type(a);\n        const tb = type(b);\n        if (ta !== tb) {\n            if (ta === \"Array\") return 1;\n            if (tb === \"Array\") return -1;\n            if (ta === \"binary\") return 1;\n            if (tb === \"binary\") return -1;\n            if (ta === \"string\") return 1;\n            if (tb === \"string\") return -1;\n            if (ta === \"Date\") return 1;\n            if (tb !== \"Date\") return NaN;\n            return -1;\n        }\n        switch(ta){\n            case \"number\":\n            case \"Date\":\n            case \"string\":\n                return a > b ? 1 : a < b ? -1 : 0;\n            case \"binary\":\n                {\n                    return compareUint8Arrays(getUint8Array(a), getUint8Array(b));\n                }\n            case \"Array\":\n                return compareArrays(a, b);\n        }\n    } catch (_a) {}\n    return NaN;\n}\nfunction compareArrays(a, b) {\n    const al = a.length;\n    const bl = b.length;\n    const l = al < bl ? al : bl;\n    for(let i = 0; i < l; ++i){\n        const res = cmp(a[i], b[i]);\n        if (res !== 0) return res;\n    }\n    return al === bl ? 0 : al < bl ? -1 : 1;\n}\nfunction compareUint8Arrays(a, b) {\n    const al = a.length;\n    const bl = b.length;\n    const l = al < bl ? al : bl;\n    for(let i = 0; i < l; ++i){\n        if (a[i] !== b[i]) return a[i] < b[i] ? -1 : 1;\n    }\n    return al === bl ? 0 : al < bl ? -1 : 1;\n}\nfunction type(x) {\n    const t = typeof x;\n    if (t !== \"object\") return t;\n    if (ArrayBuffer.isView(x)) return \"binary\";\n    const tsTag = toStringTag(x);\n    return tsTag === \"ArrayBuffer\" ? \"binary\" : tsTag;\n}\nfunction getUint8Array(a) {\n    if (a instanceof Uint8Array) return a;\n    if (ArrayBuffer.isView(a)) return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n    return new Uint8Array(a);\n}\nclass Collection {\n    _read(fn, cb) {\n        var ctx = this._ctx;\n        return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans(\"readonly\", fn).then(cb);\n    }\n    _write(fn) {\n        var ctx = this._ctx;\n        return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans(\"readwrite\", fn, \"locked\");\n    }\n    _addAlgorithm(fn) {\n        var ctx = this._ctx;\n        ctx.algorithm = combine(ctx.algorithm, fn);\n    }\n    _iterate(fn, coreTrans) {\n        return iter(this._ctx, fn, coreTrans, this._ctx.table.core);\n    }\n    clone(props) {\n        var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);\n        if (props) extend(ctx, props);\n        rv._ctx = ctx;\n        return rv;\n    }\n    raw() {\n        this._ctx.valueMapper = null;\n        return this;\n    }\n    each(fn) {\n        var ctx = this._ctx;\n        return this._read((trans)=>iter(ctx, fn, trans, ctx.table.core));\n    }\n    count(cb) {\n        return this._read((trans)=>{\n            const ctx = this._ctx;\n            const coreTable = ctx.table.core;\n            if (isPlainKeyRange(ctx, true)) {\n                return coreTable.count({\n                    trans,\n                    query: {\n                        index: getIndexOrStore(ctx, coreTable.schema),\n                        range: ctx.range\n                    }\n                }).then((count)=>Math.min(count, ctx.limit));\n            } else {\n                var count = 0;\n                return iter(ctx, ()=>{\n                    ++count;\n                    return false;\n                }, trans, coreTable).then(()=>count);\n            }\n        }).then(cb);\n    }\n    sortBy(keyPath, cb) {\n        const parts = keyPath.split(\".\").reverse(), lastPart = parts[0], lastIndex = parts.length - 1;\n        function getval(obj, i) {\n            if (i) return getval(obj[parts[i]], i - 1);\n            return obj[lastPart];\n        }\n        var order = this._ctx.dir === \"next\" ? 1 : -1;\n        function sorter(a, b) {\n            var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);\n            return aVal < bVal ? -order : aVal > bVal ? order : 0;\n        }\n        return this.toArray(function(a) {\n            return a.sort(sorter);\n        }).then(cb);\n    }\n    toArray(cb) {\n        return this._read((trans)=>{\n            var ctx = this._ctx;\n            if (ctx.dir === \"next\" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n                const { valueMapper } = ctx;\n                const index = getIndexOrStore(ctx, ctx.table.core.schema);\n                return ctx.table.core.query({\n                    trans,\n                    limit: ctx.limit,\n                    values: true,\n                    query: {\n                        index,\n                        range: ctx.range\n                    }\n                }).then(({ result })=>valueMapper ? result.map(valueMapper) : result);\n            } else {\n                const a = [];\n                return iter(ctx, (item)=>a.push(item), trans, ctx.table.core).then(()=>a);\n            }\n        }, cb);\n    }\n    offset(offset) {\n        var ctx = this._ctx;\n        if (offset <= 0) return this;\n        ctx.offset += offset;\n        if (isPlainKeyRange(ctx)) {\n            addReplayFilter(ctx, ()=>{\n                var offsetLeft = offset;\n                return (cursor, advance)=>{\n                    if (offsetLeft === 0) return true;\n                    if (offsetLeft === 1) {\n                        --offsetLeft;\n                        return false;\n                    }\n                    advance(()=>{\n                        cursor.advance(offsetLeft);\n                        offsetLeft = 0;\n                    });\n                    return false;\n                };\n            });\n        } else {\n            addReplayFilter(ctx, ()=>{\n                var offsetLeft = offset;\n                return ()=>--offsetLeft < 0;\n            });\n        }\n        return this;\n    }\n    limit(numRows) {\n        this._ctx.limit = Math.min(this._ctx.limit, numRows);\n        addReplayFilter(this._ctx, ()=>{\n            var rowsLeft = numRows;\n            return function(cursor, advance, resolve) {\n                if (--rowsLeft <= 0) advance(resolve);\n                return rowsLeft >= 0;\n            };\n        }, true);\n        return this;\n    }\n    until(filterFunction, bIncludeStopEntry) {\n        addFilter(this._ctx, function(cursor, advance, resolve) {\n            if (filterFunction(cursor.value)) {\n                advance(resolve);\n                return bIncludeStopEntry;\n            } else {\n                return true;\n            }\n        });\n        return this;\n    }\n    first(cb) {\n        return this.limit(1).toArray(function(a) {\n            return a[0];\n        }).then(cb);\n    }\n    last(cb) {\n        return this.reverse().first(cb);\n    }\n    filter(filterFunction) {\n        addFilter(this._ctx, function(cursor) {\n            return filterFunction(cursor.value);\n        });\n        addMatchFilter(this._ctx, filterFunction);\n        return this;\n    }\n    and(filter) {\n        return this.filter(filter);\n    }\n    or(indexName) {\n        return new this.db.WhereClause(this._ctx.table, indexName, this);\n    }\n    reverse() {\n        this._ctx.dir = this._ctx.dir === \"prev\" ? \"next\" : \"prev\";\n        if (this._ondirectionchange) this._ondirectionchange(this._ctx.dir);\n        return this;\n    }\n    desc() {\n        return this.reverse();\n    }\n    eachKey(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        return this.each(function(val, cursor) {\n            cb(cursor.key, cursor);\n        });\n    }\n    eachUniqueKey(cb) {\n        this._ctx.unique = \"unique\";\n        return this.eachKey(cb);\n    }\n    eachPrimaryKey(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        return this.each(function(val, cursor) {\n            cb(cursor.primaryKey, cursor);\n        });\n    }\n    keys(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        var a = [];\n        return this.each(function(item, cursor) {\n            a.push(cursor.key);\n        }).then(function() {\n            return a;\n        }).then(cb);\n    }\n    primaryKeys(cb) {\n        var ctx = this._ctx;\n        if (ctx.dir === \"next\" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n            return this._read((trans)=>{\n                var index = getIndexOrStore(ctx, ctx.table.core.schema);\n                return ctx.table.core.query({\n                    trans,\n                    values: false,\n                    limit: ctx.limit,\n                    query: {\n                        index,\n                        range: ctx.range\n                    }\n                });\n            }).then(({ result })=>result).then(cb);\n        }\n        ctx.keysOnly = !ctx.isMatch;\n        var a = [];\n        return this.each(function(item, cursor) {\n            a.push(cursor.primaryKey);\n        }).then(function() {\n            return a;\n        }).then(cb);\n    }\n    uniqueKeys(cb) {\n        this._ctx.unique = \"unique\";\n        return this.keys(cb);\n    }\n    firstKey(cb) {\n        return this.limit(1).keys(function(a) {\n            return a[0];\n        }).then(cb);\n    }\n    lastKey(cb) {\n        return this.reverse().firstKey(cb);\n    }\n    distinct() {\n        var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];\n        if (!idx || !idx.multi) return this;\n        var set = {};\n        addFilter(this._ctx, function(cursor) {\n            var strKey = cursor.primaryKey.toString();\n            var found = hasOwn(set, strKey);\n            set[strKey] = true;\n            return !found;\n        });\n        return this;\n    }\n    modify(changes) {\n        var ctx = this._ctx;\n        return this._write((trans)=>{\n            var modifyer;\n            if (typeof changes === \"function\") {\n                modifyer = changes;\n            } else {\n                var keyPaths = keys(changes);\n                var numKeys = keyPaths.length;\n                modifyer = function(item) {\n                    var anythingModified = false;\n                    for(var i = 0; i < numKeys; ++i){\n                        var keyPath = keyPaths[i], val = changes[keyPath];\n                        if (getByKeyPath(item, keyPath) !== val) {\n                            setByKeyPath(item, keyPath, val);\n                            anythingModified = true;\n                        }\n                    }\n                    return anythingModified;\n                };\n            }\n            const coreTable = ctx.table.core;\n            const { outbound, extractKey } = coreTable.schema.primaryKey;\n            const limit = this.db._options.modifyChunkSize || 200;\n            const totalFailures = [];\n            let successCount = 0;\n            const failedKeys = [];\n            const applyMutateResult = (expectedCount, res)=>{\n                const { failures, numFailures } = res;\n                successCount += expectedCount - numFailures;\n                for (let pos of keys(failures)){\n                    totalFailures.push(failures[pos]);\n                }\n            };\n            return this.clone().primaryKeys().then((keys)=>{\n                const nextChunk = (offset)=>{\n                    const count = Math.min(limit, keys.length - offset);\n                    return coreTable.getMany({\n                        trans,\n                        keys: keys.slice(offset, offset + count),\n                        cache: \"immutable\"\n                    }).then((values)=>{\n                        const addValues = [];\n                        const putValues = [];\n                        const putKeys = outbound ? [] : null;\n                        const deleteKeys = [];\n                        for(let i = 0; i < count; ++i){\n                            const origValue = values[i];\n                            const ctx = {\n                                value: deepClone(origValue),\n                                primKey: keys[offset + i]\n                            };\n                            if (modifyer.call(ctx, ctx.value, ctx) !== false) {\n                                if (ctx.value == null) {\n                                    deleteKeys.push(keys[offset + i]);\n                                } else if (!outbound && cmp(extractKey(origValue), extractKey(ctx.value)) !== 0) {\n                                    deleteKeys.push(keys[offset + i]);\n                                    addValues.push(ctx.value);\n                                } else {\n                                    putValues.push(ctx.value);\n                                    if (outbound) putKeys.push(keys[offset + i]);\n                                }\n                            }\n                        }\n                        const criteria = isPlainKeyRange(ctx) && ctx.limit === Infinity && (typeof changes !== \"function\" || changes === deleteCallback) && {\n                            index: ctx.index,\n                            range: ctx.range\n                        };\n                        return Promise.resolve(addValues.length > 0 && coreTable.mutate({\n                            trans,\n                            type: \"add\",\n                            values: addValues\n                        }).then((res)=>{\n                            for(let pos in res.failures){\n                                deleteKeys.splice(parseInt(pos), 1);\n                            }\n                            applyMutateResult(addValues.length, res);\n                        })).then(()=>(putValues.length > 0 || criteria && typeof changes === \"object\") && coreTable.mutate({\n                                trans,\n                                type: \"put\",\n                                keys: putKeys,\n                                values: putValues,\n                                criteria,\n                                changeSpec: typeof changes !== \"function\" && changes\n                            }).then((res)=>applyMutateResult(putValues.length, res))).then(()=>(deleteKeys.length > 0 || criteria && changes === deleteCallback) && coreTable.mutate({\n                                trans,\n                                type: \"delete\",\n                                keys: deleteKeys,\n                                criteria\n                            }).then((res)=>applyMutateResult(deleteKeys.length, res))).then(()=>{\n                            return keys.length > offset + count && nextChunk(offset + limit);\n                        });\n                    });\n                };\n                return nextChunk(0).then(()=>{\n                    if (totalFailures.length > 0) throw new ModifyError(\"Error modifying one or more objects\", totalFailures, successCount, failedKeys);\n                    return keys.length;\n                });\n            });\n        });\n    }\n    delete() {\n        var ctx = this._ctx, range = ctx.range;\n        if (isPlainKeyRange(ctx) && (ctx.isPrimKey && !hangsOnDeleteLargeKeyRange || range.type === 3)) {\n            return this._write((trans)=>{\n                const { primaryKey } = ctx.table.core.schema;\n                const coreRange = range;\n                return ctx.table.core.count({\n                    trans,\n                    query: {\n                        index: primaryKey,\n                        range: coreRange\n                    }\n                }).then((count)=>{\n                    return ctx.table.core.mutate({\n                        trans,\n                        type: \"deleteRange\",\n                        range: coreRange\n                    }).then(({ failures, lastResult, results, numFailures })=>{\n                        if (numFailures) throw new ModifyError(\"Could not delete some values\", Object.keys(failures).map((pos)=>failures[pos]), count - numFailures);\n                        return count - numFailures;\n                    });\n                });\n            });\n        }\n        return this.modify(deleteCallback);\n    }\n}\nconst deleteCallback = (value, ctx)=>ctx.value = null;\nfunction createCollectionConstructor(db) {\n    return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {\n        this.db = db;\n        let keyRange = AnyRange, error = null;\n        if (keyRangeGenerator) try {\n            keyRange = keyRangeGenerator();\n        } catch (ex) {\n            error = ex;\n        }\n        const whereCtx = whereClause._ctx;\n        const table = whereCtx.table;\n        const readingHook = table.hook.reading.fire;\n        this._ctx = {\n            table: table,\n            index: whereCtx.index,\n            isPrimKey: !whereCtx.index || table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name,\n            range: keyRange,\n            keysOnly: false,\n            dir: \"next\",\n            unique: \"\",\n            algorithm: null,\n            filter: null,\n            replayFilter: null,\n            justLimit: true,\n            isMatch: null,\n            offset: 0,\n            limit: Infinity,\n            error: error,\n            or: whereCtx.or,\n            valueMapper: readingHook !== mirror ? readingHook : null\n        };\n    });\n}\nfunction simpleCompare(a, b) {\n    return a < b ? -1 : a === b ? 0 : 1;\n}\nfunction simpleCompareReverse(a, b) {\n    return a > b ? -1 : a === b ? 0 : 1;\n}\nfunction fail(collectionOrWhereClause, err, T) {\n    var collection = collectionOrWhereClause instanceof WhereClause ? new collectionOrWhereClause.Collection(collectionOrWhereClause) : collectionOrWhereClause;\n    collection._ctx.error = T ? new T(err) : new TypeError(err);\n    return collection;\n}\nfunction emptyCollection(whereClause) {\n    return new whereClause.Collection(whereClause, ()=>rangeEqual(\"\")).limit(0);\n}\nfunction upperFactory(dir) {\n    return dir === \"next\" ? (s)=>s.toUpperCase() : (s)=>s.toLowerCase();\n}\nfunction lowerFactory(dir) {\n    return dir === \"next\" ? (s)=>s.toLowerCase() : (s)=>s.toUpperCase();\n}\nfunction nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {\n    var length = Math.min(key.length, lowerNeedle.length);\n    var llp = -1;\n    for(var i = 0; i < length; ++i){\n        var lwrKeyChar = lowerKey[i];\n        if (lwrKeyChar !== lowerNeedle[i]) {\n            if (cmp(key[i], upperNeedle[i]) < 0) return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);\n            if (cmp(key[i], lowerNeedle[i]) < 0) return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);\n            if (llp >= 0) return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);\n            return null;\n        }\n        if (cmp(key[i], lwrKeyChar) < 0) llp = i;\n    }\n    if (length < lowerNeedle.length && dir === \"next\") return key + upperNeedle.substr(key.length);\n    if (length < key.length && dir === \"prev\") return key.substr(0, upperNeedle.length);\n    return llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1);\n}\nfunction addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {\n    var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;\n    if (!needles.every((s)=>typeof s === \"string\")) {\n        return fail(whereClause, STRING_EXPECTED);\n    }\n    function initDirection(dir) {\n        upper = upperFactory(dir);\n        lower = lowerFactory(dir);\n        compare = dir === \"next\" ? simpleCompare : simpleCompareReverse;\n        var needleBounds = needles.map(function(needle) {\n            return {\n                lower: lower(needle),\n                upper: upper(needle)\n            };\n        }).sort(function(a, b) {\n            return compare(a.lower, b.lower);\n        });\n        upperNeedles = needleBounds.map(function(nb) {\n            return nb.upper;\n        });\n        lowerNeedles = needleBounds.map(function(nb) {\n            return nb.lower;\n        });\n        direction = dir;\n        nextKeySuffix = dir === \"next\" ? \"\" : suffix;\n    }\n    initDirection(\"next\");\n    var c = new whereClause.Collection(whereClause, ()=>createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix));\n    c._ondirectionchange = function(direction) {\n        initDirection(direction);\n    };\n    var firstPossibleNeedle = 0;\n    c._addAlgorithm(function(cursor, advance, resolve) {\n        var key = cursor.key;\n        if (typeof key !== \"string\") return false;\n        var lowerKey = lower(key);\n        if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {\n            return true;\n        } else {\n            var lowestPossibleCasing = null;\n            for(var i = firstPossibleNeedle; i < needlesLen; ++i){\n                var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);\n                if (casing === null && lowestPossibleCasing === null) firstPossibleNeedle = i + 1;\n                else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {\n                    lowestPossibleCasing = casing;\n                }\n            }\n            if (lowestPossibleCasing !== null) {\n                advance(function() {\n                    cursor.continue(lowestPossibleCasing + nextKeySuffix);\n                });\n            } else {\n                advance(resolve);\n            }\n            return false;\n        }\n    });\n    return c;\n}\nfunction createRange(lower, upper, lowerOpen, upperOpen) {\n    return {\n        type: 2,\n        lower,\n        upper,\n        lowerOpen,\n        upperOpen\n    };\n}\nfunction rangeEqual(value) {\n    return {\n        type: 1,\n        lower: value,\n        upper: value\n    };\n}\nclass WhereClause {\n    get Collection() {\n        return this._ctx.table.db.Collection;\n    }\n    between(lower, upper, includeLower, includeUpper) {\n        includeLower = includeLower !== false;\n        includeUpper = includeUpper === true;\n        try {\n            if (this._cmp(lower, upper) > 0 || this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)) return emptyCollection(this);\n            return new this.Collection(this, ()=>createRange(lower, upper, !includeLower, !includeUpper));\n        } catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n    }\n    equals(value) {\n        if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, ()=>rangeEqual(value));\n    }\n    above(value) {\n        if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, ()=>createRange(value, undefined, true));\n    }\n    aboveOrEqual(value) {\n        if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, ()=>createRange(value, undefined, false));\n    }\n    below(value) {\n        if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, ()=>createRange(undefined, value, false, true));\n    }\n    belowOrEqual(value) {\n        if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, ()=>createRange(undefined, value));\n    }\n    startsWith(str) {\n        if (typeof str !== \"string\") return fail(this, STRING_EXPECTED);\n        return this.between(str, str + maxString, true, true);\n    }\n    startsWithIgnoreCase(str) {\n        if (str === \"\") return this.startsWith(str);\n        return addIgnoreCaseAlgorithm(this, (x, a)=>x.indexOf(a[0]) === 0, [\n            str\n        ], maxString);\n    }\n    equalsIgnoreCase(str) {\n        return addIgnoreCaseAlgorithm(this, (x, a)=>x === a[0], [\n            str\n        ], \"\");\n    }\n    anyOfIgnoreCase() {\n        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0) return emptyCollection(this);\n        return addIgnoreCaseAlgorithm(this, (x, a)=>a.indexOf(x) !== -1, set, \"\");\n    }\n    startsWithAnyOfIgnoreCase() {\n        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0) return emptyCollection(this);\n        return addIgnoreCaseAlgorithm(this, (x, a)=>a.some((n)=>x.indexOf(n) === 0), set, maxString);\n    }\n    anyOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        let compare = this._cmp;\n        try {\n            set.sort(compare);\n        } catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        if (set.length === 0) return emptyCollection(this);\n        const c = new this.Collection(this, ()=>createRange(set[0], set[set.length - 1]));\n        c._ondirectionchange = (direction)=>{\n            compare = direction === \"next\" ? this._ascending : this._descending;\n            set.sort(compare);\n        };\n        let i = 0;\n        c._addAlgorithm((cursor, advance, resolve)=>{\n            const key = cursor.key;\n            while(compare(key, set[i]) > 0){\n                ++i;\n                if (i === set.length) {\n                    advance(resolve);\n                    return false;\n                }\n            }\n            if (compare(key, set[i]) === 0) {\n                return true;\n            } else {\n                advance(()=>{\n                    cursor.continue(set[i]);\n                });\n                return false;\n            }\n        });\n        return c;\n    }\n    notEqual(value) {\n        return this.inAnyRange([\n            [\n                minKey,\n                value\n            ],\n            [\n                value,\n                this.db._maxKey\n            ]\n        ], {\n            includeLowers: false,\n            includeUppers: false\n        });\n    }\n    noneOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0) return new this.Collection(this);\n        try {\n            set.sort(this._ascending);\n        } catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        const ranges = set.reduce((res, val)=>res ? res.concat([\n                [\n                    res[res.length - 1][1],\n                    val\n                ]\n            ]) : [\n                [\n                    minKey,\n                    val\n                ]\n            ], null);\n        ranges.push([\n            set[set.length - 1],\n            this.db._maxKey\n        ]);\n        return this.inAnyRange(ranges, {\n            includeLowers: false,\n            includeUppers: false\n        });\n    }\n    inAnyRange(ranges, options) {\n        const cmp = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;\n        if (ranges.length === 0) return emptyCollection(this);\n        if (!ranges.every((range)=>range[0] !== undefined && range[1] !== undefined && ascending(range[0], range[1]) <= 0)) {\n            return fail(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", exceptions.InvalidArgument);\n        }\n        const includeLowers = !options || options.includeLowers !== false;\n        const includeUppers = options && options.includeUppers === true;\n        function addRange(ranges, newRange) {\n            let i = 0, l = ranges.length;\n            for(; i < l; ++i){\n                const range = ranges[i];\n                if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {\n                    range[0] = min(range[0], newRange[0]);\n                    range[1] = max(range[1], newRange[1]);\n                    break;\n                }\n            }\n            if (i === l) ranges.push(newRange);\n            return ranges;\n        }\n        let sortDirection = ascending;\n        function rangeSorter(a, b) {\n            return sortDirection(a[0], b[0]);\n        }\n        let set;\n        try {\n            set = ranges.reduce(addRange, []);\n            set.sort(rangeSorter);\n        } catch (ex) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        let rangePos = 0;\n        const keyIsBeyondCurrentEntry = includeUppers ? (key)=>ascending(key, set[rangePos][1]) > 0 : (key)=>ascending(key, set[rangePos][1]) >= 0;\n        const keyIsBeforeCurrentEntry = includeLowers ? (key)=>descending(key, set[rangePos][0]) > 0 : (key)=>descending(key, set[rangePos][0]) >= 0;\n        function keyWithinCurrentRange(key) {\n            return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);\n        }\n        let checkKey = keyIsBeyondCurrentEntry;\n        const c = new this.Collection(this, ()=>createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers));\n        c._ondirectionchange = (direction)=>{\n            if (direction === \"next\") {\n                checkKey = keyIsBeyondCurrentEntry;\n                sortDirection = ascending;\n            } else {\n                checkKey = keyIsBeforeCurrentEntry;\n                sortDirection = descending;\n            }\n            set.sort(rangeSorter);\n        };\n        c._addAlgorithm((cursor, advance, resolve)=>{\n            var key = cursor.key;\n            while(checkKey(key)){\n                ++rangePos;\n                if (rangePos === set.length) {\n                    advance(resolve);\n                    return false;\n                }\n            }\n            if (keyWithinCurrentRange(key)) {\n                return true;\n            } else if (this._cmp(key, set[rangePos][1]) === 0 || this._cmp(key, set[rangePos][0]) === 0) {\n                return false;\n            } else {\n                advance(()=>{\n                    if (sortDirection === ascending) cursor.continue(set[rangePos][0]);\n                    else cursor.continue(set[rangePos][1]);\n                });\n                return false;\n            }\n        });\n        return c;\n    }\n    startsWithAnyOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (!set.every((s)=>typeof s === \"string\")) {\n            return fail(this, \"startsWithAnyOf() only works with strings\");\n        }\n        if (set.length === 0) return emptyCollection(this);\n        return this.inAnyRange(set.map((str)=>[\n                str,\n                str + maxString\n            ]));\n    }\n}\nfunction createWhereClauseConstructor(db) {\n    return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {\n        this.db = db;\n        this._ctx = {\n            table: table,\n            index: index === \":id\" ? null : index,\n            or: orCollection\n        };\n        const indexedDB1 = db._deps.indexedDB;\n        if (!indexedDB1) throw new exceptions.MissingAPI();\n        this._cmp = this._ascending = indexedDB1.cmp.bind(indexedDB1);\n        this._descending = (a, b)=>indexedDB1.cmp(b, a);\n        this._max = (a, b)=>indexedDB1.cmp(a, b) > 0 ? a : b;\n        this._min = (a, b)=>indexedDB1.cmp(a, b) < 0 ? a : b;\n        this._IDBKeyRange = db._deps.IDBKeyRange;\n    });\n}\nfunction eventRejectHandler(reject) {\n    return wrap(function(event) {\n        preventDefault(event);\n        reject(event.target.error);\n        return false;\n    });\n}\nfunction preventDefault(event) {\n    if (event.stopPropagation) event.stopPropagation();\n    if (event.preventDefault) event.preventDefault();\n}\nconst DEXIE_STORAGE_MUTATED_EVENT_NAME = \"storagemutated\";\nconst STORAGE_MUTATED_DOM_EVENT_NAME = \"x-storagemutated-1\";\nconst globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);\nclass Transaction {\n    _lock() {\n        assert(!PSD.global);\n        ++this._reculock;\n        if (this._reculock === 1 && !PSD.global) PSD.lockOwnerFor = this;\n        return this;\n    }\n    _unlock() {\n        assert(!PSD.global);\n        if (--this._reculock === 0) {\n            if (!PSD.global) PSD.lockOwnerFor = null;\n            while(this._blockedFuncs.length > 0 && !this._locked()){\n                var fnAndPSD = this._blockedFuncs.shift();\n                try {\n                    usePSD(fnAndPSD[1], fnAndPSD[0]);\n                } catch (e) {}\n            }\n        }\n        return this;\n    }\n    _locked() {\n        return this._reculock && PSD.lockOwnerFor !== this;\n    }\n    create(idbtrans) {\n        if (!this.mode) return this;\n        const idbdb = this.db.idbdb;\n        const dbOpenError = this.db._state.dbOpenError;\n        assert(!this.idbtrans);\n        if (!idbtrans && !idbdb) {\n            switch(dbOpenError && dbOpenError.name){\n                case \"DatabaseClosedError\":\n                    throw new exceptions.DatabaseClosed(dbOpenError);\n                case \"MissingAPIError\":\n                    throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);\n                default:\n                    throw new exceptions.OpenFailed(dbOpenError);\n            }\n        }\n        if (!this.active) throw new exceptions.TransactionInactive();\n        assert(this._completion._state === null);\n        idbtrans = this.idbtrans = idbtrans || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, {\n            durability: this.chromeTransactionDurability\n        }) : idbdb.transaction(this.storeNames, this.mode, {\n            durability: this.chromeTransactionDurability\n        }));\n        idbtrans.onerror = wrap((ev)=>{\n            preventDefault(ev);\n            this._reject(idbtrans.error);\n        });\n        idbtrans.onabort = wrap((ev)=>{\n            preventDefault(ev);\n            this.active && this._reject(new exceptions.Abort(idbtrans.error));\n            this.active = false;\n            this.on(\"abort\").fire(ev);\n        });\n        idbtrans.oncomplete = wrap(()=>{\n            this.active = false;\n            this._resolve();\n            if (\"mutatedParts\" in idbtrans) {\n                globalEvents.storagemutated.fire(idbtrans[\"mutatedParts\"]);\n            }\n        });\n        return this;\n    }\n    _promise(mode, fn, bWriteLock) {\n        if (mode === \"readwrite\" && this.mode !== \"readwrite\") return rejection(new exceptions.ReadOnly(\"Transaction is readonly\"));\n        if (!this.active) return rejection(new exceptions.TransactionInactive());\n        if (this._locked()) {\n            return new DexiePromise((resolve, reject)=>{\n                this._blockedFuncs.push([\n                    ()=>{\n                        this._promise(mode, fn, bWriteLock).then(resolve, reject);\n                    },\n                    PSD\n                ]);\n            });\n        } else if (bWriteLock) {\n            return newScope(()=>{\n                var p = new DexiePromise((resolve, reject)=>{\n                    this._lock();\n                    const rv = fn(resolve, reject, this);\n                    if (rv && rv.then) rv.then(resolve, reject);\n                });\n                p.finally(()=>this._unlock());\n                p._lib = true;\n                return p;\n            });\n        } else {\n            var p = new DexiePromise((resolve, reject)=>{\n                var rv = fn(resolve, reject, this);\n                if (rv && rv.then) rv.then(resolve, reject);\n            });\n            p._lib = true;\n            return p;\n        }\n    }\n    _root() {\n        return this.parent ? this.parent._root() : this;\n    }\n    waitFor(promiseLike) {\n        var root = this._root();\n        const promise = DexiePromise.resolve(promiseLike);\n        if (root._waitingFor) {\n            root._waitingFor = root._waitingFor.then(()=>promise);\n        } else {\n            root._waitingFor = promise;\n            root._waitingQueue = [];\n            var store = root.idbtrans.objectStore(root.storeNames[0]);\n            (function spin() {\n                ++root._spinCount;\n                while(root._waitingQueue.length)root._waitingQueue.shift()();\n                if (root._waitingFor) store.get(-Infinity).onsuccess = spin;\n            })();\n        }\n        var currentWaitPromise = root._waitingFor;\n        return new DexiePromise((resolve, reject)=>{\n            promise.then((res)=>root._waitingQueue.push(wrap(resolve.bind(null, res))), (err)=>root._waitingQueue.push(wrap(reject.bind(null, err)))).finally(()=>{\n                if (root._waitingFor === currentWaitPromise) {\n                    root._waitingFor = null;\n                }\n            });\n        });\n    }\n    abort() {\n        if (this.active) {\n            this.active = false;\n            if (this.idbtrans) this.idbtrans.abort();\n            this._reject(new exceptions.Abort());\n        }\n    }\n    table(tableName) {\n        const memoizedTables = this._memoizedTables || (this._memoizedTables = {});\n        if (hasOwn(memoizedTables, tableName)) return memoizedTables[tableName];\n        const tableSchema = this.schema[tableName];\n        if (!tableSchema) {\n            throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n        }\n        const transactionBoundTable = new this.db.Table(tableName, tableSchema, this);\n        transactionBoundTable.core = this.db.core.table(tableName);\n        memoizedTables[tableName] = transactionBoundTable;\n        return transactionBoundTable;\n    }\n}\nfunction createTransactionConstructor(db) {\n    return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {\n        this.db = db;\n        this.mode = mode;\n        this.storeNames = storeNames;\n        this.schema = dbschema;\n        this.chromeTransactionDurability = chromeTransactionDurability;\n        this.idbtrans = null;\n        this.on = Events(this, \"complete\", \"error\", \"abort\");\n        this.parent = parent || null;\n        this.active = true;\n        this._reculock = 0;\n        this._blockedFuncs = [];\n        this._resolve = null;\n        this._reject = null;\n        this._waitingFor = null;\n        this._waitingQueue = null;\n        this._spinCount = 0;\n        this._completion = new DexiePromise((resolve, reject)=>{\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n        this._completion.then(()=>{\n            this.active = false;\n            this.on.complete.fire();\n        }, (e)=>{\n            var wasActive = this.active;\n            this.active = false;\n            this.on.error.fire(e);\n            this.parent ? this.parent._reject(e) : wasActive && this.idbtrans && this.idbtrans.abort();\n            return rejection(e);\n        });\n    });\n}\nfunction createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {\n    return {\n        name,\n        keyPath,\n        unique,\n        multi,\n        auto,\n        compound,\n        src: (unique && !isPrimKey ? \"&\" : \"\") + (multi ? \"*\" : \"\") + (auto ? \"++\" : \"\") + nameFromKeyPath(keyPath)\n    };\n}\nfunction nameFromKeyPath(keyPath) {\n    return typeof keyPath === \"string\" ? keyPath : keyPath ? \"[\" + [].join.call(keyPath, \"+\") + \"]\" : \"\";\n}\nfunction createTableSchema(name, primKey, indexes) {\n    return {\n        name,\n        primKey,\n        indexes,\n        mappedClass: null,\n        idxByName: arrayToObject(indexes, (index)=>[\n                index.name,\n                index\n            ])\n    };\n}\nfunction safariMultiStoreFix(storeNames) {\n    return storeNames.length === 1 ? storeNames[0] : storeNames;\n}\nlet getMaxKey = (IdbKeyRange)=>{\n    try {\n        IdbKeyRange.only([\n            []\n        ]);\n        getMaxKey = ()=>[\n                []\n            ];\n        return [\n            []\n        ];\n    } catch (e) {\n        getMaxKey = ()=>maxString;\n        return maxString;\n    }\n};\nfunction getKeyExtractor(keyPath) {\n    if (keyPath == null) {\n        return ()=>undefined;\n    } else if (typeof keyPath === \"string\") {\n        return getSinglePathKeyExtractor(keyPath);\n    } else {\n        return (obj)=>getByKeyPath(obj, keyPath);\n    }\n}\nfunction getSinglePathKeyExtractor(keyPath) {\n    const split = keyPath.split(\".\");\n    if (split.length === 1) {\n        return (obj)=>obj[keyPath];\n    } else {\n        return (obj)=>getByKeyPath(obj, keyPath);\n    }\n}\nfunction arrayify(arrayLike) {\n    return [].slice.call(arrayLike);\n}\nlet _id_counter = 0;\nfunction getKeyPathAlias(keyPath) {\n    return keyPath == null ? \":id\" : typeof keyPath === \"string\" ? keyPath : `[${keyPath.join(\"+\")}]`;\n}\nfunction createDBCore(db, IdbKeyRange, tmpTrans) {\n    function extractSchema(db, trans) {\n        const tables = arrayify(db.objectStoreNames);\n        return {\n            schema: {\n                name: db.name,\n                tables: tables.map((table)=>trans.objectStore(table)).map((store)=>{\n                    const { keyPath, autoIncrement } = store;\n                    const compound = isArray(keyPath);\n                    const outbound = keyPath == null;\n                    const indexByKeyPath = {};\n                    const result = {\n                        name: store.name,\n                        primaryKey: {\n                            name: null,\n                            isPrimaryKey: true,\n                            outbound,\n                            compound,\n                            keyPath,\n                            autoIncrement,\n                            unique: true,\n                            extractKey: getKeyExtractor(keyPath)\n                        },\n                        indexes: arrayify(store.indexNames).map((indexName)=>store.index(indexName)).map((index)=>{\n                            const { name, unique, multiEntry, keyPath } = index;\n                            const compound = isArray(keyPath);\n                            const result = {\n                                name,\n                                compound,\n                                keyPath,\n                                unique,\n                                multiEntry,\n                                extractKey: getKeyExtractor(keyPath)\n                            };\n                            indexByKeyPath[getKeyPathAlias(keyPath)] = result;\n                            return result;\n                        }),\n                        getIndexByKeyPath: (keyPath)=>indexByKeyPath[getKeyPathAlias(keyPath)]\n                    };\n                    indexByKeyPath[\":id\"] = result.primaryKey;\n                    if (keyPath != null) {\n                        indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;\n                    }\n                    return result;\n                })\n            },\n            hasGetAll: tables.length > 0 && \"getAll\" in trans.objectStore(tables[0]) && !(typeof navigator !== \"undefined\" && /Safari/.test(navigator.userAgent) && !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604)\n        };\n    }\n    function makeIDBKeyRange(range) {\n        if (range.type === 3) return null;\n        if (range.type === 4) throw new Error(\"Cannot convert never type to IDBKeyRange\");\n        const { lower, upper, lowerOpen, upperOpen } = range;\n        const idbRange = lower === undefined ? upper === undefined ? null : IdbKeyRange.upperBound(upper, !!upperOpen) : upper === undefined ? IdbKeyRange.lowerBound(lower, !!lowerOpen) : IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);\n        return idbRange;\n    }\n    function createDbCoreTable(tableSchema) {\n        const tableName = tableSchema.name;\n        function mutate({ trans, type, keys, values, range }) {\n            return new Promise((resolve, reject)=>{\n                resolve = wrap(resolve);\n                const store = trans.objectStore(tableName);\n                const outbound = store.keyPath == null;\n                const isAddOrPut = type === \"put\" || type === \"add\";\n                if (!isAddOrPut && type !== \"delete\" && type !== \"deleteRange\") throw new Error(\"Invalid operation type: \" + type);\n                const { length } = keys || values || {\n                    length: 1\n                };\n                if (keys && values && keys.length !== values.length) {\n                    throw new Error(\"Given keys array must have same length as given values array.\");\n                }\n                if (length === 0) return resolve({\n                    numFailures: 0,\n                    failures: {},\n                    results: [],\n                    lastResult: undefined\n                });\n                let req;\n                const reqs = [];\n                const failures = [];\n                let numFailures = 0;\n                const errorHandler = (event)=>{\n                    ++numFailures;\n                    preventDefault(event);\n                };\n                if (type === \"deleteRange\") {\n                    if (range.type === 4) return resolve({\n                        numFailures,\n                        failures,\n                        results: [],\n                        lastResult: undefined\n                    });\n                    if (range.type === 3) reqs.push(req = store.clear());\n                    else reqs.push(req = store.delete(makeIDBKeyRange(range)));\n                } else {\n                    const [args1, args2] = isAddOrPut ? outbound ? [\n                        values,\n                        keys\n                    ] : [\n                        values,\n                        null\n                    ] : [\n                        keys,\n                        null\n                    ];\n                    if (isAddOrPut) {\n                        for(let i = 0; i < length; ++i){\n                            reqs.push(req = args2 && args2[i] !== undefined ? store[type](args1[i], args2[i]) : store[type](args1[i]));\n                            req.onerror = errorHandler;\n                        }\n                    } else {\n                        for(let i = 0; i < length; ++i){\n                            reqs.push(req = store[type](args1[i]));\n                            req.onerror = errorHandler;\n                        }\n                    }\n                }\n                const done = (event)=>{\n                    const lastResult = event.target.result;\n                    reqs.forEach((req, i)=>req.error != null && (failures[i] = req.error));\n                    resolve({\n                        numFailures,\n                        failures,\n                        results: type === \"delete\" ? keys : reqs.map((req)=>req.result),\n                        lastResult\n                    });\n                };\n                req.onerror = (event)=>{\n                    errorHandler(event);\n                    done(event);\n                };\n                req.onsuccess = done;\n            });\n        }\n        function openCursor({ trans, values, query, reverse, unique }) {\n            return new Promise((resolve, reject)=>{\n                resolve = wrap(resolve);\n                const { index, range } = query;\n                const store = trans.objectStore(tableName);\n                const source = index.isPrimaryKey ? store : store.index(index.name);\n                const direction = reverse ? unique ? \"prevunique\" : \"prev\" : unique ? \"nextunique\" : \"next\";\n                const req = values || !(\"openKeyCursor\" in source) ? source.openCursor(makeIDBKeyRange(range), direction) : source.openKeyCursor(makeIDBKeyRange(range), direction);\n                req.onerror = eventRejectHandler(reject);\n                req.onsuccess = wrap((ev)=>{\n                    const cursor = req.result;\n                    if (!cursor) {\n                        resolve(null);\n                        return;\n                    }\n                    cursor.___id = ++_id_counter;\n                    cursor.done = false;\n                    const _cursorContinue = cursor.continue.bind(cursor);\n                    let _cursorContinuePrimaryKey = cursor.continuePrimaryKey;\n                    if (_cursorContinuePrimaryKey) _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);\n                    const _cursorAdvance = cursor.advance.bind(cursor);\n                    const doThrowCursorIsNotStarted = ()=>{\n                        throw new Error(\"Cursor not started\");\n                    };\n                    const doThrowCursorIsStopped = ()=>{\n                        throw new Error(\"Cursor not stopped\");\n                    };\n                    cursor.trans = trans;\n                    cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;\n                    cursor.fail = wrap(reject);\n                    cursor.next = function() {\n                        let gotOne = 1;\n                        return this.start(()=>gotOne-- ? this.continue() : this.stop()).then(()=>this);\n                    };\n                    cursor.start = (callback)=>{\n                        const iterationPromise = new Promise((resolveIteration, rejectIteration)=>{\n                            resolveIteration = wrap(resolveIteration);\n                            req.onerror = eventRejectHandler(rejectIteration);\n                            cursor.fail = rejectIteration;\n                            cursor.stop = (value)=>{\n                                cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;\n                                resolveIteration(value);\n                            };\n                        });\n                        const guardedCallback = ()=>{\n                            if (req.result) {\n                                try {\n                                    callback();\n                                } catch (err) {\n                                    cursor.fail(err);\n                                }\n                            } else {\n                                cursor.done = true;\n                                cursor.start = ()=>{\n                                    throw new Error(\"Cursor behind last entry\");\n                                };\n                                cursor.stop();\n                            }\n                        };\n                        req.onsuccess = wrap((ev)=>{\n                            req.onsuccess = guardedCallback;\n                            guardedCallback();\n                        });\n                        cursor.continue = _cursorContinue;\n                        cursor.continuePrimaryKey = _cursorContinuePrimaryKey;\n                        cursor.advance = _cursorAdvance;\n                        guardedCallback();\n                        return iterationPromise;\n                    };\n                    resolve(cursor);\n                }, reject);\n            });\n        }\n        function query(hasGetAll) {\n            return (request)=>{\n                return new Promise((resolve, reject)=>{\n                    resolve = wrap(resolve);\n                    const { trans, values, limit, query } = request;\n                    const nonInfinitLimit = limit === Infinity ? undefined : limit;\n                    const { index, range } = query;\n                    const store = trans.objectStore(tableName);\n                    const source = index.isPrimaryKey ? store : store.index(index.name);\n                    const idbKeyRange = makeIDBKeyRange(range);\n                    if (limit === 0) return resolve({\n                        result: []\n                    });\n                    if (hasGetAll) {\n                        const req = values ? source.getAll(idbKeyRange, nonInfinitLimit) : source.getAllKeys(idbKeyRange, nonInfinitLimit);\n                        req.onsuccess = (event)=>resolve({\n                                result: event.target.result\n                            });\n                        req.onerror = eventRejectHandler(reject);\n                    } else {\n                        let count = 0;\n                        const req = values || !(\"openKeyCursor\" in source) ? source.openCursor(idbKeyRange) : source.openKeyCursor(idbKeyRange);\n                        const result = [];\n                        req.onsuccess = (event)=>{\n                            const cursor = req.result;\n                            if (!cursor) return resolve({\n                                result\n                            });\n                            result.push(values ? cursor.value : cursor.primaryKey);\n                            if (++count === limit) return resolve({\n                                result\n                            });\n                            cursor.continue();\n                        };\n                        req.onerror = eventRejectHandler(reject);\n                    }\n                });\n            };\n        }\n        return {\n            name: tableName,\n            schema: tableSchema,\n            mutate,\n            getMany ({ trans, keys }) {\n                return new Promise((resolve, reject)=>{\n                    resolve = wrap(resolve);\n                    const store = trans.objectStore(tableName);\n                    const length = keys.length;\n                    const result = new Array(length);\n                    let keyCount = 0;\n                    let callbackCount = 0;\n                    let req;\n                    const successHandler = (event)=>{\n                        const req = event.target;\n                        if ((result[req._pos] = req.result) != null) ;\n                        if (++callbackCount === keyCount) resolve(result);\n                    };\n                    const errorHandler = eventRejectHandler(reject);\n                    for(let i = 0; i < length; ++i){\n                        const key = keys[i];\n                        if (key != null) {\n                            req = store.get(keys[i]);\n                            req._pos = i;\n                            req.onsuccess = successHandler;\n                            req.onerror = errorHandler;\n                            ++keyCount;\n                        }\n                    }\n                    if (keyCount === 0) resolve(result);\n                });\n            },\n            get ({ trans, key }) {\n                return new Promise((resolve, reject)=>{\n                    resolve = wrap(resolve);\n                    const store = trans.objectStore(tableName);\n                    const req = store.get(key);\n                    req.onsuccess = (event)=>resolve(event.target.result);\n                    req.onerror = eventRejectHandler(reject);\n                });\n            },\n            query: query(hasGetAll),\n            openCursor,\n            count ({ query, trans }) {\n                const { index, range } = query;\n                return new Promise((resolve, reject)=>{\n                    const store = trans.objectStore(tableName);\n                    const source = index.isPrimaryKey ? store : store.index(index.name);\n                    const idbKeyRange = makeIDBKeyRange(range);\n                    const req = idbKeyRange ? source.count(idbKeyRange) : source.count();\n                    req.onsuccess = wrap((ev)=>resolve(ev.target.result));\n                    req.onerror = eventRejectHandler(reject);\n                });\n            }\n        };\n    }\n    const { schema, hasGetAll } = extractSchema(db, tmpTrans);\n    const tables = schema.tables.map((tableSchema)=>createDbCoreTable(tableSchema));\n    const tableMap = {};\n    tables.forEach((table)=>tableMap[table.name] = table);\n    return {\n        stack: \"dbcore\",\n        transaction: db.transaction.bind(db),\n        table (name) {\n            const result = tableMap[name];\n            if (!result) throw new Error(`Table '${name}' not found`);\n            return tableMap[name];\n        },\n        MIN_KEY: -Infinity,\n        MAX_KEY: getMaxKey(IdbKeyRange),\n        schema\n    };\n}\nfunction createMiddlewareStack(stackImpl, middlewares) {\n    return middlewares.reduce((down, { create })=>({\n            ...down,\n            ...create(down)\n        }), stackImpl);\n}\nfunction createMiddlewareStacks(middlewares, idbdb, { IDBKeyRange, indexedDB: indexedDB1 }, tmpTrans) {\n    const dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);\n    return {\n        dbcore\n    };\n}\nfunction generateMiddlewareStacks({ _novip: db }, tmpTrans) {\n    const idbdb = tmpTrans.db;\n    const stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);\n    db.core = stacks.dbcore;\n    db.tables.forEach((table)=>{\n        const tableName = table.name;\n        if (db.core.schema.tables.some((tbl)=>tbl.name === tableName)) {\n            table.core = db.core.table(tableName);\n            if (db[tableName] instanceof db.Table) {\n                db[tableName].core = table.core;\n            }\n        }\n    });\n}\nfunction setApiOnPlace({ _novip: db }, objs, tableNames, dbschema) {\n    tableNames.forEach((tableName)=>{\n        const schema = dbschema[tableName];\n        objs.forEach((obj)=>{\n            const propDesc = getPropertyDescriptor(obj, tableName);\n            if (!propDesc || \"value\" in propDesc && propDesc.value === undefined) {\n                if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {\n                    setProp(obj, tableName, {\n                        get () {\n                            return this.table(tableName);\n                        },\n                        set (value) {\n                            defineProperty(this, tableName, {\n                                value,\n                                writable: true,\n                                configurable: true,\n                                enumerable: true\n                            });\n                        }\n                    });\n                } else {\n                    obj[tableName] = new db.Table(tableName, schema);\n                }\n            }\n        });\n    });\n}\nfunction removeTablesApi({ _novip: db }, objs) {\n    objs.forEach((obj)=>{\n        for(let key in obj){\n            if (obj[key] instanceof db.Table) delete obj[key];\n        }\n    });\n}\nfunction lowerVersionFirst(a, b) {\n    return a._cfg.version - b._cfg.version;\n}\nfunction runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {\n    const globalSchema = db._dbSchema;\n    const trans = db._createTransaction(\"readwrite\", db._storeNames, globalSchema);\n    trans.create(idbUpgradeTrans);\n    trans._completion.catch(reject);\n    const rejectTransaction = trans._reject.bind(trans);\n    const transless = PSD.transless || PSD;\n    newScope(()=>{\n        PSD.trans = trans;\n        PSD.transless = transless;\n        if (oldVersion === 0) {\n            keys(globalSchema).forEach((tableName)=>{\n                createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);\n            });\n            generateMiddlewareStacks(db, idbUpgradeTrans);\n            DexiePromise.follow(()=>db.on.populate.fire(trans)).catch(rejectTransaction);\n        } else updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);\n    });\n}\nfunction updateTablesAndIndexes({ _novip: db }, oldVersion, trans, idbUpgradeTrans) {\n    const queue = [];\n    const versions = db._versions;\n    let globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n    let anyContentUpgraderHasRun = false;\n    const versToRun = versions.filter((v)=>v._cfg.version >= oldVersion);\n    versToRun.forEach((version)=>{\n        queue.push(()=>{\n            const oldSchema = globalSchema;\n            const newSchema = version._cfg.dbschema;\n            adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);\n            adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);\n            globalSchema = db._dbSchema = newSchema;\n            const diff = getSchemaDiff(oldSchema, newSchema);\n            diff.add.forEach((tuple)=>{\n                createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);\n            });\n            diff.change.forEach((change)=>{\n                if (change.recreate) {\n                    throw new exceptions.Upgrade(\"Not yet support for changing primary key\");\n                } else {\n                    const store = idbUpgradeTrans.objectStore(change.name);\n                    change.add.forEach((idx)=>addIndex(store, idx));\n                    change.change.forEach((idx)=>{\n                        store.deleteIndex(idx.name);\n                        addIndex(store, idx);\n                    });\n                    change.del.forEach((idxName)=>store.deleteIndex(idxName));\n                }\n            });\n            const contentUpgrade = version._cfg.contentUpgrade;\n            if (contentUpgrade && version._cfg.version > oldVersion) {\n                generateMiddlewareStacks(db, idbUpgradeTrans);\n                trans._memoizedTables = {};\n                anyContentUpgraderHasRun = true;\n                let upgradeSchema = shallowClone(newSchema);\n                diff.del.forEach((table)=>{\n                    upgradeSchema[table] = oldSchema[table];\n                });\n                removeTablesApi(db, [\n                    db.Transaction.prototype\n                ]);\n                setApiOnPlace(db, [\n                    db.Transaction.prototype\n                ], keys(upgradeSchema), upgradeSchema);\n                trans.schema = upgradeSchema;\n                const contentUpgradeIsAsync = isAsyncFunction(contentUpgrade);\n                if (contentUpgradeIsAsync) {\n                    incrementExpectedAwaits();\n                }\n                let returnValue;\n                const promiseFollowed = DexiePromise.follow(()=>{\n                    returnValue = contentUpgrade(trans);\n                    if (returnValue) {\n                        if (contentUpgradeIsAsync) {\n                            var decrementor = decrementExpectedAwaits.bind(null, null);\n                            returnValue.then(decrementor, decrementor);\n                        }\n                    }\n                });\n                return returnValue && typeof returnValue.then === \"function\" ? DexiePromise.resolve(returnValue) : promiseFollowed.then(()=>returnValue);\n            }\n        });\n        queue.push((idbtrans)=>{\n            if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {\n                const newSchema = version._cfg.dbschema;\n                deleteRemovedTables(newSchema, idbtrans);\n            }\n            removeTablesApi(db, [\n                db.Transaction.prototype\n            ]);\n            setApiOnPlace(db, [\n                db.Transaction.prototype\n            ], db._storeNames, db._dbSchema);\n            trans.schema = db._dbSchema;\n        });\n    });\n    function runQueue() {\n        return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) : DexiePromise.resolve();\n    }\n    return runQueue().then(()=>{\n        createMissingTables(globalSchema, idbUpgradeTrans);\n    });\n}\nfunction getSchemaDiff(oldSchema, newSchema) {\n    const diff = {\n        del: [],\n        add: [],\n        change: []\n    };\n    let table;\n    for(table in oldSchema){\n        if (!newSchema[table]) diff.del.push(table);\n    }\n    for(table in newSchema){\n        const oldDef = oldSchema[table], newDef = newSchema[table];\n        if (!oldDef) {\n            diff.add.push([\n                table,\n                newDef\n            ]);\n        } else {\n            const change = {\n                name: table,\n                def: newDef,\n                recreate: false,\n                del: [],\n                add: [],\n                change: []\n            };\n            if (\"\" + (oldDef.primKey.keyPath || \"\") !== \"\" + (newDef.primKey.keyPath || \"\") || oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge) {\n                change.recreate = true;\n                diff.change.push(change);\n            } else {\n                const oldIndexes = oldDef.idxByName;\n                const newIndexes = newDef.idxByName;\n                let idxName;\n                for(idxName in oldIndexes){\n                    if (!newIndexes[idxName]) change.del.push(idxName);\n                }\n                for(idxName in newIndexes){\n                    const oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];\n                    if (!oldIdx) change.add.push(newIdx);\n                    else if (oldIdx.src !== newIdx.src) change.change.push(newIdx);\n                }\n                if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {\n                    diff.change.push(change);\n                }\n            }\n        }\n    }\n    return diff;\n}\nfunction createTable(idbtrans, tableName, primKey, indexes) {\n    const store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ? {\n        keyPath: primKey.keyPath,\n        autoIncrement: primKey.auto\n    } : {\n        autoIncrement: primKey.auto\n    });\n    indexes.forEach((idx)=>addIndex(store, idx));\n    return store;\n}\nfunction createMissingTables(newSchema, idbtrans) {\n    keys(newSchema).forEach((tableName)=>{\n        if (!idbtrans.db.objectStoreNames.contains(tableName)) {\n            createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);\n        }\n    });\n}\nfunction deleteRemovedTables(newSchema, idbtrans) {\n    [].slice.call(idbtrans.db.objectStoreNames).forEach((storeName)=>newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName));\n}\nfunction addIndex(store, idx) {\n    store.createIndex(idx.name, idx.keyPath, {\n        unique: idx.unique,\n        multiEntry: idx.multi\n    });\n}\nfunction buildGlobalSchema(db, idbdb, tmpTrans) {\n    const globalSchema = {};\n    const dbStoreNames = slice(idbdb.objectStoreNames, 0);\n    dbStoreNames.forEach((storeName)=>{\n        const store = tmpTrans.objectStore(storeName);\n        let keyPath = store.keyPath;\n        const primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || \"\", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== \"string\", true);\n        const indexes = [];\n        for(let j = 0; j < store.indexNames.length; ++j){\n            const idbindex = store.index(store.indexNames[j]);\n            keyPath = idbindex.keyPath;\n            var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== \"string\", false);\n            indexes.push(index);\n        }\n        globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);\n    });\n    return globalSchema;\n}\nfunction readGlobalSchema({ _novip: db }, idbdb, tmpTrans) {\n    db.verno = idbdb.version / 10;\n    const globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);\n    db._storeNames = slice(idbdb.objectStoreNames, 0);\n    setApiOnPlace(db, [\n        db._allTables\n    ], keys(globalSchema), globalSchema);\n}\nfunction verifyInstalledSchema(db, tmpTrans) {\n    const installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);\n    const diff = getSchemaDiff(installedSchema, db._dbSchema);\n    return !(diff.add.length || diff.change.some((ch)=>ch.add.length || ch.change.length));\n}\nfunction adjustToExistingIndexNames({ _novip: db }, schema, idbtrans) {\n    const storeNames = idbtrans.db.objectStoreNames;\n    for(let i = 0; i < storeNames.length; ++i){\n        const storeName = storeNames[i];\n        const store = idbtrans.objectStore(storeName);\n        db._hasGetAll = \"getAll\" in store;\n        for(let j = 0; j < store.indexNames.length; ++j){\n            const indexName = store.indexNames[j];\n            const keyPath = store.index(indexName).keyPath;\n            const dexieName = typeof keyPath === \"string\" ? keyPath : \"[\" + slice(keyPath).join(\"+\") + \"]\";\n            if (schema[storeName]) {\n                const indexSpec = schema[storeName].idxByName[dexieName];\n                if (indexSpec) {\n                    indexSpec.name = indexName;\n                    delete schema[storeName].idxByName[dexieName];\n                    schema[storeName].idxByName[indexName] = indexSpec;\n                }\n            }\n        }\n    }\n    if (typeof navigator !== \"undefined\" && /Safari/.test(navigator.userAgent) && !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) && _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604) {\n        db._hasGetAll = false;\n    }\n}\nfunction parseIndexSyntax(primKeyAndIndexes) {\n    return primKeyAndIndexes.split(\",\").map((index, indexNum)=>{\n        index = index.trim();\n        const name = index.replace(/([&*]|\\+\\+)/g, \"\");\n        const keyPath = /^\\[/.test(name) ? name.match(/^\\[(.*)\\]$/)[1].split(\"+\") : name;\n        return createIndexSpec(name, keyPath || null, /\\&/.test(index), /\\*/.test(index), /\\+\\+/.test(index), isArray(keyPath), indexNum === 0);\n    });\n}\nclass Version {\n    _parseStoresSpec(stores, outSchema) {\n        keys(stores).forEach((tableName)=>{\n            if (stores[tableName] !== null) {\n                var indexes = parseIndexSyntax(stores[tableName]);\n                var primKey = indexes.shift();\n                if (primKey.multi) throw new exceptions.Schema(\"Primary key cannot be multi-valued\");\n                indexes.forEach((idx)=>{\n                    if (idx.auto) throw new exceptions.Schema(\"Only primary key can be marked as autoIncrement (++)\");\n                    if (!idx.keyPath) throw new exceptions.Schema(\"Index must have a name and cannot be an empty string\");\n                });\n                outSchema[tableName] = createTableSchema(tableName, primKey, indexes);\n            }\n        });\n    }\n    stores(stores) {\n        const db = this.db;\n        this._cfg.storesSource = this._cfg.storesSource ? extend(this._cfg.storesSource, stores) : stores;\n        const versions = db._versions;\n        const storesSpec = {};\n        let dbschema = {};\n        versions.forEach((version)=>{\n            extend(storesSpec, version._cfg.storesSource);\n            dbschema = version._cfg.dbschema = {};\n            version._parseStoresSpec(storesSpec, dbschema);\n        });\n        db._dbSchema = dbschema;\n        removeTablesApi(db, [\n            db._allTables,\n            db,\n            db.Transaction.prototype\n        ]);\n        setApiOnPlace(db, [\n            db._allTables,\n            db,\n            db.Transaction.prototype,\n            this._cfg.tables\n        ], keys(dbschema), dbschema);\n        db._storeNames = keys(dbschema);\n        return this;\n    }\n    upgrade(upgradeFunction) {\n        this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);\n        return this;\n    }\n}\nfunction createVersionConstructor(db) {\n    return makeClassConstructor(Version.prototype, function Version(versionNumber) {\n        this.db = db;\n        this._cfg = {\n            version: versionNumber,\n            storesSource: null,\n            dbschema: {},\n            tables: {},\n            contentUpgrade: null\n        };\n    });\n}\nfunction getDbNamesTable(indexedDB1, IDBKeyRange) {\n    let dbNamesDB = indexedDB1[\"_dbNamesDB\"];\n    if (!dbNamesDB) {\n        dbNamesDB = indexedDB1[\"_dbNamesDB\"] = new Dexie$1(DBNAMES_DB, {\n            addons: [],\n            indexedDB: indexedDB1,\n            IDBKeyRange\n        });\n        dbNamesDB.version(1).stores({\n            dbnames: \"name\"\n        });\n    }\n    return dbNamesDB.table(\"dbnames\");\n}\nfunction hasDatabasesNative(indexedDB1) {\n    return indexedDB1 && typeof indexedDB1.databases === \"function\";\n}\nfunction getDatabaseNames({ indexedDB: indexedDB1, IDBKeyRange }) {\n    return hasDatabasesNative(indexedDB1) ? Promise.resolve(indexedDB1.databases()).then((infos)=>infos.map((info)=>info.name).filter((name)=>name !== DBNAMES_DB)) : getDbNamesTable(indexedDB1, IDBKeyRange).toCollection().primaryKeys();\n}\nfunction _onDatabaseCreated({ indexedDB: indexedDB1, IDBKeyRange }, name) {\n    !hasDatabasesNative(indexedDB1) && name !== DBNAMES_DB && getDbNamesTable(indexedDB1, IDBKeyRange).put({\n        name\n    }).catch(nop);\n}\nfunction _onDatabaseDeleted({ indexedDB: indexedDB1, IDBKeyRange }, name) {\n    !hasDatabasesNative(indexedDB1) && name !== DBNAMES_DB && getDbNamesTable(indexedDB1, IDBKeyRange).delete(name).catch(nop);\n}\nfunction vip(fn) {\n    return newScope(function() {\n        PSD.letThrough = true;\n        return fn();\n    });\n}\nfunction idbReady() {\n    var isSafari = !navigator.userAgentData && /Safari\\//.test(navigator.userAgent) && !/Chrom(e|ium)\\//.test(navigator.userAgent);\n    if (!isSafari || !indexedDB.databases) return Promise.resolve();\n    var intervalId;\n    return new Promise(function(resolve) {\n        var tryIdb = function() {\n            return indexedDB.databases().finally(resolve);\n        };\n        intervalId = setInterval(tryIdb, 100);\n        tryIdb();\n    }).finally(function() {\n        return clearInterval(intervalId);\n    });\n}\nfunction dexieOpen(db) {\n    const state = db._state;\n    const { indexedDB: indexedDB1 } = db._deps;\n    if (state.isBeingOpened || db.idbdb) return state.dbReadyPromise.then(()=>state.dbOpenError ? rejection(state.dbOpenError) : db);\n    debug && (state.openCanceller._stackHolder = getErrorWithStack());\n    state.isBeingOpened = true;\n    state.dbOpenError = null;\n    state.openComplete = false;\n    const openCanceller = state.openCanceller;\n    function throwIfCancelled() {\n        if (state.openCanceller !== openCanceller) throw new exceptions.DatabaseClosed(\"db.open() was cancelled\");\n    }\n    let resolveDbReady = state.dbReadyResolve, upgradeTransaction = null, wasCreated = false;\n    const tryOpenDB = ()=>new DexiePromise((resolve, reject)=>{\n            throwIfCancelled();\n            if (!indexedDB1) throw new exceptions.MissingAPI();\n            const dbName = db.name;\n            const req = state.autoSchema ? indexedDB1.open(dbName) : indexedDB1.open(dbName, Math.round(db.verno * 10));\n            if (!req) throw new exceptions.MissingAPI();\n            req.onerror = eventRejectHandler(reject);\n            req.onblocked = wrap(db._fireOnBlocked);\n            req.onupgradeneeded = wrap((e)=>{\n                upgradeTransaction = req.transaction;\n                if (state.autoSchema && !db._options.allowEmptyDB) {\n                    req.onerror = preventDefault;\n                    upgradeTransaction.abort();\n                    req.result.close();\n                    const delreq = indexedDB1.deleteDatabase(dbName);\n                    delreq.onsuccess = delreq.onerror = wrap(()=>{\n                        reject(new exceptions.NoSuchDatabase(`Database ${dbName} doesnt exist`));\n                    });\n                } else {\n                    upgradeTransaction.onerror = eventRejectHandler(reject);\n                    var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;\n                    wasCreated = oldVer < 1;\n                    db._novip.idbdb = req.result;\n                    runUpgraders(db, oldVer / 10, upgradeTransaction, reject);\n                }\n            }, reject);\n            req.onsuccess = wrap(()=>{\n                upgradeTransaction = null;\n                const idbdb = db._novip.idbdb = req.result;\n                const objectStoreNames = slice(idbdb.objectStoreNames);\n                if (objectStoreNames.length > 0) try {\n                    const tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), \"readonly\");\n                    if (state.autoSchema) readGlobalSchema(db, idbdb, tmpTrans);\n                    else {\n                        adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);\n                        if (!verifyInstalledSchema(db, tmpTrans)) {\n                            console.warn(`Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.`);\n                        }\n                    }\n                    generateMiddlewareStacks(db, tmpTrans);\n                } catch (e) {}\n                connections.push(db);\n                idbdb.onversionchange = wrap((ev)=>{\n                    state.vcFired = true;\n                    db.on(\"versionchange\").fire(ev);\n                });\n                idbdb.onclose = wrap((ev)=>{\n                    db.on(\"close\").fire(ev);\n                });\n                if (wasCreated) _onDatabaseCreated(db._deps, dbName);\n                resolve();\n            }, reject);\n        }).catch((err)=>{\n            if (err && err.name === \"UnknownError\" && state.PR1398_maxLoop > 0) {\n                state.PR1398_maxLoop--;\n                console.warn(\"Dexie: Workaround for Chrome UnknownError on open()\");\n                return tryOpenDB();\n            } else {\n                return DexiePromise.reject(err);\n            }\n        });\n    return DexiePromise.race([\n        openCanceller,\n        (typeof navigator === \"undefined\" ? DexiePromise.resolve() : idbReady()).then(tryOpenDB)\n    ]).then(()=>{\n        throwIfCancelled();\n        state.onReadyBeingFired = [];\n        return DexiePromise.resolve(vip(()=>db.on.ready.fire(db.vip))).then(function fireRemainders() {\n            if (state.onReadyBeingFired.length > 0) {\n                let remainders = state.onReadyBeingFired.reduce(promisableChain, nop);\n                state.onReadyBeingFired = [];\n                return DexiePromise.resolve(vip(()=>remainders(db.vip))).then(fireRemainders);\n            }\n        });\n    }).finally(()=>{\n        state.onReadyBeingFired = null;\n        state.isBeingOpened = false;\n    }).then(()=>{\n        return db;\n    }).catch((err)=>{\n        state.dbOpenError = err;\n        try {\n            upgradeTransaction && upgradeTransaction.abort();\n        } catch (_a) {}\n        if (openCanceller === state.openCanceller) {\n            db._close();\n        }\n        return rejection(err);\n    }).finally(()=>{\n        state.openComplete = true;\n        resolveDbReady();\n    });\n}\nfunction awaitIterator(iterator) {\n    var callNext = (result)=>iterator.next(result), doThrow = (error)=>iterator.throw(error), onSuccess = step(callNext), onError = step(doThrow);\n    function step(getNext) {\n        return (val)=>{\n            var next = getNext(val), value = next.value;\n            return next.done ? value : !value || typeof value.then !== \"function\" ? isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) : value.then(onSuccess, onError);\n        };\n    }\n    return step(callNext)();\n}\nfunction extractTransactionArgs(mode, _tableArgs_, scopeFunc) {\n    var i = arguments.length;\n    if (i < 2) throw new exceptions.InvalidArgument(\"Too few arguments\");\n    var args = new Array(i - 1);\n    while(--i)args[i - 1] = arguments[i];\n    scopeFunc = args.pop();\n    var tables = flatten(args);\n    return [\n        mode,\n        tables,\n        scopeFunc\n    ];\n}\nfunction enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {\n    return DexiePromise.resolve().then(()=>{\n        const transless = PSD.transless || PSD;\n        const trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);\n        const zoneProps = {\n            trans: trans,\n            transless: transless\n        };\n        if (parentTransaction) {\n            trans.idbtrans = parentTransaction.idbtrans;\n        } else {\n            try {\n                trans.create();\n                db._state.PR1398_maxLoop = 3;\n            } catch (ex) {\n                if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n                    console.warn(\"Dexie: Need to reopen db\");\n                    db._close();\n                    return db.open().then(()=>enterTransactionScope(db, mode, storeNames, null, scopeFunc));\n                }\n                return rejection(ex);\n            }\n        }\n        const scopeFuncIsAsync = isAsyncFunction(scopeFunc);\n        if (scopeFuncIsAsync) {\n            incrementExpectedAwaits();\n        }\n        let returnValue;\n        const promiseFollowed = DexiePromise.follow(()=>{\n            returnValue = scopeFunc.call(trans, trans);\n            if (returnValue) {\n                if (scopeFuncIsAsync) {\n                    var decrementor = decrementExpectedAwaits.bind(null, null);\n                    returnValue.then(decrementor, decrementor);\n                } else if (typeof returnValue.next === \"function\" && typeof returnValue.throw === \"function\") {\n                    returnValue = awaitIterator(returnValue);\n                }\n            }\n        }, zoneProps);\n        return (returnValue && typeof returnValue.then === \"function\" ? DexiePromise.resolve(returnValue).then((x)=>trans.active ? x : rejection(new exceptions.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\"))) : promiseFollowed.then(()=>returnValue)).then((x)=>{\n            if (parentTransaction) trans._resolve();\n            return trans._completion.then(()=>x);\n        }).catch((e)=>{\n            trans._reject(e);\n            return rejection(e);\n        });\n    });\n}\nfunction pad(a, value, count) {\n    const result = isArray(a) ? a.slice() : [\n        a\n    ];\n    for(let i = 0; i < count; ++i)result.push(value);\n    return result;\n}\nfunction createVirtualIndexMiddleware(down) {\n    return {\n        ...down,\n        table (tableName) {\n            const table = down.table(tableName);\n            const { schema } = table;\n            const indexLookup = {};\n            const allVirtualIndexes = [];\n            function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {\n                const keyPathAlias = getKeyPathAlias(keyPath);\n                const indexList = indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || [];\n                const keyLength = keyPath == null ? 0 : typeof keyPath === \"string\" ? 1 : keyPath.length;\n                const isVirtual = keyTail > 0;\n                const virtualIndex = {\n                    ...lowLevelIndex,\n                    isVirtual,\n                    keyTail,\n                    keyLength,\n                    extractKey: getKeyExtractor(keyPath),\n                    unique: !isVirtual && lowLevelIndex.unique\n                };\n                indexList.push(virtualIndex);\n                if (!virtualIndex.isPrimaryKey) {\n                    allVirtualIndexes.push(virtualIndex);\n                }\n                if (keyLength > 1) {\n                    const virtualKeyPath = keyLength === 2 ? keyPath[0] : keyPath.slice(0, keyLength - 1);\n                    addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);\n                }\n                indexList.sort((a, b)=>a.keyTail - b.keyTail);\n                return virtualIndex;\n            }\n            const primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);\n            indexLookup[\":id\"] = [\n                primaryKey\n            ];\n            for (const index of schema.indexes){\n                addVirtualIndexes(index.keyPath, 0, index);\n            }\n            function findBestIndex(keyPath) {\n                const result = indexLookup[getKeyPathAlias(keyPath)];\n                return result && result[0];\n            }\n            function translateRange(range, keyTail) {\n                return {\n                    type: range.type === 1 ? 2 : range.type,\n                    lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),\n                    lowerOpen: true,\n                    upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),\n                    upperOpen: true\n                };\n            }\n            function translateRequest(req) {\n                const index = req.query.index;\n                return index.isVirtual ? {\n                    ...req,\n                    query: {\n                        index,\n                        range: translateRange(req.query.range, index.keyTail)\n                    }\n                } : req;\n            }\n            const result = {\n                ...table,\n                schema: {\n                    ...schema,\n                    primaryKey,\n                    indexes: allVirtualIndexes,\n                    getIndexByKeyPath: findBestIndex\n                },\n                count (req) {\n                    return table.count(translateRequest(req));\n                },\n                query (req) {\n                    return table.query(translateRequest(req));\n                },\n                openCursor (req) {\n                    const { keyTail, isVirtual, keyLength } = req.query.index;\n                    if (!isVirtual) return table.openCursor(req);\n                    function createVirtualCursor(cursor) {\n                        function _continue(key) {\n                            key != null ? cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) : req.unique ? cursor.continue(cursor.key.slice(0, keyLength).concat(req.reverse ? down.MIN_KEY : down.MAX_KEY, keyTail)) : cursor.continue();\n                        }\n                        const virtualCursor = Object.create(cursor, {\n                            continue: {\n                                value: _continue\n                            },\n                            continuePrimaryKey: {\n                                value (key, primaryKey) {\n                                    cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);\n                                }\n                            },\n                            primaryKey: {\n                                get () {\n                                    return cursor.primaryKey;\n                                }\n                            },\n                            key: {\n                                get () {\n                                    const key = cursor.key;\n                                    return keyLength === 1 ? key[0] : key.slice(0, keyLength);\n                                }\n                            },\n                            value: {\n                                get () {\n                                    return cursor.value;\n                                }\n                            }\n                        });\n                        return virtualCursor;\n                    }\n                    return table.openCursor(translateRequest(req)).then((cursor)=>cursor && createVirtualCursor(cursor));\n                }\n            };\n            return result;\n        }\n    };\n}\nconst virtualIndexMiddleware = {\n    stack: \"dbcore\",\n    name: \"VirtualIndexMiddleware\",\n    level: 1,\n    create: createVirtualIndexMiddleware\n};\nfunction getObjectDiff(a, b, rv, prfx) {\n    rv = rv || {};\n    prfx = prfx || \"\";\n    keys(a).forEach((prop)=>{\n        if (!hasOwn(b, prop)) {\n            rv[prfx + prop] = undefined;\n        } else {\n            var ap = a[prop], bp = b[prop];\n            if (typeof ap === \"object\" && typeof bp === \"object\" && ap && bp) {\n                const apTypeName = toStringTag(ap);\n                const bpTypeName = toStringTag(bp);\n                if (apTypeName !== bpTypeName) {\n                    rv[prfx + prop] = b[prop];\n                } else if (apTypeName === \"Object\") {\n                    getObjectDiff(ap, bp, rv, prfx + prop + \".\");\n                } else if (ap !== bp) {\n                    rv[prfx + prop] = b[prop];\n                }\n            } else if (ap !== bp) rv[prfx + prop] = b[prop];\n        }\n    });\n    keys(b).forEach((prop)=>{\n        if (!hasOwn(a, prop)) {\n            rv[prfx + prop] = b[prop];\n        }\n    });\n    return rv;\n}\nfunction getEffectiveKeys(primaryKey, req) {\n    if (req.type === \"delete\") return req.keys;\n    return req.keys || req.values.map(primaryKey.extractKey);\n}\nconst hooksMiddleware = {\n    stack: \"dbcore\",\n    name: \"HooksMiddleware\",\n    level: 2,\n    create: (downCore)=>({\n            ...downCore,\n            table (tableName) {\n                const downTable = downCore.table(tableName);\n                const { primaryKey } = downTable.schema;\n                const tableMiddleware = {\n                    ...downTable,\n                    mutate (req) {\n                        const dxTrans = PSD.trans;\n                        const { deleting, creating, updating } = dxTrans.table(tableName).hook;\n                        switch(req.type){\n                            case \"add\":\n                                if (creating.fire === nop) break;\n                                return dxTrans._promise(\"readwrite\", ()=>addPutOrDelete(req), true);\n                            case \"put\":\n                                if (creating.fire === nop && updating.fire === nop) break;\n                                return dxTrans._promise(\"readwrite\", ()=>addPutOrDelete(req), true);\n                            case \"delete\":\n                                if (deleting.fire === nop) break;\n                                return dxTrans._promise(\"readwrite\", ()=>addPutOrDelete(req), true);\n                            case \"deleteRange\":\n                                if (deleting.fire === nop) break;\n                                return dxTrans._promise(\"readwrite\", ()=>deleteRange(req), true);\n                        }\n                        return downTable.mutate(req);\n                        function addPutOrDelete(req) {\n                            const dxTrans = PSD.trans;\n                            const keys = req.keys || getEffectiveKeys(primaryKey, req);\n                            if (!keys) throw new Error(\"Keys missing\");\n                            req = req.type === \"add\" || req.type === \"put\" ? {\n                                ...req,\n                                keys\n                            } : {\n                                ...req\n                            };\n                            if (req.type !== \"delete\") req.values = [\n                                ...req.values\n                            ];\n                            if (req.keys) req.keys = [\n                                ...req.keys\n                            ];\n                            return getExistingValues(downTable, req, keys).then((existingValues)=>{\n                                const contexts = keys.map((key, i)=>{\n                                    const existingValue = existingValues[i];\n                                    const ctx = {\n                                        onerror: null,\n                                        onsuccess: null\n                                    };\n                                    if (req.type === \"delete\") {\n                                        deleting.fire.call(ctx, key, existingValue, dxTrans);\n                                    } else if (req.type === \"add\" || existingValue === undefined) {\n                                        const generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);\n                                        if (key == null && generatedPrimaryKey != null) {\n                                            key = generatedPrimaryKey;\n                                            req.keys[i] = key;\n                                            if (!primaryKey.outbound) {\n                                                setByKeyPath(req.values[i], primaryKey.keyPath, key);\n                                            }\n                                        }\n                                    } else {\n                                        const objectDiff = getObjectDiff(existingValue, req.values[i]);\n                                        const additionalChanges = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);\n                                        if (additionalChanges) {\n                                            const requestedValue = req.values[i];\n                                            Object.keys(additionalChanges).forEach((keyPath)=>{\n                                                if (hasOwn(requestedValue, keyPath)) {\n                                                    requestedValue[keyPath] = additionalChanges[keyPath];\n                                                } else {\n                                                    setByKeyPath(requestedValue, keyPath, additionalChanges[keyPath]);\n                                                }\n                                            });\n                                        }\n                                    }\n                                    return ctx;\n                                });\n                                return downTable.mutate(req).then(({ failures, results, numFailures, lastResult })=>{\n                                    for(let i = 0; i < keys.length; ++i){\n                                        const primKey = results ? results[i] : keys[i];\n                                        const ctx = contexts[i];\n                                        if (primKey == null) {\n                                            ctx.onerror && ctx.onerror(failures[i]);\n                                        } else {\n                                            ctx.onsuccess && ctx.onsuccess(req.type === \"put\" && existingValues[i] ? req.values[i] : primKey);\n                                        }\n                                    }\n                                    return {\n                                        failures,\n                                        results,\n                                        numFailures,\n                                        lastResult\n                                    };\n                                }).catch((error)=>{\n                                    contexts.forEach((ctx)=>ctx.onerror && ctx.onerror(error));\n                                    return Promise.reject(error);\n                                });\n                            });\n                        }\n                        function deleteRange(req) {\n                            return deleteNextChunk(req.trans, req.range, 10000);\n                        }\n                        function deleteNextChunk(trans, range, limit) {\n                            return downTable.query({\n                                trans,\n                                values: false,\n                                query: {\n                                    index: primaryKey,\n                                    range\n                                },\n                                limit\n                            }).then(({ result })=>{\n                                return addPutOrDelete({\n                                    type: \"delete\",\n                                    keys: result,\n                                    trans\n                                }).then((res)=>{\n                                    if (res.numFailures > 0) return Promise.reject(res.failures[0]);\n                                    if (result.length < limit) {\n                                        return {\n                                            failures: [],\n                                            numFailures: 0,\n                                            lastResult: undefined\n                                        };\n                                    } else {\n                                        return deleteNextChunk(trans, {\n                                            ...range,\n                                            lower: result[result.length - 1],\n                                            lowerOpen: true\n                                        }, limit);\n                                    }\n                                });\n                            });\n                        }\n                    }\n                };\n                return tableMiddleware;\n            }\n        })\n};\nfunction getExistingValues(table, req, effectiveKeys) {\n    return req.type === \"add\" ? Promise.resolve([]) : table.getMany({\n        trans: req.trans,\n        keys: effectiveKeys,\n        cache: \"immutable\"\n    });\n}\nfunction getFromTransactionCache(keys, cache, clone) {\n    try {\n        if (!cache) return null;\n        if (cache.keys.length < keys.length) return null;\n        const result = [];\n        for(let i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i){\n            if (cmp(cache.keys[i], keys[j]) !== 0) continue;\n            result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);\n            ++j;\n        }\n        return result.length === keys.length ? result : null;\n    } catch (_a) {\n        return null;\n    }\n}\nconst cacheExistingValuesMiddleware = {\n    stack: \"dbcore\",\n    level: -1,\n    create: (core)=>{\n        return {\n            table: (tableName)=>{\n                const table = core.table(tableName);\n                return {\n                    ...table,\n                    getMany: (req)=>{\n                        if (!req.cache) {\n                            return table.getMany(req);\n                        }\n                        const cachedResult = getFromTransactionCache(req.keys, req.trans[\"_cache\"], req.cache === \"clone\");\n                        if (cachedResult) {\n                            return DexiePromise.resolve(cachedResult);\n                        }\n                        return table.getMany(req).then((res)=>{\n                            req.trans[\"_cache\"] = {\n                                keys: req.keys,\n                                values: req.cache === \"clone\" ? deepClone(res) : res\n                            };\n                            return res;\n                        });\n                    },\n                    mutate: (req)=>{\n                        if (req.type !== \"add\") req.trans[\"_cache\"] = null;\n                        return table.mutate(req);\n                    }\n                };\n            }\n        };\n    }\n};\nfunction isEmptyRange(node) {\n    return !(\"from\" in node);\n}\nconst RangeSet = function(fromOrTree, to) {\n    if (this) {\n        extend(this, arguments.length ? {\n            d: 1,\n            from: fromOrTree,\n            to: arguments.length > 1 ? to : fromOrTree\n        } : {\n            d: 0\n        });\n    } else {\n        const rv = new RangeSet();\n        if (fromOrTree && \"d\" in fromOrTree) {\n            extend(rv, fromOrTree);\n        }\n        return rv;\n    }\n};\nprops(RangeSet.prototype, {\n    add (rangeSet) {\n        mergeRanges(this, rangeSet);\n        return this;\n    },\n    addKey (key) {\n        addRange(this, key, key);\n        return this;\n    },\n    addKeys (keys) {\n        keys.forEach((key)=>addRange(this, key, key));\n        return this;\n    },\n    [iteratorSymbol] () {\n        return getRangeSetIterator(this);\n    }\n});\nfunction addRange(target, from, to) {\n    const diff = cmp(from, to);\n    if (isNaN(diff)) return;\n    if (diff > 0) throw RangeError();\n    if (isEmptyRange(target)) return extend(target, {\n        from,\n        to,\n        d: 1\n    });\n    const left = target.l;\n    const right = target.r;\n    if (cmp(to, target.from) < 0) {\n        left ? addRange(left, from, to) : target.l = {\n            from,\n            to,\n            d: 1,\n            l: null,\n            r: null\n        };\n        return rebalance(target);\n    }\n    if (cmp(from, target.to) > 0) {\n        right ? addRange(right, from, to) : target.r = {\n            from,\n            to,\n            d: 1,\n            l: null,\n            r: null\n        };\n        return rebalance(target);\n    }\n    if (cmp(from, target.from) < 0) {\n        target.from = from;\n        target.l = null;\n        target.d = right ? right.d + 1 : 1;\n    }\n    if (cmp(to, target.to) > 0) {\n        target.to = to;\n        target.r = null;\n        target.d = target.l ? target.l.d + 1 : 1;\n    }\n    const rightWasCutOff = !target.r;\n    if (left && !target.l) {\n        mergeRanges(target, left);\n    }\n    if (right && rightWasCutOff) {\n        mergeRanges(target, right);\n    }\n}\nfunction mergeRanges(target, newSet) {\n    function _addRangeSet(target, { from, to, l, r }) {\n        addRange(target, from, to);\n        if (l) _addRangeSet(target, l);\n        if (r) _addRangeSet(target, r);\n    }\n    if (!isEmptyRange(newSet)) _addRangeSet(target, newSet);\n}\nfunction rangesOverlap(rangeSet1, rangeSet2) {\n    const i1 = getRangeSetIterator(rangeSet2);\n    let nextResult1 = i1.next();\n    if (nextResult1.done) return false;\n    let a = nextResult1.value;\n    const i2 = getRangeSetIterator(rangeSet1);\n    let nextResult2 = i2.next(a.from);\n    let b = nextResult2.value;\n    while(!nextResult1.done && !nextResult2.done){\n        if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0) return true;\n        cmp(a.from, b.from) < 0 ? a = (nextResult1 = i1.next(b.from)).value : b = (nextResult2 = i2.next(a.from)).value;\n    }\n    return false;\n}\nfunction getRangeSetIterator(node) {\n    let state = isEmptyRange(node) ? null : {\n        s: 0,\n        n: node\n    };\n    return {\n        next (key) {\n            const keyProvided = arguments.length > 0;\n            while(state){\n                switch(state.s){\n                    case 0:\n                        state.s = 1;\n                        if (keyProvided) {\n                            while(state.n.l && cmp(key, state.n.from) < 0)state = {\n                                up: state,\n                                n: state.n.l,\n                                s: 1\n                            };\n                        } else {\n                            while(state.n.l)state = {\n                                up: state,\n                                n: state.n.l,\n                                s: 1\n                            };\n                        }\n                    case 1:\n                        state.s = 2;\n                        if (!keyProvided || cmp(key, state.n.to) <= 0) return {\n                            value: state.n,\n                            done: false\n                        };\n                    case 2:\n                        if (state.n.r) {\n                            state.s = 3;\n                            state = {\n                                up: state,\n                                n: state.n.r,\n                                s: 0\n                            };\n                            continue;\n                        }\n                    case 3:\n                        state = state.up;\n                }\n            }\n            return {\n                done: true\n            };\n        }\n    };\n}\nfunction rebalance(target) {\n    var _a, _b;\n    const diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);\n    const r = diff > 1 ? \"r\" : diff < -1 ? \"l\" : \"\";\n    if (r) {\n        const l = r === \"r\" ? \"l\" : \"r\";\n        const rootClone = {\n            ...target\n        };\n        const oldRootRight = target[r];\n        target.from = oldRootRight.from;\n        target.to = oldRootRight.to;\n        target[r] = oldRootRight[r];\n        rootClone[r] = oldRootRight[l];\n        target[l] = rootClone;\n        rootClone.d = computeDepth(rootClone);\n    }\n    target.d = computeDepth(target);\n}\nfunction computeDepth({ r, l }) {\n    return (r ? l ? Math.max(r.d, l.d) : r.d : l ? l.d : 0) + 1;\n}\nconst observabilityMiddleware = {\n    stack: \"dbcore\",\n    level: 0,\n    create: (core)=>{\n        const dbName = core.schema.name;\n        const FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);\n        return {\n            ...core,\n            table: (tableName)=>{\n                const table = core.table(tableName);\n                const { schema } = table;\n                const { primaryKey } = schema;\n                const { extractKey, outbound } = primaryKey;\n                const tableClone = {\n                    ...table,\n                    mutate: (req)=>{\n                        const trans = req.trans;\n                        const mutatedParts = trans.mutatedParts || (trans.mutatedParts = {});\n                        const getRangeSet = (indexName)=>{\n                            const part = `idb://${dbName}/${tableName}/${indexName}`;\n                            return mutatedParts[part] || (mutatedParts[part] = new RangeSet());\n                        };\n                        const pkRangeSet = getRangeSet(\"\");\n                        const delsRangeSet = getRangeSet(\":dels\");\n                        const { type } = req;\n                        let [keys, newObjs] = req.type === \"deleteRange\" ? [\n                            req.range\n                        ] : req.type === \"delete\" ? [\n                            req.keys\n                        ] : req.values.length < 50 ? [\n                            [],\n                            req.values\n                        ] : [];\n                        const oldCache = req.trans[\"_cache\"];\n                        return table.mutate(req).then((res)=>{\n                            if (isArray(keys)) {\n                                if (type !== \"delete\") keys = res.results;\n                                pkRangeSet.addKeys(keys);\n                                const oldObjs = getFromTransactionCache(keys, oldCache);\n                                if (!oldObjs && type !== \"add\") {\n                                    delsRangeSet.addKeys(keys);\n                                }\n                                if (oldObjs || newObjs) {\n                                    trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);\n                                }\n                            } else if (keys) {\n                                const range = {\n                                    from: keys.lower,\n                                    to: keys.upper\n                                };\n                                delsRangeSet.add(range);\n                                pkRangeSet.add(range);\n                            } else {\n                                pkRangeSet.add(FULL_RANGE);\n                                delsRangeSet.add(FULL_RANGE);\n                                schema.indexes.forEach((idx)=>getRangeSet(idx.name).add(FULL_RANGE));\n                            }\n                            return res;\n                        });\n                    }\n                };\n                const getRange = ({ query: { index, range } })=>{\n                    var _a, _b;\n                    return [\n                        index,\n                        new RangeSet((_a = range.lower) !== null && _a !== void 0 ? _a : core.MIN_KEY, (_b = range.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY)\n                    ];\n                };\n                const readSubscribers = {\n                    get: (req)=>[\n                            primaryKey,\n                            new RangeSet(req.key)\n                        ],\n                    getMany: (req)=>[\n                            primaryKey,\n                            new RangeSet().addKeys(req.keys)\n                        ],\n                    count: getRange,\n                    query: getRange,\n                    openCursor: getRange\n                };\n                keys(readSubscribers).forEach((method)=>{\n                    tableClone[method] = function(req) {\n                        const { subscr } = PSD;\n                        if (subscr) {\n                            const getRangeSet = (indexName)=>{\n                                const part = `idb://${dbName}/${tableName}/${indexName}`;\n                                return subscr[part] || (subscr[part] = new RangeSet());\n                            };\n                            const pkRangeSet = getRangeSet(\"\");\n                            const delsRangeSet = getRangeSet(\":dels\");\n                            const [queriedIndex, queriedRanges] = readSubscribers[method](req);\n                            getRangeSet(queriedIndex.name || \"\").add(queriedRanges);\n                            if (!queriedIndex.isPrimaryKey) {\n                                if (method === \"count\") {\n                                    delsRangeSet.add(FULL_RANGE);\n                                } else {\n                                    const keysPromise = method === \"query\" && outbound && req.values && table.query({\n                                        ...req,\n                                        values: false\n                                    });\n                                    return table[method].apply(this, arguments).then((res)=>{\n                                        if (method === \"query\") {\n                                            if (outbound && req.values) {\n                                                return keysPromise.then(({ result: resultingKeys })=>{\n                                                    pkRangeSet.addKeys(resultingKeys);\n                                                    return res;\n                                                });\n                                            }\n                                            const pKeys = req.values ? res.result.map(extractKey) : res.result;\n                                            if (req.values) {\n                                                pkRangeSet.addKeys(pKeys);\n                                            } else {\n                                                delsRangeSet.addKeys(pKeys);\n                                            }\n                                        } else if (method === \"openCursor\") {\n                                            const cursor = res;\n                                            const wantValues = req.values;\n                                            return cursor && Object.create(cursor, {\n                                                key: {\n                                                    get () {\n                                                        delsRangeSet.addKey(cursor.primaryKey);\n                                                        return cursor.key;\n                                                    }\n                                                },\n                                                primaryKey: {\n                                                    get () {\n                                                        const pkey = cursor.primaryKey;\n                                                        delsRangeSet.addKey(pkey);\n                                                        return pkey;\n                                                    }\n                                                },\n                                                value: {\n                                                    get () {\n                                                        wantValues && pkRangeSet.addKey(cursor.primaryKey);\n                                                        return cursor.value;\n                                                    }\n                                                }\n                                            });\n                                        }\n                                        return res;\n                                    });\n                                }\n                            }\n                        }\n                        return table[method].apply(this, arguments);\n                    };\n                });\n                return tableClone;\n            }\n        };\n    }\n};\nfunction trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {\n    function addAffectedIndex(ix) {\n        const rangeSet = getRangeSet(ix.name || \"\");\n        function extractKey(obj) {\n            return obj != null ? ix.extractKey(obj) : null;\n        }\n        const addKeyOrKeys = (key)=>ix.multiEntry && isArray(key) ? key.forEach((key)=>rangeSet.addKey(key)) : rangeSet.addKey(key);\n        (oldObjs || newObjs).forEach((_, i)=>{\n            const oldKey = oldObjs && extractKey(oldObjs[i]);\n            const newKey = newObjs && extractKey(newObjs[i]);\n            if (cmp(oldKey, newKey) !== 0) {\n                if (oldKey != null) addKeyOrKeys(oldKey);\n                if (newKey != null) addKeyOrKeys(newKey);\n            }\n        });\n    }\n    schema.indexes.forEach(addAffectedIndex);\n}\nclass Dexie$1 {\n    constructor(name, options){\n        this._middlewares = {};\n        this.verno = 0;\n        const deps = Dexie$1.dependencies;\n        this._options = options = {\n            addons: Dexie$1.addons,\n            autoOpen: true,\n            indexedDB: deps.indexedDB,\n            IDBKeyRange: deps.IDBKeyRange,\n            ...options\n        };\n        this._deps = {\n            indexedDB: options.indexedDB,\n            IDBKeyRange: options.IDBKeyRange\n        };\n        const { addons } = options;\n        this._dbSchema = {};\n        this._versions = [];\n        this._storeNames = [];\n        this._allTables = {};\n        this.idbdb = null;\n        this._novip = this;\n        const state = {\n            dbOpenError: null,\n            isBeingOpened: false,\n            onReadyBeingFired: null,\n            openComplete: false,\n            dbReadyResolve: nop,\n            dbReadyPromise: null,\n            cancelOpen: nop,\n            openCanceller: null,\n            autoSchema: true,\n            PR1398_maxLoop: 3\n        };\n        state.dbReadyPromise = new DexiePromise((resolve)=>{\n            state.dbReadyResolve = resolve;\n        });\n        state.openCanceller = new DexiePromise((_, reject)=>{\n            state.cancelOpen = reject;\n        });\n        this._state = state;\n        this.name = name;\n        this.on = Events(this, \"populate\", \"blocked\", \"versionchange\", \"close\", {\n            ready: [\n                promisableChain,\n                nop\n            ]\n        });\n        this.on.ready.subscribe = override(this.on.ready.subscribe, (subscribe)=>{\n            return (subscriber, bSticky)=>{\n                Dexie$1.vip(()=>{\n                    const state = this._state;\n                    if (state.openComplete) {\n                        if (!state.dbOpenError) DexiePromise.resolve().then(subscriber);\n                        if (bSticky) subscribe(subscriber);\n                    } else if (state.onReadyBeingFired) {\n                        state.onReadyBeingFired.push(subscriber);\n                        if (bSticky) subscribe(subscriber);\n                    } else {\n                        subscribe(subscriber);\n                        const db = this;\n                        if (!bSticky) subscribe(function unsubscribe() {\n                            db.on.ready.unsubscribe(subscriber);\n                            db.on.ready.unsubscribe(unsubscribe);\n                        });\n                    }\n                });\n            };\n        });\n        this.Collection = createCollectionConstructor(this);\n        this.Table = createTableConstructor(this);\n        this.Transaction = createTransactionConstructor(this);\n        this.Version = createVersionConstructor(this);\n        this.WhereClause = createWhereClauseConstructor(this);\n        this.on(\"versionchange\", (ev)=>{\n            if (ev.newVersion > 0) console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`);\n            else console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`);\n            this.close();\n        });\n        this.on(\"blocked\", (ev)=>{\n            if (!ev.newVersion || ev.newVersion < ev.oldVersion) console.warn(`Dexie.delete('${this.name}') was blocked`);\n            else console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${ev.oldVersion / 10}`);\n        });\n        this._maxKey = getMaxKey(options.IDBKeyRange);\n        this._createTransaction = (mode, storeNames, dbschema, parentTransaction)=>new this.Transaction(mode, storeNames, dbschema, this._options.chromeTransactionDurability, parentTransaction);\n        this._fireOnBlocked = (ev)=>{\n            this.on(\"blocked\").fire(ev);\n            connections.filter((c)=>c.name === this.name && c !== this && !c._state.vcFired).map((c)=>c.on(\"versionchange\").fire(ev));\n        };\n        this.use(virtualIndexMiddleware);\n        this.use(hooksMiddleware);\n        this.use(observabilityMiddleware);\n        this.use(cacheExistingValuesMiddleware);\n        this.vip = Object.create(this, {\n            _vip: {\n                value: true\n            }\n        });\n        addons.forEach((addon)=>addon(this));\n    }\n    version(versionNumber) {\n        if (isNaN(versionNumber) || versionNumber < 0.1) throw new exceptions.Type(`Given version is not a positive number`);\n        versionNumber = Math.round(versionNumber * 10) / 10;\n        if (this.idbdb || this._state.isBeingOpened) throw new exceptions.Schema(\"Cannot add version when database is open\");\n        this.verno = Math.max(this.verno, versionNumber);\n        const versions = this._versions;\n        var versionInstance = versions.filter((v)=>v._cfg.version === versionNumber)[0];\n        if (versionInstance) return versionInstance;\n        versionInstance = new this.Version(versionNumber);\n        versions.push(versionInstance);\n        versions.sort(lowerVersionFirst);\n        versionInstance.stores({});\n        this._state.autoSchema = false;\n        return versionInstance;\n    }\n    _whenReady(fn) {\n        return this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip) ? fn() : new DexiePromise((resolve, reject)=>{\n            if (this._state.openComplete) {\n                return reject(new exceptions.DatabaseClosed(this._state.dbOpenError));\n            }\n            if (!this._state.isBeingOpened) {\n                if (!this._options.autoOpen) {\n                    reject(new exceptions.DatabaseClosed());\n                    return;\n                }\n                this.open().catch(nop);\n            }\n            this._state.dbReadyPromise.then(resolve, reject);\n        }).then(fn);\n    }\n    use({ stack, create, level, name }) {\n        if (name) this.unuse({\n            stack,\n            name\n        });\n        const middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);\n        middlewares.push({\n            stack,\n            create,\n            level: level == null ? 10 : level,\n            name\n        });\n        middlewares.sort((a, b)=>a.level - b.level);\n        return this;\n    }\n    unuse({ stack, name, create }) {\n        if (stack && this._middlewares[stack]) {\n            this._middlewares[stack] = this._middlewares[stack].filter((mw)=>create ? mw.create !== create : name ? mw.name !== name : false);\n        }\n        return this;\n    }\n    open() {\n        return dexieOpen(this);\n    }\n    _close() {\n        const state = this._state;\n        const idx = connections.indexOf(this);\n        if (idx >= 0) connections.splice(idx, 1);\n        if (this.idbdb) {\n            try {\n                this.idbdb.close();\n            } catch (e) {}\n            this._novip.idbdb = null;\n        }\n        state.dbReadyPromise = new DexiePromise((resolve)=>{\n            state.dbReadyResolve = resolve;\n        });\n        state.openCanceller = new DexiePromise((_, reject)=>{\n            state.cancelOpen = reject;\n        });\n    }\n    close() {\n        this._close();\n        const state = this._state;\n        this._options.autoOpen = false;\n        state.dbOpenError = new exceptions.DatabaseClosed();\n        if (state.isBeingOpened) state.cancelOpen(state.dbOpenError);\n    }\n    delete() {\n        const hasArguments = arguments.length > 0;\n        const state = this._state;\n        return new DexiePromise((resolve, reject)=>{\n            const doDelete = ()=>{\n                this.close();\n                var req = this._deps.indexedDB.deleteDatabase(this.name);\n                req.onsuccess = wrap(()=>{\n                    _onDatabaseDeleted(this._deps, this.name);\n                    resolve();\n                });\n                req.onerror = eventRejectHandler(reject);\n                req.onblocked = this._fireOnBlocked;\n            };\n            if (hasArguments) throw new exceptions.InvalidArgument(\"Arguments not allowed in db.delete()\");\n            if (state.isBeingOpened) {\n                state.dbReadyPromise.then(doDelete);\n            } else {\n                doDelete();\n            }\n        });\n    }\n    backendDB() {\n        return this.idbdb;\n    }\n    isOpen() {\n        return this.idbdb !== null;\n    }\n    hasBeenClosed() {\n        const dbOpenError = this._state.dbOpenError;\n        return dbOpenError && dbOpenError.name === \"DatabaseClosed\";\n    }\n    hasFailed() {\n        return this._state.dbOpenError !== null;\n    }\n    dynamicallyOpened() {\n        return this._state.autoSchema;\n    }\n    get tables() {\n        return keys(this._allTables).map((name)=>this._allTables[name]);\n    }\n    transaction() {\n        const args = extractTransactionArgs.apply(this, arguments);\n        return this._transaction.apply(this, args);\n    }\n    _transaction(mode, tables, scopeFunc) {\n        let parentTransaction = PSD.trans;\n        if (!parentTransaction || parentTransaction.db !== this || mode.indexOf(\"!\") !== -1) parentTransaction = null;\n        const onlyIfCompatible = mode.indexOf(\"?\") !== -1;\n        mode = mode.replace(\"!\", \"\").replace(\"?\", \"\");\n        let idbMode, storeNames;\n        try {\n            storeNames = tables.map((table)=>{\n                var storeName = table instanceof this.Table ? table.name : table;\n                if (typeof storeName !== \"string\") throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n                return storeName;\n            });\n            if (mode == \"r\" || mode === READONLY) idbMode = READONLY;\n            else if (mode == \"rw\" || mode == READWRITE) idbMode = READWRITE;\n            else throw new exceptions.InvalidArgument(\"Invalid transaction mode: \" + mode);\n            if (parentTransaction) {\n                if (parentTransaction.mode === READONLY && idbMode === READWRITE) {\n                    if (onlyIfCompatible) {\n                        parentTransaction = null;\n                    } else throw new exceptions.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n                }\n                if (parentTransaction) {\n                    storeNames.forEach((storeName)=>{\n                        if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {\n                            if (onlyIfCompatible) {\n                                parentTransaction = null;\n                            } else throw new exceptions.SubTransaction(\"Table \" + storeName + \" not included in parent transaction.\");\n                        }\n                    });\n                }\n                if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {\n                    parentTransaction = null;\n                }\n            }\n        } catch (e) {\n            return parentTransaction ? parentTransaction._promise(null, (_, reject)=>{\n                reject(e);\n            }) : rejection(e);\n        }\n        const enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);\n        return parentTransaction ? parentTransaction._promise(idbMode, enterTransaction, \"lock\") : PSD.trans ? usePSD(PSD.transless, ()=>this._whenReady(enterTransaction)) : this._whenReady(enterTransaction);\n    }\n    table(tableName) {\n        if (!hasOwn(this._allTables, tableName)) {\n            throw new exceptions.InvalidTable(`Table ${tableName} does not exist`);\n        }\n        return this._allTables[tableName];\n    }\n}\nconst symbolObservable = typeof Symbol !== \"undefined\" && \"observable\" in Symbol ? Symbol.observable : \"@@observable\";\nclass Observable {\n    constructor(subscribe){\n        this._subscribe = subscribe;\n    }\n    subscribe(x, error, complete) {\n        return this._subscribe(!x || typeof x === \"function\" ? {\n            next: x,\n            error,\n            complete\n        } : x);\n    }\n    [symbolObservable]() {\n        return this;\n    }\n}\nfunction extendObservabilitySet(target, newSet) {\n    keys(newSet).forEach((part)=>{\n        const rangeSet = target[part] || (target[part] = new RangeSet());\n        mergeRanges(rangeSet, newSet[part]);\n    });\n    return target;\n}\nfunction liveQuery(querier) {\n    let hasValue = false;\n    let currentValue = undefined;\n    const observable = new Observable((observer)=>{\n        const scopeFuncIsAsync = isAsyncFunction(querier);\n        function execute(subscr) {\n            if (scopeFuncIsAsync) {\n                incrementExpectedAwaits();\n            }\n            const exec = ()=>newScope(querier, {\n                    subscr,\n                    trans: null\n                });\n            const rv = PSD.trans ? usePSD(PSD.transless, exec) : exec();\n            if (scopeFuncIsAsync) {\n                rv.then(decrementExpectedAwaits, decrementExpectedAwaits);\n            }\n            return rv;\n        }\n        let closed = false;\n        let accumMuts = {};\n        let currentObs = {};\n        const subscription = {\n            get closed () {\n                return closed;\n            },\n            unsubscribe: ()=>{\n                closed = true;\n                globalEvents.storagemutated.unsubscribe(mutationListener);\n            }\n        };\n        observer.start && observer.start(subscription);\n        let querying = false, startedListening = false;\n        function shouldNotify() {\n            return keys(currentObs).some((key)=>accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key]));\n        }\n        const mutationListener = (parts)=>{\n            extendObservabilitySet(accumMuts, parts);\n            if (shouldNotify()) {\n                doQuery();\n            }\n        };\n        const doQuery = ()=>{\n            if (querying || closed) return;\n            accumMuts = {};\n            const subscr = {};\n            const ret = execute(subscr);\n            if (!startedListening) {\n                globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);\n                startedListening = true;\n            }\n            querying = true;\n            Promise.resolve(ret).then((result)=>{\n                hasValue = true;\n                currentValue = result;\n                querying = false;\n                if (closed) return;\n                if (shouldNotify()) {\n                    doQuery();\n                } else {\n                    accumMuts = {};\n                    currentObs = subscr;\n                    observer.next && observer.next(result);\n                }\n            }, (err)=>{\n                querying = false;\n                hasValue = false;\n                observer.error && observer.error(err);\n                subscription.unsubscribe();\n            });\n        };\n        doQuery();\n        return subscription;\n    });\n    observable.hasValue = ()=>hasValue;\n    observable.getValue = ()=>currentValue;\n    return observable;\n}\nlet domDeps;\ntry {\n    domDeps = {\n        indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,\n        IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange\n    };\n} catch (e) {\n    domDeps = {\n        indexedDB: null,\n        IDBKeyRange: null\n    };\n}\nconst Dexie = Dexie$1;\nprops(Dexie, {\n    ...fullNameExceptions,\n    delete (databaseName) {\n        const db = new Dexie(databaseName, {\n            addons: []\n        });\n        return db.delete();\n    },\n    exists (name) {\n        return new Dexie(name, {\n            addons: []\n        }).open().then((db)=>{\n            db.close();\n            return true;\n        }).catch(\"NoSuchDatabaseError\", ()=>false);\n    },\n    getDatabaseNames (cb) {\n        try {\n            return getDatabaseNames(Dexie.dependencies).then(cb);\n        } catch (_a) {\n            return rejection(new exceptions.MissingAPI());\n        }\n    },\n    defineClass () {\n        function Class(content) {\n            extend(this, content);\n        }\n        return Class;\n    },\n    ignoreTransaction (scopeFunc) {\n        return PSD.trans ? usePSD(PSD.transless, scopeFunc) : scopeFunc();\n    },\n    vip,\n    async: function(generatorFn) {\n        return function() {\n            try {\n                var rv = awaitIterator(generatorFn.apply(this, arguments));\n                if (!rv || typeof rv.then !== \"function\") return DexiePromise.resolve(rv);\n                return rv;\n            } catch (e) {\n                return rejection(e);\n            }\n        };\n    },\n    spawn: function(generatorFn, args, thiz) {\n        try {\n            var rv = awaitIterator(generatorFn.apply(thiz, args || []));\n            if (!rv || typeof rv.then !== \"function\") return DexiePromise.resolve(rv);\n            return rv;\n        } catch (e) {\n            return rejection(e);\n        }\n    },\n    currentTransaction: {\n        get: ()=>PSD.trans || null\n    },\n    waitFor: function(promiseOrFunction, optionalTimeout) {\n        const promise = DexiePromise.resolve(typeof promiseOrFunction === \"function\" ? Dexie.ignoreTransaction(promiseOrFunction) : promiseOrFunction).timeout(optionalTimeout || 60000);\n        return PSD.trans ? PSD.trans.waitFor(promise) : promise;\n    },\n    Promise: DexiePromise,\n    debug: {\n        get: ()=>debug,\n        set: (value)=>{\n            setDebug(value, value === \"dexie\" ? ()=>true : dexieStackFrameFilter);\n        }\n    },\n    derive: derive,\n    extend: extend,\n    props: props,\n    override: override,\n    Events: Events,\n    on: globalEvents,\n    liveQuery,\n    extendObservabilitySet,\n    getByKeyPath: getByKeyPath,\n    setByKeyPath: setByKeyPath,\n    delByKeyPath: delByKeyPath,\n    shallowClone: shallowClone,\n    deepClone: deepClone,\n    getObjectDiff: getObjectDiff,\n    cmp,\n    asap: asap$1,\n    minKey: minKey,\n    addons: [],\n    connections: connections,\n    errnames: errnames,\n    dependencies: domDeps,\n    semVer: DEXIE_VERSION,\n    version: DEXIE_VERSION.split(\".\").map((n)=>parseInt(n)).reduce((p, c, i)=>p + c / Math.pow(10, i * 2))\n});\nDexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);\nif (typeof dispatchEvent !== \"undefined\" && typeof addEventListener !== \"undefined\") {\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (updatedParts)=>{\n        if (!propagatingLocally) {\n            let event;\n            if (isIEOrEdge) {\n                event = document.createEvent(\"CustomEvent\");\n                event.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);\n            } else {\n                event = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {\n                    detail: updatedParts\n                });\n            }\n            propagatingLocally = true;\n            dispatchEvent(event);\n            propagatingLocally = false;\n        }\n    });\n    addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, ({ detail })=>{\n        if (!propagatingLocally) {\n            propagateLocally(detail);\n        }\n    });\n}\nfunction propagateLocally(updateParts) {\n    let wasMe = propagatingLocally;\n    try {\n        propagatingLocally = true;\n        globalEvents.storagemutated.fire(updateParts);\n    } finally{\n        propagatingLocally = wasMe;\n    }\n}\nlet propagatingLocally = false;\nif (typeof BroadcastChannel !== \"undefined\") {\n    const bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);\n    if (typeof bc.unref === \"function\") {\n        bc.unref();\n    }\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts)=>{\n        if (!propagatingLocally) {\n            bc.postMessage(changedParts);\n        }\n    });\n    bc.onmessage = (ev)=>{\n        if (ev.data) propagateLocally(ev.data);\n    };\n} else if (typeof self !== \"undefined\" && typeof navigator !== \"undefined\") {\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts)=>{\n        try {\n            if (!propagatingLocally) {\n                if (typeof localStorage !== \"undefined\") {\n                    localStorage.setItem(STORAGE_MUTATED_DOM_EVENT_NAME, JSON.stringify({\n                        trig: Math.random(),\n                        changedParts\n                    }));\n                }\n                if (typeof self[\"clients\"] === \"object\") {\n                    [\n                        ...self[\"clients\"].matchAll({\n                            includeUncontrolled: true\n                        })\n                    ].forEach((client)=>client.postMessage({\n                            type: STORAGE_MUTATED_DOM_EVENT_NAME,\n                            changedParts\n                        }));\n                }\n            }\n        } catch (_a) {}\n    });\n    if (typeof addEventListener !== \"undefined\") {\n        addEventListener(\"storage\", (ev)=>{\n            if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {\n                const data = JSON.parse(ev.newValue);\n                if (data) propagateLocally(data.changedParts);\n            }\n        });\n    }\n    const swContainer = self.document && navigator.serviceWorker;\n    if (swContainer) {\n        swContainer.addEventListener(\"message\", propagateMessageLocally);\n    }\n}\nfunction propagateMessageLocally({ data }) {\n    if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) {\n        propagateLocally(data.changedParts);\n    }\n}\nDexiePromise.rejectionMapper = mapError;\nsetDebug(debug, dexieStackFrameFilter);\n //# sourceMappingURL=dexie.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2RleGllQDMuMi43L25vZGVfbW9kdWxlcy9kZXhpZS9kaXN0L21vZGVybi9kZXhpZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7O0NBV0MsR0FFRCxNQUFNQSxVQUFVLE9BQU9DLGVBQWUsY0FBY0EsYUFDaEQsT0FBT0MsU0FBUyxjQUFjQSxPQUMxQixNQUFrQixHQUFjQyxDQUFNQSxHQUNsQ0M7QUFFWixNQUFNQyxPQUFPQyxPQUFPRCxJQUFJO0FBQ3hCLE1BQU1FLFVBQVVDLE1BQU1ELE9BQU87QUFDN0IsSUFBSSxPQUFPRSxZQUFZLGVBQWUsQ0FBQ1QsUUFBUVMsT0FBTyxFQUFFO0lBQ3BEVCxRQUFRUyxPQUFPLEdBQUdBO0FBQ3RCO0FBQ0EsU0FBU0MsT0FBT0MsR0FBRyxFQUFFQyxTQUFTO0lBQzFCLElBQUksT0FBT0EsY0FBYyxVQUNyQixPQUFPRDtJQUNYTixLQUFLTyxXQUFXQyxPQUFPLENBQUMsU0FBVUMsR0FBRztRQUNqQ0gsR0FBRyxDQUFDRyxJQUFJLEdBQUdGLFNBQVMsQ0FBQ0UsSUFBSTtJQUM3QjtJQUNBLE9BQU9IO0FBQ1g7QUFDQSxNQUFNSSxXQUFXVCxPQUFPVSxjQUFjO0FBQ3RDLE1BQU1DLFVBQVUsQ0FBQyxFQUFFQyxjQUFjO0FBQ2pDLFNBQVNDLE9BQU9SLEdBQUcsRUFBRVMsSUFBSTtJQUNyQixPQUFPSCxRQUFRSSxJQUFJLENBQUNWLEtBQUtTO0FBQzdCO0FBQ0EsU0FBU0UsTUFBTUMsS0FBSyxFQUFFWCxTQUFTO0lBQzNCLElBQUksT0FBT0EsY0FBYyxZQUNyQkEsWUFBWUEsVUFBVUcsU0FBU1E7SUFDbEMsUUFBT0MsWUFBWSxjQUFjbkIsT0FBT21CLFFBQVFDLE9BQU8sRUFBRWIsV0FBV0MsT0FBTyxDQUFDQyxDQUFBQTtRQUN6RVksUUFBUUgsT0FBT1QsS0FBS0YsU0FBUyxDQUFDRSxJQUFJO0lBQ3RDO0FBQ0o7QUFDQSxNQUFNYSxpQkFBaUJy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LEdBQUc3dUIsR0FBRyxLQUFLNnRCLGdDQUFnQztnQkFDM0MsTUFBTWljLE9BQU92dEIsS0FBSyt0QixLQUFLLENBQUN6YixHQUFHMGIsUUFBUTtnQkFDbkMsSUFBSVQsTUFDQVQsaUJBQWlCUyxLQUFLSCxZQUFZO1lBQzFDO1FBQ0o7SUFDSjtJQUNBLE1BQU1hLGNBQWNwckMsS0FBSzhOLFFBQVEsSUFBSXNNLFVBQVVpeEIsYUFBYTtJQUM1RCxJQUFJRCxhQUFhO1FBQ2JBLFlBQVl2QixnQkFBZ0IsQ0FBQyxXQUFXeUI7SUFDNUM7QUFDSjtBQUNBLFNBQVNBLHdCQUF3QixFQUFFWixJQUFJLEVBQUU7SUFDckMsSUFBSUEsUUFBUUEsS0FBS3I1QixJQUFJLEtBQUtvZCxnQ0FBZ0M7UUFDdER3YixpQkFBaUJTLEtBQUtILFlBQVk7SUFDdEM7QUFDSjtBQUVBOTZCLGFBQWFkLGVBQWUsR0FBR3pEO0FBQy9CakQsU0FBU0osT0FBTzJTO0FBRWlGLENBQ2pHLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZGV4aWVAMy4yLjcvbm9kZV9tb2R1bGVzL2RleGllL2Rpc3QvbW9kZXJuL2RleGllLm1qcz81YmMxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBEZXhpZS5qcyAtIGEgbWluaW1hbGlzdGljIHdyYXBwZXIgZm9yIEluZGV4ZWREQlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBCeSBEYXZpZCBGYWhsYW5kZXIsIGRhdmlkLmZhaGxhbmRlckBnbWFpbC5jb21cbiAqXG4gKiBWZXJzaW9uIDMuMi43LCBXZWQgTWFyIDIwIDIwMjRcbiAqXG4gKiBodHRwczovL2RleGllLm9yZ1xuICpcbiAqIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wLCBKYW51YXJ5IDIwMDQsIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9cbiAqL1xuIFxuY29uc3QgX2dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOlxuICAgIHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOlxuICAgICAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6XG4gICAgICAgICAgICBnbG9iYWw7XG5cbmNvbnN0IGtleXMgPSBPYmplY3Qua2V5cztcbmNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiAhX2dsb2JhbC5Qcm9taXNlKSB7XG4gICAgX2dsb2JhbC5Qcm9taXNlID0gUHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGV4dGVuZChvYmosIGV4dGVuc2lvbikge1xuICAgIGlmICh0eXBlb2YgZXh0ZW5zaW9uICE9PSAnb2JqZWN0JylcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICBrZXlzKGV4dGVuc2lvbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIG9ialtrZXldID0gZXh0ZW5zaW9uW2tleV07XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbn1cbmNvbnN0IGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuY29uc3QgX2hhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzT3duKG9iaiwgcHJvcCkge1xuICAgIHJldHVybiBfaGFzT3duLmNhbGwob2JqLCBwcm9wKTtcbn1cbmZ1bmN0aW9uIHByb3BzKHByb3RvLCBleHRlbnNpb24pIHtcbiAgICBpZiAodHlwZW9mIGV4dGVuc2lvbiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9uKGdldFByb3RvKHByb3RvKSk7XG4gICAgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiID8ga2V5cyA6IFJlZmxlY3Qub3duS2V5cykoZXh0ZW5zaW9uKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIHNldFByb3AocHJvdG8sIGtleSwgZXh0ZW5zaW9uW2tleV0pO1xuICAgIH0pO1xufVxuY29uc3QgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5mdW5jdGlvbiBzZXRQcm9wKG9iaiwgcHJvcCwgZnVuY3Rpb25PckdldFNldCwgb3B0aW9ucykge1xuICAgIGRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwgZXh0ZW5kKGZ1bmN0aW9uT3JHZXRTZXQgJiYgaGFzT3duKGZ1bmN0aW9uT3JHZXRTZXQsIFwiZ2V0XCIpICYmIHR5cGVvZiBmdW5jdGlvbk9yR2V0U2V0LmdldCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIHsgZ2V0OiBmdW5jdGlvbk9yR2V0U2V0LmdldCwgc2V0OiBmdW5jdGlvbk9yR2V0U2V0LnNldCwgY29uZmlndXJhYmxlOiB0cnVlIH0gOlxuICAgICAgICB7IHZhbHVlOiBmdW5jdGlvbk9yR2V0U2V0LCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0sIG9wdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIGRlcml2ZShDaGlsZCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZyb206IGZ1bmN0aW9uIChQYXJlbnQpIHtcbiAgICAgICAgICAgIENoaWxkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUGFyZW50LnByb3RvdHlwZSk7XG4gICAgICAgICAgICBzZXRQcm9wKENoaWxkLnByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCBDaGlsZCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGV4dGVuZDogcHJvcHMuYmluZChudWxsLCBDaGlsZC5wcm90b3R5cGUpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbn1cbmNvbnN0IGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5mdW5jdGlvbiBnZXRQcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBwcm9wKSB7XG4gICAgY29uc3QgcGQgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBwcm9wKTtcbiAgICBsZXQgcHJvdG87XG4gICAgcmV0dXJuIHBkIHx8IChwcm90byA9IGdldFByb3RvKG9iaikpICYmIGdldFByb3BlcnR5RGVzY3JpcHRvcihwcm90bywgcHJvcCk7XG59XG5jb25zdCBfc2xpY2UgPSBbXS5zbGljZTtcbmZ1bmN0aW9uIHNsaWNlKGFyZ3MsIHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gX3NsaWNlLmNhbGwoYXJncywgc3RhcnQsIGVuZCk7XG59XG5mdW5jdGlvbiBvdmVycmlkZShvcmlnRnVuYywgb3ZlcnJpZGVkRmFjdG9yeSkge1xuICAgIHJldHVybiBvdmVycmlkZWRGYWN0b3J5KG9yaWdGdW5jKTtcbn1cbmZ1bmN0aW9uIGFzc2VydChiKSB7XG4gICAgaWYgKCFiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3NlcnRpb24gRmFpbGVkXCIpO1xufVxuZnVuY3Rpb24gYXNhcCQxKGZuKSB7XG4gICAgaWYgKF9nbG9iYWwuc2V0SW1tZWRpYXRlKVxuICAgICAgICBzZXRJbW1lZGlhdGUoZm4pO1xuICAgIGVsc2VcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG59XG5mdW5jdGlvbiBhcnJheVRvT2JqZWN0KGFycmF5LCBleHRyYWN0b3IpIHtcbiAgICByZXR1cm4gYXJyYXkucmVkdWNlKChyZXN1bHQsIGl0ZW0sIGkpID0+IHtcbiAgICAgICAgdmFyIG5hbWVBbmRWYWx1ZSA9IGV4dHJhY3RvcihpdGVtLCBpKTtcbiAgICAgICAgaWYgKG5hbWVBbmRWYWx1ZSlcbiAgICAgICAgICAgIHJlc3VsdFtuYW1lQW5kVmFsdWVbMF1dID0gbmFtZUFuZFZhbHVlWzFdO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvbmVycm9yLCBhcmdzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIGNhdGNoIChleCkge1xuICAgICAgICBvbmVycm9yICYmIG9uZXJyb3IoZXgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGgpIHtcbiAgICBpZiAodHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnICYmIGhhc093bihvYmosIGtleVBhdGgpKVxuICAgICAgICByZXR1cm4gb2JqW2tleVBhdGhdO1xuICAgIGlmICgha2V5UGF0aClcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICBpZiAodHlwZW9mIGtleVBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBydiA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGtleVBhdGgubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gZ2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aFtpXSk7XG4gICAgICAgICAgICBydi5wdXNoKHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgIH1cbiAgICB2YXIgcGVyaW9kID0ga2V5UGF0aC5pbmRleE9mKCcuJyk7XG4gICAgaWYgKHBlcmlvZCAhPT0gLTEpIHtcbiAgICAgICAgdmFyIGlubmVyT2JqID0gb2JqW2tleVBhdGguc3Vic3RyKDAsIHBlcmlvZCldO1xuICAgICAgICByZXR1cm4gaW5uZXJPYmogPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGdldEJ5S2V5UGF0aChpbm5lck9iaiwga2V5UGF0aC5zdWJzdHIocGVyaW9kICsgMSkpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCwgdmFsdWUpIHtcbiAgICBpZiAoIW9iaiB8fCBrZXlQYXRoID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoJ2lzRnJvemVuJyBpbiBPYmplY3QgJiYgT2JqZWN0LmlzRnJvemVuKG9iaikpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAodHlwZW9mIGtleVBhdGggIT09ICdzdHJpbmcnICYmICdsZW5ndGgnIGluIGtleVBhdGgpIHtcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgJiYgJ2xlbmd0aCcgaW4gdmFsdWUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGtleVBhdGgubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBzZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoW2ldLCB2YWx1ZVtpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBwZXJpb2QgPSBrZXlQYXRoLmluZGV4T2YoJy4nKTtcbiAgICAgICAgaWYgKHBlcmlvZCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50S2V5UGF0aCA9IGtleVBhdGguc3Vic3RyKDAsIHBlcmlvZCk7XG4gICAgICAgICAgICB2YXIgcmVtYWluaW5nS2V5UGF0aCA9IGtleVBhdGguc3Vic3RyKHBlcmlvZCArIDEpO1xuICAgICAgICAgICAgaWYgKHJlbWFpbmluZ0tleVBhdGggPT09IFwiXCIpXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkob2JqKSAmJiAhaXNOYU4ocGFyc2VJbnQoY3VycmVudEtleVBhdGgpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai5zcGxpY2UoY3VycmVudEtleVBhdGgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb2JqW2N1cnJlbnRLZXlQYXRoXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBvYmpbY3VycmVudEtleVBhdGhdID0gdmFsdWU7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5uZXJPYmogPSBvYmpbY3VycmVudEtleVBhdGhdO1xuICAgICAgICAgICAgICAgIGlmICghaW5uZXJPYmogfHwgIWhhc093bihvYmosIGN1cnJlbnRLZXlQYXRoKSlcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJPYmogPSAob2JqW2N1cnJlbnRLZXlQYXRoXSA9IHt9KTtcbiAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgoaW5uZXJPYmosIHJlbWFpbmluZ0tleVBhdGgsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkob2JqKSAmJiAhaXNOYU4ocGFyc2VJbnQoa2V5UGF0aCkpKVxuICAgICAgICAgICAgICAgICAgICBvYmouc3BsaWNlKGtleVBhdGgsIDEpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9ialtrZXlQYXRoXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBvYmpba2V5UGF0aF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGRlbEJ5S2V5UGF0aChvYmosIGtleVBhdGgpIHtcbiAgICBpZiAodHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnKVxuICAgICAgICBzZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoLCB1bmRlZmluZWQpO1xuICAgIGVsc2UgaWYgKCdsZW5ndGgnIGluIGtleVBhdGgpXG4gICAgICAgIFtdLm1hcC5jYWxsKGtleVBhdGgsIGZ1bmN0aW9uIChrcCkge1xuICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga3AsIHVuZGVmaW5lZCk7XG4gICAgICAgIH0pO1xufVxuZnVuY3Rpb24gc2hhbGxvd0Nsb25lKG9iaikge1xuICAgIHZhciBydiA9IHt9O1xuICAgIGZvciAodmFyIG0gaW4gb2JqKSB7XG4gICAgICAgIGlmIChoYXNPd24ob2JqLCBtKSlcbiAgICAgICAgICAgIHJ2W21dID0gb2JqW21dO1xuICAgIH1cbiAgICByZXR1cm4gcnY7XG59XG5jb25zdCBjb25jYXQgPSBbXS5jb25jYXQ7XG5mdW5jdGlvbiBmbGF0dGVuKGEpIHtcbiAgICByZXR1cm4gY29uY2F0LmFwcGx5KFtdLCBhKTtcbn1cbmNvbnN0IGludHJpbnNpY1R5cGVOYW1lcyA9IFwiQmlnVWludDY0QXJyYXksQmlnSW50NjRBcnJheSxBcnJheSxCb29sZWFuLFN0cmluZyxEYXRlLFJlZ0V4cCxCbG9iLEZpbGUsRmlsZUxpc3QsRmlsZVN5c3RlbUZpbGVIYW5kbGUsRmlsZVN5c3RlbURpcmVjdG9yeUhhbmRsZSxBcnJheUJ1ZmZlcixEYXRhVmlldyxVaW50OENsYW1wZWRBcnJheSxJbWFnZUJpdG1hcCxJbWFnZURhdGEsTWFwLFNldCxDcnlwdG9LZXlcIlxuICAgIC5zcGxpdCgnLCcpLmNvbmNhdChmbGF0dGVuKFs4LCAxNiwgMzIsIDY0XS5tYXAobnVtID0+IFtcIkludFwiLCBcIlVpbnRcIiwgXCJGbG9hdFwiXS5tYXAodCA9PiB0ICsgbnVtICsgXCJBcnJheVwiKSkpKS5maWx0ZXIodCA9PiBfZ2xvYmFsW3RdKTtcbmNvbnN0IGludHJpbnNpY1R5cGVzID0gaW50cmluc2ljVHlwZU5hbWVzLm1hcCh0ID0+IF9nbG9iYWxbdF0pO1xuYXJyYXlUb09iamVjdChpbnRyaW5zaWNUeXBlTmFtZXMsIHggPT4gW3gsIHRydWVdKTtcbmxldCBjaXJjdWxhclJlZnMgPSBudWxsO1xuZnVuY3Rpb24gZGVlcENsb25lKGFueSkge1xuICAgIGNpcmN1bGFyUmVmcyA9IHR5cGVvZiBXZWFrTWFwICE9PSAndW5kZWZpbmVkJyAmJiBuZXcgV2Vha01hcCgpO1xuICAgIGNvbnN0IHJ2ID0gaW5uZXJEZWVwQ2xvbmUoYW55KTtcbiAgICBjaXJjdWxhclJlZnMgPSBudWxsO1xuICAgIHJldHVybiBydjtcbn1cbmZ1bmN0aW9uIGlubmVyRGVlcENsb25lKGFueSkge1xuICAgIGlmICghYW55IHx8IHR5cGVvZiBhbnkgIT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm4gYW55O1xuICAgIGxldCBydiA9IGNpcmN1bGFyUmVmcyAmJiBjaXJjdWxhclJlZnMuZ2V0KGFueSk7XG4gICAgaWYgKHJ2KVxuICAgICAgICByZXR1cm4gcnY7XG4gICAgaWYgKGlzQXJyYXkoYW55KSkge1xuICAgICAgICBydiA9IFtdO1xuICAgICAgICBjaXJjdWxhclJlZnMgJiYgY2lyY3VsYXJSZWZzLnNldChhbnksIHJ2KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhbnkubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBydi5wdXNoKGlubmVyRGVlcENsb25lKGFueVtpXSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGludHJpbnNpY1R5cGVzLmluZGV4T2YoYW55LmNvbnN0cnVjdG9yKSA+PSAwKSB7XG4gICAgICAgIHJ2ID0gYW55O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcHJvdG8gPSBnZXRQcm90byhhbnkpO1xuICAgICAgICBydiA9IHByb3RvID09PSBPYmplY3QucHJvdG90eXBlID8ge30gOiBPYmplY3QuY3JlYXRlKHByb3RvKTtcbiAgICAgICAgY2lyY3VsYXJSZWZzICYmIGNpcmN1bGFyUmVmcy5zZXQoYW55LCBydik7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gYW55KSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duKGFueSwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBydltwcm9wXSA9IGlubmVyRGVlcENsb25lKGFueVtwcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJ2O1xufVxuY29uc3QgeyB0b1N0cmluZyB9ID0ge307XG5mdW5jdGlvbiB0b1N0cmluZ1RhZyhvKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xufVxuY29uc3QgaXRlcmF0b3JTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyA/XG4gICAgU3ltYm9sLml0ZXJhdG9yIDpcbiAgICAnQEBpdGVyYXRvcic7XG5jb25zdCBnZXRJdGVyYXRvck9mID0gdHlwZW9mIGl0ZXJhdG9yU3ltYm9sID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKHgpIHtcbiAgICB2YXIgaTtcbiAgICByZXR1cm4geCAhPSBudWxsICYmIChpID0geFtpdGVyYXRvclN5bWJvbF0pICYmIGkuYXBwbHkoeCk7XG59IDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfTtcbmNvbnN0IE5PX0NIQVJfQVJSQVkgPSB7fTtcbmZ1bmN0aW9uIGdldEFycmF5T2YoYXJyYXlMaWtlKSB7XG4gICAgdmFyIGksIGEsIHgsIGl0O1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmIChpc0FycmF5KGFycmF5TGlrZSkpXG4gICAgICAgICAgICByZXR1cm4gYXJyYXlMaWtlLnNsaWNlKCk7XG4gICAgICAgIGlmICh0aGlzID09PSBOT19DSEFSX0FSUkFZICYmIHR5cGVvZiBhcnJheUxpa2UgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIFthcnJheUxpa2VdO1xuICAgICAgICBpZiAoKGl0ID0gZ2V0SXRlcmF0b3JPZihhcnJheUxpa2UpKSkge1xuICAgICAgICAgICAgYSA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKCh4ID0gaXQubmV4dCgpKSwgIXguZG9uZSlcbiAgICAgICAgICAgICAgICBhLnB1c2goeC52YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJyYXlMaWtlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gW2FycmF5TGlrZV07XG4gICAgICAgIGkgPSBhcnJheUxpa2UubGVuZ3RoO1xuICAgICAgICBpZiAodHlwZW9mIGkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBhID0gbmV3IEFycmF5KGkpO1xuICAgICAgICAgICAgd2hpbGUgKGktLSlcbiAgICAgICAgICAgICAgICBhW2ldID0gYXJyYXlMaWtlW2ldO1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFthcnJheUxpa2VdO1xuICAgIH1cbiAgICBpID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhID0gbmV3IEFycmF5KGkpO1xuICAgIHdoaWxlIChpLS0pXG4gICAgICAgIGFbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGE7XG59XG5jb25zdCBpc0FzeW5jRnVuY3Rpb24gPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJ1xuICAgID8gKGZuKSA9PiBmbltTeW1ib2wudG9TdHJpbmdUYWddID09PSAnQXN5bmNGdW5jdGlvbidcbiAgICA6ICgpID0+IGZhbHNlO1xuXG52YXIgZGVidWcgPSB0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnICYmXG4gICAgL14oaHR0cHxodHRwcyk6XFwvXFwvKGxvY2FsaG9zdHwxMjdcXC4wXFwuMFxcLjEpLy50ZXN0KGxvY2F0aW9uLmhyZWYpO1xuZnVuY3Rpb24gc2V0RGVidWcodmFsdWUsIGZpbHRlcikge1xuICAgIGRlYnVnID0gdmFsdWU7XG4gICAgbGlicmFyeUZpbHRlciA9IGZpbHRlcjtcbn1cbnZhciBsaWJyYXJ5RmlsdGVyID0gKCkgPT4gdHJ1ZTtcbmNvbnN0IE5FRURTX1RIUk9XX0ZPUl9TVEFDSyA9ICFuZXcgRXJyb3IoXCJcIikuc3RhY2s7XG5mdW5jdGlvbiBnZXRFcnJvcldpdGhTdGFjaygpIHtcbiAgICBpZiAoTkVFRFNfVEhST1dfRk9SX1NUQUNLKVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZ2V0RXJyb3JXaXRoU3RhY2suYXJndW1lbnRzO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9XG4gICAgcmV0dXJuIG5ldyBFcnJvcigpO1xufVxuZnVuY3Rpb24gcHJldHR5U3RhY2soZXhjZXB0aW9uLCBudW1JZ25vcmVkRnJhbWVzKSB7XG4gICAgdmFyIHN0YWNrID0gZXhjZXB0aW9uLnN0YWNrO1xuICAgIGlmICghc3RhY2spXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIG51bUlnbm9yZWRGcmFtZXMgPSAobnVtSWdub3JlZEZyYW1lcyB8fCAwKTtcbiAgICBpZiAoc3RhY2suaW5kZXhPZihleGNlcHRpb24ubmFtZSkgPT09IDApXG4gICAgICAgIG51bUlnbm9yZWRGcmFtZXMgKz0gKGV4Y2VwdGlvbi5uYW1lICsgZXhjZXB0aW9uLm1lc3NhZ2UpLnNwbGl0KCdcXG4nKS5sZW5ndGg7XG4gICAgcmV0dXJuIHN0YWNrLnNwbGl0KCdcXG4nKVxuICAgICAgICAuc2xpY2UobnVtSWdub3JlZEZyYW1lcylcbiAgICAgICAgLmZpbHRlcihsaWJyYXJ5RmlsdGVyKVxuICAgICAgICAubWFwKGZyYW1lID0+IFwiXFxuXCIgKyBmcmFtZSlcbiAgICAgICAgLmpvaW4oJycpO1xufVxuXG52YXIgZGV4aWVFcnJvck5hbWVzID0gW1xuICAgICdNb2RpZnknLFxuICAgICdCdWxrJyxcbiAgICAnT3BlbkZhaWxlZCcsXG4gICAgJ1ZlcnNpb25DaGFuZ2UnLFxuICAgICdTY2hlbWEnLFxuICAgICdVcGdyYWRlJyxcbiAgICAnSW52YWxpZFRhYmxlJyxcbiAgICAnTWlzc2luZ0FQSScsXG4gICAgJ05vU3VjaERhdGFiYXNlJyxcbiAgICAnSW52YWxpZEFyZ3VtZW50JyxcbiAgICAnU3ViVHJhbnNhY3Rpb24nLFxuICAgICdVbnN1cHBvcnRlZCcsXG4gICAgJ0ludGVybmFsJyxcbiAgICAnRGF0YWJhc2VDbG9zZWQnLFxuICAgICdQcmVtYXR1cmVDb21taXQnLFxuICAgICdGb3JlaWduQXdhaXQnXG5dO1xudmFyIGlkYkRvbUVycm9yTmFtZXMgPSBbXG4gICAgJ1Vua25vd24nLFxuICAgICdDb25zdHJhaW50JyxcbiAgICAnRGF0YScsXG4gICAgJ1RyYW5zYWN0aW9uSW5hY3RpdmUnLFxuICAgICdSZWFkT25seScsXG4gICAgJ1ZlcnNpb24nLFxuICAgICdOb3RGb3VuZCcsXG4gICAgJ0ludmFsaWRTdGF0ZScsXG4gICAgJ0ludmFsaWRBY2Nlc3MnLFxuICAgICdBYm9ydCcsXG4gICAgJ1RpbWVvdXQnLFxuICAgICdRdW90YUV4Y2VlZGVkJyxcbiAgICAnU3ludGF4JyxcbiAgICAnRGF0YUNsb25lJ1xuXTtcbnZhciBlcnJvckxpc3QgPSBkZXhpZUVycm9yTmFtZXMuY29uY2F0KGlkYkRvbUVycm9yTmFtZXMpO1xudmFyIGRlZmF1bHRUZXh0cyA9IHtcbiAgICBWZXJzaW9uQ2hhbmdlZDogXCJEYXRhYmFzZSB2ZXJzaW9uIGNoYW5nZWQgYnkgb3RoZXIgZGF0YWJhc2UgY29ubmVjdGlvblwiLFxuICAgIERhdGFiYXNlQ2xvc2VkOiBcIkRhdGFiYXNlIGhhcyBiZWVuIGNsb3NlZFwiLFxuICAgIEFib3J0OiBcIlRyYW5zYWN0aW9uIGFib3J0ZWRcIixcbiAgICBUcmFuc2FjdGlvbkluYWN0aXZlOiBcIlRyYW5zYWN0aW9uIGhhcyBhbHJlYWR5IGNvbXBsZXRlZCBvciBmYWlsZWRcIixcbiAgICBNaXNzaW5nQVBJOiBcIkluZGV4ZWREQiBBUEkgbWlzc2luZy4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vdGlueXVybC5jb20veTJ1dXZza2JcIlxufTtcbmZ1bmN0aW9uIERleGllRXJyb3IobmFtZSwgbXNnKSB7XG4gICAgdGhpcy5fZSA9IGdldEVycm9yV2l0aFN0YWNrKCk7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtc2c7XG59XG5kZXJpdmUoRGV4aWVFcnJvcikuZnJvbShFcnJvcikuZXh0ZW5kKHtcbiAgICBzdGFjazoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGFjayB8fFxuICAgICAgICAgICAgICAgICh0aGlzLl9zdGFjayA9IHRoaXMubmFtZSArIFwiOiBcIiArIHRoaXMubWVzc2FnZSArIHByZXR0eVN0YWNrKHRoaXMuX2UsIDIpKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubmFtZSArIFwiOiBcIiArIHRoaXMubWVzc2FnZTsgfVxufSk7XG5mdW5jdGlvbiBnZXRNdWx0aUVycm9yTWVzc2FnZShtc2csIGZhaWx1cmVzKSB7XG4gICAgcmV0dXJuIG1zZyArIFwiLiBFcnJvcnM6IFwiICsgT2JqZWN0LmtleXMoZmFpbHVyZXMpXG4gICAgICAgIC5tYXAoa2V5ID0+IGZhaWx1cmVzW2tleV0udG9TdHJpbmcoKSlcbiAgICAgICAgLmZpbHRlcigodiwgaSwgcykgPT4gcy5pbmRleE9mKHYpID09PSBpKVxuICAgICAgICAuam9pbignXFxuJyk7XG59XG5mdW5jdGlvbiBNb2RpZnlFcnJvcihtc2csIGZhaWx1cmVzLCBzdWNjZXNzQ291bnQsIGZhaWxlZEtleXMpIHtcbiAgICB0aGlzLl9lID0gZ2V0RXJyb3JXaXRoU3RhY2soKTtcbiAgICB0aGlzLmZhaWx1cmVzID0gZmFpbHVyZXM7XG4gICAgdGhpcy5mYWlsZWRLZXlzID0gZmFpbGVkS2V5cztcbiAgICB0aGlzLnN1Y2Nlc3NDb3VudCA9IHN1Y2Nlc3NDb3VudDtcbiAgICB0aGlzLm1lc3NhZ2UgPSBnZXRNdWx0aUVycm9yTWVzc2FnZShtc2csIGZhaWx1cmVzKTtcbn1cbmRlcml2ZShNb2RpZnlFcnJvcikuZnJvbShEZXhpZUVycm9yKTtcbmZ1bmN0aW9uIEJ1bGtFcnJvcihtc2csIGZhaWx1cmVzKSB7XG4gICAgdGhpcy5fZSA9IGdldEVycm9yV2l0aFN0YWNrKCk7XG4gICAgdGhpcy5uYW1lID0gXCJCdWxrRXJyb3JcIjtcbiAgICB0aGlzLmZhaWx1cmVzID0gT2JqZWN0LmtleXMoZmFpbHVyZXMpLm1hcChwb3MgPT4gZmFpbHVyZXNbcG9zXSk7XG4gICAgdGhpcy5mYWlsdXJlc0J5UG9zID0gZmFpbHVyZXM7XG4gICAgdGhpcy5tZXNzYWdlID0gZ2V0TXVsdGlFcnJvck1lc3NhZ2UobXNnLCBmYWlsdXJlcyk7XG59XG5kZXJpdmUoQnVsa0Vycm9yKS5mcm9tKERleGllRXJyb3IpO1xudmFyIGVycm5hbWVzID0gZXJyb3JMaXN0LnJlZHVjZSgob2JqLCBuYW1lKSA9PiAob2JqW25hbWVdID0gbmFtZSArIFwiRXJyb3JcIiwgb2JqKSwge30pO1xuY29uc3QgQmFzZUV4Y2VwdGlvbiA9IERleGllRXJyb3I7XG52YXIgZXhjZXB0aW9ucyA9IGVycm9yTGlzdC5yZWR1Y2UoKG9iaiwgbmFtZSkgPT4ge1xuICAgIHZhciBmdWxsTmFtZSA9IG5hbWUgKyBcIkVycm9yXCI7XG4gICAgZnVuY3Rpb24gRGV4aWVFcnJvcihtc2dPcklubmVyLCBpbm5lcikge1xuICAgICAgICB0aGlzLl9lID0gZ2V0RXJyb3JXaXRoU3RhY2soKTtcbiAgICAgICAgdGhpcy5uYW1lID0gZnVsbE5hbWU7XG4gICAgICAgIGlmICghbXNnT3JJbm5lcikge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gZGVmYXVsdFRleHRzW25hbWVdIHx8IGZ1bGxOYW1lO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1zZ09ySW5uZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgJHttc2dPcklubmVyfSR7IWlubmVyID8gJycgOiAnXFxuICcgKyBpbm5lcn1gO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IGlubmVyIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1zZ09ySW5uZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgJHttc2dPcklubmVyLm5hbWV9ICR7bXNnT3JJbm5lci5tZXNzYWdlfWA7XG4gICAgICAgICAgICB0aGlzLmlubmVyID0gbXNnT3JJbm5lcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXJpdmUoRGV4aWVFcnJvcikuZnJvbShCYXNlRXhjZXB0aW9uKTtcbiAgICBvYmpbbmFtZV0gPSBEZXhpZUVycm9yO1xuICAgIHJldHVybiBvYmo7XG59LCB7fSk7XG5leGNlcHRpb25zLlN5bnRheCA9IFN5bnRheEVycm9yO1xuZXhjZXB0aW9ucy5UeXBlID0gVHlwZUVycm9yO1xuZXhjZXB0aW9ucy5SYW5nZSA9IFJhbmdlRXJyb3I7XG52YXIgZXhjZXB0aW9uTWFwID0gaWRiRG9tRXJyb3JOYW1lcy5yZWR1Y2UoKG9iaiwgbmFtZSkgPT4ge1xuICAgIG9ialtuYW1lICsgXCJFcnJvclwiXSA9IGV4Y2VwdGlvbnNbbmFtZV07XG4gICAgcmV0dXJuIG9iajtcbn0sIHt9KTtcbmZ1bmN0aW9uIG1hcEVycm9yKGRvbUVycm9yLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFkb21FcnJvciB8fCBkb21FcnJvciBpbnN0YW5jZW9mIERleGllRXJyb3IgfHwgZG9tRXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgfHwgZG9tRXJyb3IgaW5zdGFuY2VvZiBTeW50YXhFcnJvciB8fCAhZG9tRXJyb3IubmFtZSB8fCAhZXhjZXB0aW9uTWFwW2RvbUVycm9yLm5hbWVdKVxuICAgICAgICByZXR1cm4gZG9tRXJyb3I7XG4gICAgdmFyIHJ2ID0gbmV3IGV4Y2VwdGlvbk1hcFtkb21FcnJvci5uYW1lXShtZXNzYWdlIHx8IGRvbUVycm9yLm1lc3NhZ2UsIGRvbUVycm9yKTtcbiAgICBpZiAoXCJzdGFja1wiIGluIGRvbUVycm9yKSB7XG4gICAgICAgIHNldFByb3AocnYsIFwic3RhY2tcIiwgeyBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbm5lci5zdGFjaztcbiAgICAgICAgICAgIH0gfSk7XG4gICAgfVxuICAgIHJldHVybiBydjtcbn1cbnZhciBmdWxsTmFtZUV4Y2VwdGlvbnMgPSBlcnJvckxpc3QucmVkdWNlKChvYmosIG5hbWUpID0+IHtcbiAgICBpZiAoW1wiU3ludGF4XCIsIFwiVHlwZVwiLCBcIlJhbmdlXCJdLmluZGV4T2YobmFtZSkgPT09IC0xKVxuICAgICAgICBvYmpbbmFtZSArIFwiRXJyb3JcIl0gPSBleGNlcHRpb25zW25hbWVdO1xuICAgIHJldHVybiBvYmo7XG59LCB7fSk7XG5mdWxsTmFtZUV4Y2VwdGlvbnMuTW9kaWZ5RXJyb3IgPSBNb2RpZnlFcnJvcjtcbmZ1bGxOYW1lRXhjZXB0aW9ucy5EZXhpZUVycm9yID0gRGV4aWVFcnJvcjtcbmZ1bGxOYW1lRXhjZXB0aW9ucy5CdWxrRXJyb3IgPSBCdWxrRXJyb3I7XG5cbmZ1bmN0aW9uIG5vcCgpIHsgfVxuZnVuY3Rpb24gbWlycm9yKHZhbCkgeyByZXR1cm4gdmFsOyB9XG5mdW5jdGlvbiBwdXJlRnVuY3Rpb25DaGFpbihmMSwgZjIpIHtcbiAgICBpZiAoZjEgPT0gbnVsbCB8fCBmMSA9PT0gbWlycm9yKVxuICAgICAgICByZXR1cm4gZjI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIGYyKGYxKHZhbCkpO1xuICAgIH07XG59XG5mdW5jdGlvbiBjYWxsQm90aChvbjEsIG9uMikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9uMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBvbjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gaG9va0NyZWF0aW5nQ2hhaW4oZjEsIGYyKSB7XG4gICAgaWYgKGYxID09PSBub3ApXG4gICAgICAgIHJldHVybiBmMjtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzID0gZjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHJlcyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgYXJndW1lbnRzWzBdID0gcmVzO1xuICAgICAgICB2YXIgb25zdWNjZXNzID0gdGhpcy5vbnN1Y2Nlc3MsXG4gICAgICAgIG9uZXJyb3IgPSB0aGlzLm9uZXJyb3I7XG4gICAgICAgIHRoaXMub25zdWNjZXNzID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgdmFyIHJlczIgPSBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAob25zdWNjZXNzKVxuICAgICAgICAgICAgdGhpcy5vbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcyA/IGNhbGxCb3RoKG9uc3VjY2VzcywgdGhpcy5vbnN1Y2Nlc3MpIDogb25zdWNjZXNzO1xuICAgICAgICBpZiAob25lcnJvcilcbiAgICAgICAgICAgIHRoaXMub25lcnJvciA9IHRoaXMub25lcnJvciA/IGNhbGxCb3RoKG9uZXJyb3IsIHRoaXMub25lcnJvcikgOiBvbmVycm9yO1xuICAgICAgICByZXR1cm4gcmVzMiAhPT0gdW5kZWZpbmVkID8gcmVzMiA6IHJlcztcbiAgICB9O1xufVxuZnVuY3Rpb24gaG9va0RlbGV0aW5nQ2hhaW4oZjEsIGYyKSB7XG4gICAgaWYgKGYxID09PSBub3ApXG4gICAgICAgIHJldHVybiBmMjtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgb25zdWNjZXNzID0gdGhpcy5vbnN1Y2Nlc3MsXG4gICAgICAgIG9uZXJyb3IgPSB0aGlzLm9uZXJyb3I7XG4gICAgICAgIHRoaXMub25zdWNjZXNzID0gdGhpcy5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKG9uc3VjY2VzcylcbiAgICAgICAgICAgIHRoaXMub25zdWNjZXNzID0gdGhpcy5vbnN1Y2Nlc3MgPyBjYWxsQm90aChvbnN1Y2Nlc3MsIHRoaXMub25zdWNjZXNzKSA6IG9uc3VjY2VzcztcbiAgICAgICAgaWYgKG9uZXJyb3IpXG4gICAgICAgICAgICB0aGlzLm9uZXJyb3IgPSB0aGlzLm9uZXJyb3IgPyBjYWxsQm90aChvbmVycm9yLCB0aGlzLm9uZXJyb3IpIDogb25lcnJvcjtcbiAgICB9O1xufVxuZnVuY3Rpb24gaG9va1VwZGF0aW5nQ2hhaW4oZjEsIGYyKSB7XG4gICAgaWYgKGYxID09PSBub3ApXG4gICAgICAgIHJldHVybiBmMjtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vZGlmaWNhdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlcyA9IGYxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGV4dGVuZChtb2RpZmljYXRpb25zLCByZXMpO1xuICAgICAgICB2YXIgb25zdWNjZXNzID0gdGhpcy5vbnN1Y2Nlc3MsXG4gICAgICAgIG9uZXJyb3IgPSB0aGlzLm9uZXJyb3I7XG4gICAgICAgIHRoaXMub25zdWNjZXNzID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgdmFyIHJlczIgPSBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAob25zdWNjZXNzKVxuICAgICAgICAgICAgdGhpcy5vbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcyA/IGNhbGxCb3RoKG9uc3VjY2VzcywgdGhpcy5vbnN1Y2Nlc3MpIDogb25zdWNjZXNzO1xuICAgICAgICBpZiAob25lcnJvcilcbiAgICAgICAgICAgIHRoaXMub25lcnJvciA9IHRoaXMub25lcnJvciA/IGNhbGxCb3RoKG9uZXJyb3IsIHRoaXMub25lcnJvcikgOiBvbmVycm9yO1xuICAgICAgICByZXR1cm4gcmVzID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgKHJlczIgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlczIpIDpcbiAgICAgICAgICAgIChleHRlbmQocmVzLCByZXMyKSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJldmVyc2VTdG9wcGFibGVFdmVudENoYWluKGYxLCBmMikge1xuICAgIGlmIChmMSA9PT0gbm9wKVxuICAgICAgICByZXR1cm4gZjI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gZjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gcHJvbWlzYWJsZUNoYWluKGYxLCBmMikge1xuICAgIGlmIChmMSA9PT0gbm9wKVxuICAgICAgICByZXR1cm4gZjI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlcyA9IGYxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChyZXMgJiYgdHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgdGhpeiA9IHRoaXMsIGkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGkpO1xuICAgICAgICAgICAgd2hpbGUgKGktLSlcbiAgICAgICAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgcmV0dXJuIHJlcy50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZjIuYXBwbHkodGhpeiwgYXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG52YXIgSU5URVJOQUwgPSB7fTtcbmNvbnN0IExPTkdfU1RBQ0tTX0NMSVBfTElNSVQgPSAxMDAsXG5NQVhfTE9OR19TVEFDS1MgPSAyMCwgWk9ORV9FQ0hPX0xJTUlUID0gMTAwLCBbcmVzb2x2ZWROYXRpdmVQcm9taXNlLCBuYXRpdmVQcm9taXNlUHJvdG8sIHJlc29sdmVkR2xvYmFsUHJvbWlzZV0gPSB0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcgP1xuICAgIFtdIDpcbiAgICAoKCkgPT4ge1xuICAgICAgICBsZXQgZ2xvYmFsUCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICBpZiAodHlwZW9mIGNyeXB0byA9PT0gJ3VuZGVmaW5lZCcgfHwgIWNyeXB0by5zdWJ0bGUpXG4gICAgICAgICAgICByZXR1cm4gW2dsb2JhbFAsIGdldFByb3RvKGdsb2JhbFApLCBnbG9iYWxQXTtcbiAgICAgICAgY29uc3QgbmF0aXZlUCA9IGNyeXB0by5zdWJ0bGUuZGlnZXN0KFwiU0hBLTUxMlwiLCBuZXcgVWludDhBcnJheShbMF0pKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5hdGl2ZVAsXG4gICAgICAgICAgICBnZXRQcm90byhuYXRpdmVQKSxcbiAgICAgICAgICAgIGdsb2JhbFBcbiAgICAgICAgXTtcbiAgICB9KSgpLCBuYXRpdmVQcm9taXNlVGhlbiA9IG5hdGl2ZVByb21pc2VQcm90byAmJiBuYXRpdmVQcm9taXNlUHJvdG8udGhlbjtcbmNvbnN0IE5hdGl2ZVByb21pc2UgPSByZXNvbHZlZE5hdGl2ZVByb21pc2UgJiYgcmVzb2x2ZWROYXRpdmVQcm9taXNlLmNvbnN0cnVjdG9yO1xuY29uc3QgcGF0Y2hHbG9iYWxQcm9taXNlID0gISFyZXNvbHZlZEdsb2JhbFByb21pc2U7XG52YXIgc3RhY2tfYmVpbmdfZ2VuZXJhdGVkID0gZmFsc2U7XG52YXIgc2NoZWR1bGVQaHlzaWNhbFRpY2sgPSByZXNvbHZlZEdsb2JhbFByb21pc2UgP1xuICAgICgpID0+IHsgcmVzb2x2ZWRHbG9iYWxQcm9taXNlLnRoZW4ocGh5c2ljYWxUaWNrKTsgfVxuICAgIDpcbiAgICAgICAgX2dsb2JhbC5zZXRJbW1lZGlhdGUgP1xuICAgICAgICAgICAgc2V0SW1tZWRpYXRlLmJpbmQobnVsbCwgcGh5c2ljYWxUaWNrKSA6XG4gICAgICAgICAgICBfZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgP1xuICAgICAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhpZGRlbkRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgICAgIChuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwaHlzaWNhbFRpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGRlbkRpdiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH0pKS5vYnNlcnZlKGhpZGRlbkRpdiwgeyBhdHRyaWJ1dGVzOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICBoaWRkZW5EaXYuc2V0QXR0cmlidXRlKCdpJywgJzEnKTtcbiAgICAgICAgICAgICAgICB9IDpcbiAgICAgICAgICAgICAgICAoKSA9PiB7IHNldFRpbWVvdXQocGh5c2ljYWxUaWNrLCAwKTsgfTtcbnZhciBhc2FwID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBhcmdzKSB7XG4gICAgbWljcm90aWNrUXVldWUucHVzaChbY2FsbGJhY2ssIGFyZ3NdKTtcbiAgICBpZiAobmVlZHNOZXdQaHlzaWNhbFRpY2spIHtcbiAgICAgICAgc2NoZWR1bGVQaHlzaWNhbFRpY2soKTtcbiAgICAgICAgbmVlZHNOZXdQaHlzaWNhbFRpY2sgPSBmYWxzZTtcbiAgICB9XG59O1xudmFyIGlzT3V0c2lkZU1pY3JvVGljayA9IHRydWUsXG5uZWVkc05ld1BoeXNpY2FsVGljayA9IHRydWUsXG51bmhhbmRsZWRFcnJvcnMgPSBbXSxcbnJlamVjdGluZ0Vycm9ycyA9IFtdLFxuY3VycmVudEZ1bGZpbGxlciA9IG51bGwsIHJlamVjdGlvbk1hcHBlciA9IG1pcnJvcjtcbnZhciBnbG9iYWxQU0QgPSB7XG4gICAgaWQ6ICdnbG9iYWwnLFxuICAgIGdsb2JhbDogdHJ1ZSxcbiAgICByZWY6IDAsXG4gICAgdW5oYW5kbGVkczogW10sXG4gICAgb251bmhhbmRsZWQ6IGdsb2JhbEVycm9yLFxuICAgIHBncDogZmFsc2UsXG4gICAgZW52OiB7fSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVuaGFuZGxlZHMuZm9yRWFjaCh1aCA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGdsb2JhbEVycm9yKHVoWzBdLCB1aFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG52YXIgUFNEID0gZ2xvYmFsUFNEO1xudmFyIG1pY3JvdGlja1F1ZXVlID0gW107XG52YXIgbnVtU2NoZWR1bGVkQ2FsbHMgPSAwO1xudmFyIHRpY2tGaW5hbGl6ZXJzID0gW107XG5mdW5jdGlvbiBEZXhpZVByb21pc2UoZm4pIHtcbiAgICBpZiAodHlwZW9mIHRoaXMgIT09ICdvYmplY3QnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm9taXNlcyBtdXN0IGJlIGNvbnN0cnVjdGVkIHZpYSBuZXcnKTtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLm9udW5jYXRjaGVkID0gbm9wO1xuICAgIHRoaXMuX2xpYiA9IGZhbHNlO1xuICAgIHZhciBwc2QgPSAodGhpcy5fUFNEID0gUFNEKTtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgdGhpcy5fc3RhY2tIb2xkZXIgPSBnZXRFcnJvcldpdGhTdGFjaygpO1xuICAgICAgICB0aGlzLl9wcmV2ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbnVtUHJldiA9IDA7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKGZuICE9PSBJTlRFUk5BTClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBmYWxzZSlcbiAgICAgICAgICAgIGhhbmRsZVJlamVjdGlvbih0aGlzLCB0aGlzLl92YWx1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fc3RhdGUgPSBudWxsO1xuICAgIHRoaXMuX3ZhbHVlID0gbnVsbDtcbiAgICArK3BzZC5yZWY7XG4gICAgZXhlY3V0ZVByb21pc2VUYXNrKHRoaXMsIGZuKTtcbn1cbmNvbnN0IHRoZW5Qcm9wID0ge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHNkID0gUFNELCBtaWNyb1Rhc2tJZCA9IHRvdGFsRWNob2VzO1xuICAgICAgICBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgICAgICB2YXIgcG9zc2libGVBd2FpdCA9ICFwc2QuZ2xvYmFsICYmIChwc2QgIT09IFBTRCB8fCBtaWNyb1Rhc2tJZCAhPT0gdG90YWxFY2hvZXMpO1xuICAgICAgICAgICAgY29uc3QgY2xlYW51cCA9IHBvc3NpYmxlQXdhaXQgJiYgIWRlY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgICAgICB2YXIgcnYgPSBuZXcgRGV4aWVQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBwcm9wYWdhdGVUb0xpc3RlbmVyKHRoaXMsIG5ldyBMaXN0ZW5lcihuYXRpdmVBd2FpdENvbXBhdGlibGVXcmFwKG9uRnVsZmlsbGVkLCBwc2QsIHBvc3NpYmxlQXdhaXQsIGNsZWFudXApLCBuYXRpdmVBd2FpdENvbXBhdGlibGVXcmFwKG9uUmVqZWN0ZWQsIHBzZCwgcG9zc2libGVBd2FpdCwgY2xlYW51cCksIHJlc29sdmUsIHJlamVjdCwgcHNkKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlYnVnICYmIGxpbmtUb1ByZXZpb3VzUHJvbWlzZShydiwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgIH1cbiAgICAgICAgdGhlbi5wcm90b3R5cGUgPSBJTlRFUk5BTDtcbiAgICAgICAgcmV0dXJuIHRoZW47XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBzZXRQcm9wKHRoaXMsICd0aGVuJywgdmFsdWUgJiYgdmFsdWUucHJvdG90eXBlID09PSBJTlRFUk5BTCA/XG4gICAgICAgICAgICB0aGVuUHJvcCA6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogdGhlblByb3Auc2V0XG4gICAgICAgICAgICB9KTtcbiAgICB9XG59O1xucHJvcHMoRGV4aWVQcm9taXNlLnByb3RvdHlwZSwge1xuICAgIHRoZW46IHRoZW5Qcm9wLFxuICAgIF90aGVuOiBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgcHJvcGFnYXRlVG9MaXN0ZW5lcih0aGlzLCBuZXcgTGlzdGVuZXIobnVsbCwgbnVsbCwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIFBTRCkpO1xuICAgIH0sXG4gICAgY2F0Y2g6IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGVkKTtcbiAgICAgICAgdmFyIHR5cGUgPSBhcmd1bWVudHNbMF0sIGhhbmRsZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMudGhlbihudWxsLCBlcnIgPT5cbiAgICAgICAgZXJyIGluc3RhbmNlb2YgdHlwZSA/IGhhbmRsZXIoZXJyKSA6IFByb21pc2VSZWplY3QoZXJyKSlcbiAgICAgICAgICAgIDogdGhpcy50aGVuKG51bGwsIGVyciA9PlxuICAgICAgICAgICAgZXJyICYmIGVyci5uYW1lID09PSB0eXBlID8gaGFuZGxlcihlcnIpIDogUHJvbWlzZVJlamVjdChlcnIpKTtcbiAgICB9LFxuICAgIGZpbmFsbHk6IGZ1bmN0aW9uIChvbkZpbmFsbHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbih2YWx1ZSA9PiB7XG4gICAgICAgICAgICBvbkZpbmFsbHkoKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICAgIG9uRmluYWxseSgpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2VSZWplY3QoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBzdGFjazoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGFjaylcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhY2s7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0YWNrX2JlaW5nX2dlbmVyYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIHN0YWNrcyA9IGdldFN0YWNrKHRoaXMsIFtdLCBNQVhfTE9OR19TVEFDS1MpO1xuICAgICAgICAgICAgICAgIHZhciBzdGFjayA9IHN0YWNrcy5qb2luKFwiXFxuRnJvbSBwcmV2aW91czogXCIpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2sgPSBzdGFjaztcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBzdGFja19iZWluZ19nZW5lcmF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgdGltZW91dDogZnVuY3Rpb24gKG1zLCBtc2cpIHtcbiAgICAgICAgcmV0dXJuIG1zIDwgSW5maW5pdHkgP1xuICAgICAgICAgICAgbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBleGNlcHRpb25zLlRpbWVvdXQobXNnKSksIG1zKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KS5maW5hbGx5KGNsZWFyVGltZW91dC5iaW5kKG51bGwsIGhhbmRsZSkpO1xuICAgICAgICAgICAgfSkgOiB0aGlzO1xuICAgIH1cbn0pO1xuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZylcbiAgICBzZXRQcm9wKERleGllUHJvbWlzZS5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywgJ0RleGllLlByb21pc2UnKTtcbmdsb2JhbFBTRC5lbnYgPSBzbmFwU2hvdCgpO1xuZnVuY3Rpb24gTGlzdGVuZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHJlc29sdmUsIHJlamVjdCwgem9uZSkge1xuICAgIHRoaXMub25GdWxmaWxsZWQgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IG51bGw7XG4gICAgdGhpcy5vblJlamVjdGVkID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT09ICdmdW5jdGlvbicgPyBvblJlamVjdGVkIDogbnVsbDtcbiAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xuICAgIHRoaXMucHNkID0gem9uZTtcbn1cbnByb3BzKERleGllUHJvbWlzZSwge1xuICAgIGFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWVzID0gZ2V0QXJyYXlPZi5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gICAgICAgICAgICAubWFwKG9uUG9zc2libGVQYXJhbGxlbGxBc3luYyk7XG4gICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJlc29sdmUoW10pO1xuICAgICAgICAgICAgdmFyIHJlbWFpbmluZyA9IHZhbHVlcy5sZW5ndGg7XG4gICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaCgoYSwgaSkgPT4gRGV4aWVQcm9taXNlLnJlc29sdmUoYSkudGhlbih4ID0+IHtcbiAgICAgICAgICAgICAgICB2YWx1ZXNbaV0gPSB4O1xuICAgICAgICAgICAgICAgIGlmICghLS1yZW1haW5pbmcpXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgICAgIH0sIHJlamVjdCkpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIHJlc29sdmU6IHZhbHVlID0+IHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGV4aWVQcm9taXNlKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFsdWUudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHZhciBydiA9IG5ldyBEZXhpZVByb21pc2UoSU5URVJOQUwsIHRydWUsIHZhbHVlKTtcbiAgICAgICAgbGlua1RvUHJldmlvdXNQcm9taXNlKHJ2LCBjdXJyZW50RnVsZmlsbGVyKTtcbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgIH0sXG4gICAgcmVqZWN0OiBQcm9taXNlUmVqZWN0LFxuICAgIHJhY2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IGdldEFycmF5T2YuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5tYXAob25Qb3NzaWJsZVBhcmFsbGVsbEFzeW5jKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdmFsdWVzLm1hcCh2YWx1ZSA9PiBEZXhpZVByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihyZXNvbHZlLCByZWplY3QpKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBQU0Q6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBQU0QsXG4gICAgICAgIHNldDogdmFsdWUgPT4gUFNEID0gdmFsdWVcbiAgICB9LFxuICAgIHRvdGFsRWNob2VzOiB7IGdldDogKCkgPT4gdG90YWxFY2hvZXMgfSxcbiAgICBuZXdQU0Q6IG5ld1Njb3BlLFxuICAgIHVzZVBTRDogdXNlUFNELFxuICAgIHNjaGVkdWxlcjoge1xuICAgICAgICBnZXQ6ICgpID0+IGFzYXAsXG4gICAgICAgIHNldDogdmFsdWUgPT4geyBhc2FwID0gdmFsdWU7IH1cbiAgICB9LFxuICAgIHJlamVjdGlvbk1hcHBlcjoge1xuICAgICAgICBnZXQ6ICgpID0+IHJlamVjdGlvbk1hcHBlcixcbiAgICAgICAgc2V0OiB2YWx1ZSA9PiB7IHJlamVjdGlvbk1hcHBlciA9IHZhbHVlOyB9XG4gICAgfSxcbiAgICBmb2xsb3c6IChmbiwgem9uZVByb3BzKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXdTY29wZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHBzZCA9IFBTRDtcbiAgICAgICAgICAgICAgICBwc2QudW5oYW5kbGVkcyA9IFtdO1xuICAgICAgICAgICAgICAgIHBzZC5vbnVuaGFuZGxlZCA9IHJlamVjdDtcbiAgICAgICAgICAgICAgICBwc2QuZmluYWxpemUgPSBjYWxsQm90aChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bl9hdF9lbmRfb2ZfdGhpc19vcl9uZXh0X3BoeXNpY2FsX3RpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51bmhhbmRsZWRzLmxlbmd0aCA9PT0gMCA/IHJlc29sdmUoKSA6IHJlamVjdCh0aGlzLnVuaGFuZGxlZHNbMF0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCBwc2QuZmluYWxpemUpO1xuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICB9LCB6b25lUHJvcHMsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuaWYgKE5hdGl2ZVByb21pc2UpIHtcbiAgICBpZiAoTmF0aXZlUHJvbWlzZS5hbGxTZXR0bGVkKVxuICAgICAgICBzZXRQcm9wKERleGllUHJvbWlzZSwgXCJhbGxTZXR0bGVkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlUHJvbWlzZXMgPSBnZXRBcnJheU9mLmFwcGx5KG51bGwsIGFyZ3VtZW50cykubWFwKG9uUG9zc2libGVQYXJhbGxlbGxBc3luYyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocG9zc2libGVQcm9taXNlcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoW10pO1xuICAgICAgICAgICAgICAgIGxldCByZW1haW5pbmcgPSBwb3NzaWJsZVByb21pc2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzID0gbmV3IEFycmF5KHJlbWFpbmluZyk7XG4gICAgICAgICAgICAgICAgcG9zc2libGVQcm9taXNlcy5mb3JFYWNoKChwLCBpKSA9PiBEZXhpZVByb21pc2UucmVzb2x2ZShwKS50aGVuKHZhbHVlID0+IHJlc3VsdHNbaV0gPSB7IHN0YXR1czogXCJmdWxmaWxsZWRcIiwgdmFsdWUgfSwgcmVhc29uID0+IHJlc3VsdHNbaV0gPSB7IHN0YXR1czogXCJyZWplY3RlZFwiLCByZWFzb24gfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gLS1yZW1haW5pbmcgfHwgcmVzb2x2ZShyZXN1bHRzKSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIGlmIChOYXRpdmVQcm9taXNlLmFueSAmJiB0eXBlb2YgQWdncmVnYXRlRXJyb3IgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICBzZXRQcm9wKERleGllUHJvbWlzZSwgXCJhbnlcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgcG9zc2libGVQcm9taXNlcyA9IGdldEFycmF5T2YuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5tYXAob25Qb3NzaWJsZVBhcmFsbGVsbEFzeW5jKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocG9zc2libGVQcm9taXNlcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgQWdncmVnYXRlRXJyb3IoW10pKTtcbiAgICAgICAgICAgICAgICBsZXQgcmVtYWluaW5nID0gcG9zc2libGVQcm9taXNlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgZmFpbHVyZXMgPSBuZXcgQXJyYXkocmVtYWluaW5nKTtcbiAgICAgICAgICAgICAgICBwb3NzaWJsZVByb21pc2VzLmZvckVhY2goKHAsIGkpID0+IERleGllUHJvbWlzZS5yZXNvbHZlKHApLnRoZW4odmFsdWUgPT4gcmVzb2x2ZSh2YWx1ZSksIGZhaWx1cmUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBmYWlsdXJlc1tpXSA9IGZhaWx1cmU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghLS1yZW1haW5pbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEFnZ3JlZ2F0ZUVycm9yKGZhaWx1cmVzKSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xufVxuZnVuY3Rpb24gZXhlY3V0ZVByb21pc2VUYXNrKHByb21pc2UsIGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgZm4odmFsdWUgPT4ge1xuICAgICAgICAgICAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gcHJvbWlzZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIHByb21pc2UgY2Fubm90IGJlIHJlc29sdmVkIHdpdGggaXRzZWxmLicpO1xuICAgICAgICAgICAgdmFyIHNob3VsZEV4ZWN1dGVUaWNrID0gcHJvbWlzZS5fbGliICYmIGJlZ2luTWljcm9UaWNrU2NvcGUoKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGV4ZWN1dGVQcm9taXNlVGFzayhwcm9taXNlLCAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgRGV4aWVQcm9taXNlID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLl90aGVuKHJlc29sdmUsIHJlamVjdCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fc3RhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByb21pc2UuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcHJvcGFnYXRlQWxsTGlzdGVuZXJzKHByb21pc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNob3VsZEV4ZWN1dGVUaWNrKVxuICAgICAgICAgICAgICAgIGVuZE1pY3JvVGlja1Njb3BlKCk7XG4gICAgICAgIH0sIGhhbmRsZVJlamVjdGlvbi5iaW5kKG51bGwsIHByb21pc2UpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgIGhhbmRsZVJlamVjdGlvbihwcm9taXNlLCBleCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFuZGxlUmVqZWN0aW9uKHByb21pc2UsIHJlYXNvbikge1xuICAgIHJlamVjdGluZ0Vycm9ycy5wdXNoKHJlYXNvbik7XG4gICAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIHNob3VsZEV4ZWN1dGVUaWNrID0gcHJvbWlzZS5fbGliICYmIGJlZ2luTWljcm9UaWNrU2NvcGUoKTtcbiAgICByZWFzb24gPSByZWplY3Rpb25NYXBwZXIocmVhc29uKTtcbiAgICBwcm9taXNlLl9zdGF0ZSA9IGZhbHNlO1xuICAgIHByb21pc2UuX3ZhbHVlID0gcmVhc29uO1xuICAgIGRlYnVnICYmIHJlYXNvbiAhPT0gbnVsbCAmJiB0eXBlb2YgcmVhc29uID09PSAnb2JqZWN0JyAmJiAhcmVhc29uLl9wcm9taXNlICYmIHRyeUNhdGNoKCgpID0+IHtcbiAgICAgICAgdmFyIG9yaWdQcm9wID0gZ2V0UHJvcGVydHlEZXNjcmlwdG9yKHJlYXNvbiwgXCJzdGFja1wiKTtcbiAgICAgICAgcmVhc29uLl9wcm9taXNlID0gcHJvbWlzZTtcbiAgICAgICAgc2V0UHJvcChyZWFzb24sIFwic3RhY2tcIiwge1xuICAgICAgICAgICAgZ2V0OiAoKSA9PiBzdGFja19iZWluZ19nZW5lcmF0ZWQgP1xuICAgICAgICAgICAgICAgIG9yaWdQcm9wICYmIChvcmlnUHJvcC5nZXQgP1xuICAgICAgICAgICAgICAgICAgICBvcmlnUHJvcC5nZXQuYXBwbHkocmVhc29uKSA6XG4gICAgICAgICAgICAgICAgICAgIG9yaWdQcm9wLnZhbHVlKSA6XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5zdGFja1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBhZGRQb3NzaWJseVVuaGFuZGxlZEVycm9yKHByb21pc2UpO1xuICAgIHByb3BhZ2F0ZUFsbExpc3RlbmVycyhwcm9taXNlKTtcbiAgICBpZiAoc2hvdWxkRXhlY3V0ZVRpY2spXG4gICAgICAgIGVuZE1pY3JvVGlja1Njb3BlKCk7XG59XG5mdW5jdGlvbiBwcm9wYWdhdGVBbGxMaXN0ZW5lcnMocHJvbWlzZSkge1xuICAgIHZhciBsaXN0ZW5lcnMgPSBwcm9taXNlLl9saXN0ZW5lcnM7XG4gICAgcHJvbWlzZS5fbGlzdGVuZXJzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBwcm9wYWdhdGVUb0xpc3RlbmVyKHByb21pc2UsIGxpc3RlbmVyc1tpXSk7XG4gICAgfVxuICAgIHZhciBwc2QgPSBwcm9taXNlLl9QU0Q7XG4gICAgLS1wc2QucmVmIHx8IHBzZC5maW5hbGl6ZSgpO1xuICAgIGlmIChudW1TY2hlZHVsZWRDYWxscyA9PT0gMCkge1xuICAgICAgICArK251bVNjaGVkdWxlZENhbGxzO1xuICAgICAgICBhc2FwKCgpID0+IHtcbiAgICAgICAgICAgIGlmICgtLW51bVNjaGVkdWxlZENhbGxzID09PSAwKVxuICAgICAgICAgICAgICAgIGZpbmFsaXplUGh5c2ljYWxUaWNrKCk7XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwcm9wYWdhdGVUb0xpc3RlbmVyKHByb21pc2UsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHByb21pc2UuX3N0YXRlID09PSBudWxsKSB7XG4gICAgICAgIHByb21pc2UuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY2IgPSBwcm9taXNlLl9zdGF0ZSA/IGxpc3RlbmVyLm9uRnVsZmlsbGVkIDogbGlzdGVuZXIub25SZWplY3RlZDtcbiAgICBpZiAoY2IgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIChwcm9taXNlLl9zdGF0ZSA/IGxpc3RlbmVyLnJlc29sdmUgOiBsaXN0ZW5lci5yZWplY3QpKHByb21pc2UuX3ZhbHVlKTtcbiAgICB9XG4gICAgKytsaXN0ZW5lci5wc2QucmVmO1xuICAgICsrbnVtU2NoZWR1bGVkQ2FsbHM7XG4gICAgYXNhcChjYWxsTGlzdGVuZXIsIFtjYiwgcHJvbWlzZSwgbGlzdGVuZXJdKTtcbn1cbmZ1bmN0aW9uIGNhbGxMaXN0ZW5lcihjYiwgcHJvbWlzZSwgbGlzdGVuZXIpIHtcbiAgICB0cnkge1xuICAgICAgICBjdXJyZW50RnVsZmlsbGVyID0gcHJvbWlzZTtcbiAgICAgICAgdmFyIHJldCwgdmFsdWUgPSBwcm9taXNlLl92YWx1ZTtcbiAgICAgICAgaWYgKHByb21pc2UuX3N0YXRlKSB7XG4gICAgICAgICAgICByZXQgPSBjYih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocmVqZWN0aW5nRXJyb3JzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZWplY3RpbmdFcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIHJldCA9IGNiKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChyZWplY3RpbmdFcnJvcnMuaW5kZXhPZih2YWx1ZSkgPT09IC0xKVxuICAgICAgICAgICAgICAgIG1hcmtFcnJvckFzSGFuZGxlZChwcm9taXNlKTtcbiAgICAgICAgfVxuICAgICAgICBsaXN0ZW5lci5yZXNvbHZlKHJldCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGxpc3RlbmVyLnJlamVjdChlKTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGN1cnJlbnRGdWxmaWxsZXIgPSBudWxsO1xuICAgICAgICBpZiAoLS1udW1TY2hlZHVsZWRDYWxscyA9PT0gMClcbiAgICAgICAgICAgIGZpbmFsaXplUGh5c2ljYWxUaWNrKCk7XG4gICAgICAgIC0tbGlzdGVuZXIucHNkLnJlZiB8fCBsaXN0ZW5lci5wc2QuZmluYWxpemUoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRTdGFjayhwcm9taXNlLCBzdGFja3MsIGxpbWl0KSB7XG4gICAgaWYgKHN0YWNrcy5sZW5ndGggPT09IGxpbWl0KVxuICAgICAgICByZXR1cm4gc3RhY2tzO1xuICAgIHZhciBzdGFjayA9IFwiXCI7XG4gICAgaWYgKHByb21pc2UuX3N0YXRlID09PSBmYWxzZSkge1xuICAgICAgICB2YXIgZmFpbHVyZSA9IHByb21pc2UuX3ZhbHVlLCBlcnJvck5hbWUsIG1lc3NhZ2U7XG4gICAgICAgIGlmIChmYWlsdXJlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGVycm9yTmFtZSA9IGZhaWx1cmUubmFtZSB8fCBcIkVycm9yXCI7XG4gICAgICAgICAgICBtZXNzYWdlID0gZmFpbHVyZS5tZXNzYWdlIHx8IGZhaWx1cmU7XG4gICAgICAgICAgICBzdGFjayA9IHByZXR0eVN0YWNrKGZhaWx1cmUsIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXJyb3JOYW1lID0gZmFpbHVyZTtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHN0YWNrcy5wdXNoKGVycm9yTmFtZSArIChtZXNzYWdlID8gXCI6IFwiICsgbWVzc2FnZSA6IFwiXCIpICsgc3RhY2spO1xuICAgIH1cbiAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgc3RhY2sgPSBwcmV0dHlTdGFjayhwcm9taXNlLl9zdGFja0hvbGRlciwgMik7XG4gICAgICAgIGlmIChzdGFjayAmJiBzdGFja3MuaW5kZXhPZihzdGFjaykgPT09IC0xKVxuICAgICAgICAgICAgc3RhY2tzLnB1c2goc3RhY2spO1xuICAgICAgICBpZiAocHJvbWlzZS5fcHJldilcbiAgICAgICAgICAgIGdldFN0YWNrKHByb21pc2UuX3ByZXYsIHN0YWNrcywgbGltaXQpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhY2tzO1xufVxuZnVuY3Rpb24gbGlua1RvUHJldmlvdXNQcm9taXNlKHByb21pc2UsIHByZXYpIHtcbiAgICB2YXIgbnVtUHJldiA9IHByZXYgPyBwcmV2Ll9udW1QcmV2ICsgMSA6IDA7XG4gICAgaWYgKG51bVByZXYgPCBMT05HX1NUQUNLU19DTElQX0xJTUlUKSB7XG4gICAgICAgIHByb21pc2UuX3ByZXYgPSBwcmV2O1xuICAgICAgICBwcm9taXNlLl9udW1QcmV2ID0gbnVtUHJldjtcbiAgICB9XG59XG5mdW5jdGlvbiBwaHlzaWNhbFRpY2soKSB7XG4gICAgYmVnaW5NaWNyb1RpY2tTY29wZSgpICYmIGVuZE1pY3JvVGlja1Njb3BlKCk7XG59XG5mdW5jdGlvbiBiZWdpbk1pY3JvVGlja1Njb3BlKCkge1xuICAgIHZhciB3YXNSb290RXhlYyA9IGlzT3V0c2lkZU1pY3JvVGljaztcbiAgICBpc091dHNpZGVNaWNyb1RpY2sgPSBmYWxzZTtcbiAgICBuZWVkc05ld1BoeXNpY2FsVGljayA9IGZhbHNlO1xuICAgIHJldHVybiB3YXNSb290RXhlYztcbn1cbmZ1bmN0aW9uIGVuZE1pY3JvVGlja1Njb3BlKCkge1xuICAgIHZhciBjYWxsYmFja3MsIGksIGw7XG4gICAgZG8ge1xuICAgICAgICB3aGlsZSAobWljcm90aWNrUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY2FsbGJhY2tzID0gbWljcm90aWNrUXVldWU7XG4gICAgICAgICAgICBtaWNyb3RpY2tRdWV1ZSA9IFtdO1xuICAgICAgICAgICAgbCA9IGNhbGxiYWNrcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBjYWxsYmFja3NbaV07XG4gICAgICAgICAgICAgICAgaXRlbVswXS5hcHBseShudWxsLCBpdGVtWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKG1pY3JvdGlja1F1ZXVlLmxlbmd0aCA+IDApO1xuICAgIGlzT3V0c2lkZU1pY3JvVGljayA9IHRydWU7XG4gICAgbmVlZHNOZXdQaHlzaWNhbFRpY2sgPSB0cnVlO1xufVxuZnVuY3Rpb24gZmluYWxpemVQaHlzaWNhbFRpY2soKSB7XG4gICAgdmFyIHVuaGFuZGxlZEVycnMgPSB1bmhhbmRsZWRFcnJvcnM7XG4gICAgdW5oYW5kbGVkRXJyb3JzID0gW107XG4gICAgdW5oYW5kbGVkRXJycy5mb3JFYWNoKHAgPT4ge1xuICAgICAgICBwLl9QU0Qub251bmhhbmRsZWQuY2FsbChudWxsLCBwLl92YWx1ZSwgcCk7XG4gICAgfSk7XG4gICAgdmFyIGZpbmFsaXplcnMgPSB0aWNrRmluYWxpemVycy5zbGljZSgwKTtcbiAgICB2YXIgaSA9IGZpbmFsaXplcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpKVxuICAgICAgICBmaW5hbGl6ZXJzWy0taV0oKTtcbn1cbmZ1bmN0aW9uIHJ1bl9hdF9lbmRfb2ZfdGhpc19vcl9uZXh0X3BoeXNpY2FsX3RpY2soZm4pIHtcbiAgICBmdW5jdGlvbiBmaW5hbGl6ZXIoKSB7XG4gICAgICAgIGZuKCk7XG4gICAgICAgIHRpY2tGaW5hbGl6ZXJzLnNwbGljZSh0aWNrRmluYWxpemVycy5pbmRleE9mKGZpbmFsaXplciksIDEpO1xuICAgIH1cbiAgICB0aWNrRmluYWxpemVycy5wdXNoKGZpbmFsaXplcik7XG4gICAgKytudW1TY2hlZHVsZWRDYWxscztcbiAgICBhc2FwKCgpID0+IHtcbiAgICAgICAgaWYgKC0tbnVtU2NoZWR1bGVkQ2FsbHMgPT09IDApXG4gICAgICAgICAgICBmaW5hbGl6ZVBoeXNpY2FsVGljaygpO1xuICAgIH0sIFtdKTtcbn1cbmZ1bmN0aW9uIGFkZFBvc3NpYmx5VW5oYW5kbGVkRXJyb3IocHJvbWlzZSkge1xuICAgIGlmICghdW5oYW5kbGVkRXJyb3JzLnNvbWUocCA9PiBwLl92YWx1ZSA9PT0gcHJvbWlzZS5fdmFsdWUpKVxuICAgICAgICB1bmhhbmRsZWRFcnJvcnMucHVzaChwcm9taXNlKTtcbn1cbmZ1bmN0aW9uIG1hcmtFcnJvckFzSGFuZGxlZChwcm9taXNlKSB7XG4gICAgdmFyIGkgPSB1bmhhbmRsZWRFcnJvcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpKVxuICAgICAgICBpZiAodW5oYW5kbGVkRXJyb3JzWy0taV0uX3ZhbHVlID09PSBwcm9taXNlLl92YWx1ZSkge1xuICAgICAgICAgICAgdW5oYW5kbGVkRXJyb3JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxufVxuZnVuY3Rpb24gUHJvbWlzZVJlamVjdChyZWFzb24pIHtcbiAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZShJTlRFUk5BTCwgZmFsc2UsIHJlYXNvbik7XG59XG5mdW5jdGlvbiB3cmFwKGZuLCBlcnJvckNhdGNoZXIpIHtcbiAgICB2YXIgcHNkID0gUFNEO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3YXNSb290RXhlYyA9IGJlZ2luTWljcm9UaWNrU2NvcGUoKSwgb3V0ZXJTY29wZSA9IFBTRDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN3aXRjaFRvWm9uZShwc2QsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGVycm9yQ2F0Y2hlciAmJiBlcnJvckNhdGNoZXIoZSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBzd2l0Y2hUb1pvbmUob3V0ZXJTY29wZSwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKHdhc1Jvb3RFeGVjKVxuICAgICAgICAgICAgICAgIGVuZE1pY3JvVGlja1Njb3BlKCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuY29uc3QgdGFzayA9IHsgYXdhaXRzOiAwLCBlY2hvZXM6IDAsIGlkOiAwIH07XG52YXIgdGFza0NvdW50ZXIgPSAwO1xudmFyIHpvbmVTdGFjayA9IFtdO1xudmFyIHpvbmVFY2hvZXMgPSAwO1xudmFyIHRvdGFsRWNob2VzID0gMDtcbnZhciB6b25lX2lkX2NvdW50ZXIgPSAwO1xuZnVuY3Rpb24gbmV3U2NvcGUoZm4sIHByb3BzLCBhMSwgYTIpIHtcbiAgICB2YXIgcGFyZW50ID0gUFNELCBwc2QgPSBPYmplY3QuY3JlYXRlKHBhcmVudCk7XG4gICAgcHNkLnBhcmVudCA9IHBhcmVudDtcbiAgICBwc2QucmVmID0gMDtcbiAgICBwc2QuZ2xvYmFsID0gZmFsc2U7XG4gICAgcHNkLmlkID0gKyt6b25lX2lkX2NvdW50ZXI7XG4gICAgdmFyIGdsb2JhbEVudiA9IGdsb2JhbFBTRC5lbnY7XG4gICAgcHNkLmVudiA9IHBhdGNoR2xvYmFsUHJvbWlzZSA/IHtcbiAgICAgICAgUHJvbWlzZTogRGV4aWVQcm9taXNlLFxuICAgICAgICBQcm9taXNlUHJvcDogeyB2YWx1ZTogRGV4aWVQcm9taXNlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0sXG4gICAgICAgIGFsbDogRGV4aWVQcm9taXNlLmFsbCxcbiAgICAgICAgcmFjZTogRGV4aWVQcm9taXNlLnJhY2UsXG4gICAgICAgIGFsbFNldHRsZWQ6IERleGllUHJvbWlzZS5hbGxTZXR0bGVkLFxuICAgICAgICBhbnk6IERleGllUHJvbWlzZS5hbnksXG4gICAgICAgIHJlc29sdmU6IERleGllUHJvbWlzZS5yZXNvbHZlLFxuICAgICAgICByZWplY3Q6IERleGllUHJvbWlzZS5yZWplY3QsXG4gICAgICAgIG50aGVuOiBnZXRQYXRjaGVkUHJvbWlzZVRoZW4oZ2xvYmFsRW52Lm50aGVuLCBwc2QpLFxuICAgICAgICBndGhlbjogZ2V0UGF0Y2hlZFByb21pc2VUaGVuKGdsb2JhbEVudi5ndGhlbiwgcHNkKVxuICAgIH0gOiB7fTtcbiAgICBpZiAocHJvcHMpXG4gICAgICAgIGV4dGVuZChwc2QsIHByb3BzKTtcbiAgICArK3BhcmVudC5yZWY7XG4gICAgcHNkLmZpbmFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAtLXRoaXMucGFyZW50LnJlZiB8fCB0aGlzLnBhcmVudC5maW5hbGl6ZSgpO1xuICAgIH07XG4gICAgdmFyIHJ2ID0gdXNlUFNEKHBzZCwgZm4sIGExLCBhMik7XG4gICAgaWYgKHBzZC5yZWYgPT09IDApXG4gICAgICAgIHBzZC5maW5hbGl6ZSgpO1xuICAgIHJldHVybiBydjtcbn1cbmZ1bmN0aW9uIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCkge1xuICAgIGlmICghdGFzay5pZClcbiAgICAgICAgdGFzay5pZCA9ICsrdGFza0NvdW50ZXI7XG4gICAgKyt0YXNrLmF3YWl0cztcbiAgICB0YXNrLmVjaG9lcyArPSBaT05FX0VDSE9fTElNSVQ7XG4gICAgcmV0dXJuIHRhc2suaWQ7XG59XG5mdW5jdGlvbiBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cygpIHtcbiAgICBpZiAoIXRhc2suYXdhaXRzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKC0tdGFzay5hd2FpdHMgPT09IDApXG4gICAgICAgIHRhc2suaWQgPSAwO1xuICAgIHRhc2suZWNob2VzID0gdGFzay5hd2FpdHMgKiBaT05FX0VDSE9fTElNSVQ7XG4gICAgcmV0dXJuIHRydWU7XG59XG5pZiAoKCcnICsgbmF0aXZlUHJvbWlzZVRoZW4pLmluZGV4T2YoJ1tuYXRpdmUgY29kZV0nKSA9PT0gLTEpIHtcbiAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cyA9IGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzID0gbm9wO1xufVxuZnVuY3Rpb24gb25Qb3NzaWJsZVBhcmFsbGVsbEFzeW5jKHBvc3NpYmxlUHJvbWlzZSkge1xuICAgIGlmICh0YXNrLmVjaG9lcyAmJiBwb3NzaWJsZVByb21pc2UgJiYgcG9zc2libGVQcm9taXNlLmNvbnN0cnVjdG9yID09PSBOYXRpdmVQcm9taXNlKSB7XG4gICAgICAgIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgIHJldHVybiBwb3NzaWJsZVByb21pc2UudGhlbih4ID0+IHtcbiAgICAgICAgICAgIGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfSwgZSA9PiB7XG4gICAgICAgICAgICBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwb3NzaWJsZVByb21pc2U7XG59XG5mdW5jdGlvbiB6b25lRW50ZXJFY2hvKHRhcmdldFpvbmUpIHtcbiAgICArK3RvdGFsRWNob2VzO1xuICAgIGlmICghdGFzay5lY2hvZXMgfHwgLS10YXNrLmVjaG9lcyA9PT0gMCkge1xuICAgICAgICB0YXNrLmVjaG9lcyA9IHRhc2suaWQgPSAwO1xuICAgIH1cbiAgICB6b25lU3RhY2sucHVzaChQU0QpO1xuICAgIHN3aXRjaFRvWm9uZSh0YXJnZXRab25lLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIHpvbmVMZWF2ZUVjaG8oKSB7XG4gICAgdmFyIHpvbmUgPSB6b25lU3RhY2tbem9uZVN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIHpvbmVTdGFjay5wb3AoKTtcbiAgICBzd2l0Y2hUb1pvbmUoem9uZSwgZmFsc2UpO1xufVxuZnVuY3Rpb24gc3dpdGNoVG9ab25lKHRhcmdldFpvbmUsIGJFbnRlcmluZ1pvbmUpIHtcbiAgICB2YXIgY3VycmVudFpvbmUgPSBQU0Q7XG4gICAgaWYgKGJFbnRlcmluZ1pvbmUgPyB0YXNrLmVjaG9lcyAmJiAoIXpvbmVFY2hvZXMrKyB8fCB0YXJnZXRab25lICE9PSBQU0QpIDogem9uZUVjaG9lcyAmJiAoIS0tem9uZUVjaG9lcyB8fCB0YXJnZXRab25lICE9PSBQU0QpKSB7XG4gICAgICAgIGVucXVldWVOYXRpdmVNaWNyb1Rhc2soYkVudGVyaW5nWm9uZSA/IHpvbmVFbnRlckVjaG8uYmluZChudWxsLCB0YXJnZXRab25lKSA6IHpvbmVMZWF2ZUVjaG8pO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0Wm9uZSA9PT0gUFNEKVxuICAgICAgICByZXR1cm47XG4gICAgUFNEID0gdGFyZ2V0Wm9uZTtcbiAgICBpZiAoY3VycmVudFpvbmUgPT09IGdsb2JhbFBTRClcbiAgICAgICAgZ2xvYmFsUFNELmVudiA9IHNuYXBTaG90KCk7XG4gICAgaWYgKHBhdGNoR2xvYmFsUHJvbWlzZSkge1xuICAgICAgICB2YXIgR2xvYmFsUHJvbWlzZSA9IGdsb2JhbFBTRC5lbnYuUHJvbWlzZTtcbiAgICAgICAgdmFyIHRhcmdldEVudiA9IHRhcmdldFpvbmUuZW52O1xuICAgICAgICBuYXRpdmVQcm9taXNlUHJvdG8udGhlbiA9IHRhcmdldEVudi5udGhlbjtcbiAgICAgICAgR2xvYmFsUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IHRhcmdldEVudi5ndGhlbjtcbiAgICAgICAgaWYgKGN1cnJlbnRab25lLmdsb2JhbCB8fCB0YXJnZXRab25lLmdsb2JhbCkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9nbG9iYWwsICdQcm9taXNlJywgdGFyZ2V0RW52LlByb21pc2VQcm9wKTtcbiAgICAgICAgICAgIEdsb2JhbFByb21pc2UuYWxsID0gdGFyZ2V0RW52LmFsbDtcbiAgICAgICAgICAgIEdsb2JhbFByb21pc2UucmFjZSA9IHRhcmdldEVudi5yYWNlO1xuICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5yZXNvbHZlID0gdGFyZ2V0RW52LnJlc29sdmU7XG4gICAgICAgICAgICBHbG9iYWxQcm9taXNlLnJlamVjdCA9IHRhcmdldEVudi5yZWplY3Q7XG4gICAgICAgICAgICBpZiAodGFyZ2V0RW52LmFsbFNldHRsZWQpXG4gICAgICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5hbGxTZXR0bGVkID0gdGFyZ2V0RW52LmFsbFNldHRsZWQ7XG4gICAgICAgICAgICBpZiAodGFyZ2V0RW52LmFueSlcbiAgICAgICAgICAgICAgICBHbG9iYWxQcm9taXNlLmFueSA9IHRhcmdldEVudi5hbnk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBzbmFwU2hvdCgpIHtcbiAgICB2YXIgR2xvYmFsUHJvbWlzZSA9IF9nbG9iYWwuUHJvbWlzZTtcbiAgICByZXR1cm4gcGF0Y2hHbG9iYWxQcm9taXNlID8ge1xuICAgICAgICBQcm9taXNlOiBHbG9iYWxQcm9taXNlLFxuICAgICAgICBQcm9taXNlUHJvcDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihfZ2xvYmFsLCBcIlByb21pc2VcIiksXG4gICAgICAgIGFsbDogR2xvYmFsUHJvbWlzZS5hbGwsXG4gICAgICAgIHJhY2U6IEdsb2JhbFByb21pc2UucmFjZSxcbiAgICAgICAgYWxsU2V0dGxlZDogR2xvYmFsUHJvbWlzZS5hbGxTZXR0bGVkLFxuICAgICAgICBhbnk6IEdsb2JhbFByb21pc2UuYW55LFxuICAgICAgICByZXNvbHZlOiBHbG9iYWxQcm9taXNlLnJlc29sdmUsXG4gICAgICAgIHJlamVjdDogR2xvYmFsUHJvbWlzZS5yZWplY3QsXG4gICAgICAgIG50aGVuOiBuYXRpdmVQcm9taXNlUHJvdG8udGhlbixcbiAgICAgICAgZ3RoZW46IEdsb2JhbFByb21pc2UucHJvdG90eXBlLnRoZW5cbiAgICB9IDoge307XG59XG5mdW5jdGlvbiB1c2VQU0QocHNkLCBmbiwgYTEsIGEyLCBhMykge1xuICAgIHZhciBvdXRlclNjb3BlID0gUFNEO1xuICAgIHRyeSB7XG4gICAgICAgIHN3aXRjaFRvWm9uZShwc2QsIHRydWUpO1xuICAgICAgICByZXR1cm4gZm4oYTEsIGEyLCBhMyk7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBzd2l0Y2hUb1pvbmUob3V0ZXJTY29wZSwgZmFsc2UpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVucXVldWVOYXRpdmVNaWNyb1Rhc2soam9iKSB7XG4gICAgbmF0aXZlUHJvbWlzZVRoZW4uY2FsbChyZXNvbHZlZE5hdGl2ZVByb21pc2UsIGpvYik7XG59XG5mdW5jdGlvbiBuYXRpdmVBd2FpdENvbXBhdGlibGVXcmFwKGZuLCB6b25lLCBwb3NzaWJsZUF3YWl0LCBjbGVhbnVwKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJyA/IGZuIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3V0ZXJab25lID0gUFNEO1xuICAgICAgICBpZiAocG9zc2libGVBd2FpdClcbiAgICAgICAgICAgIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgIHN3aXRjaFRvWm9uZSh6b25lLCB0cnVlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgc3dpdGNoVG9ab25lKG91dGVyWm9uZSwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGNsZWFudXApXG4gICAgICAgICAgICAgICAgZW5xdWV1ZU5hdGl2ZU1pY3JvVGFzayhkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cyk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0UGF0Y2hlZFByb21pc2VUaGVuKG9yaWdUaGVuLCB6b25lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvblJlc29sdmVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiBvcmlnVGhlbi5jYWxsKHRoaXMsIG5hdGl2ZUF3YWl0Q29tcGF0aWJsZVdyYXAob25SZXNvbHZlZCwgem9uZSksIG5hdGl2ZUF3YWl0Q29tcGF0aWJsZVdyYXAob25SZWplY3RlZCwgem9uZSkpO1xuICAgIH07XG59XG5jb25zdCBVTkhBTkRMRURSRUpFQ1RJT04gPSBcInVuaGFuZGxlZHJlamVjdGlvblwiO1xuZnVuY3Rpb24gZ2xvYmFsRXJyb3IoZXJyLCBwcm9taXNlKSB7XG4gICAgdmFyIHJ2O1xuICAgIHRyeSB7XG4gICAgICAgIHJ2ID0gcHJvbWlzZS5vbnVuY2F0Y2hlZChlcnIpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkgeyB9XG4gICAgaWYgKHJ2ICE9PSBmYWxzZSlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBldmVudCwgZXZlbnREYXRhID0geyBwcm9taXNlOiBwcm9taXNlLCByZWFzb246IGVyciB9O1xuICAgICAgICAgICAgaWYgKF9nbG9iYWwuZG9jdW1lbnQgJiYgZG9jdW1lbnQuY3JlYXRlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgICAgICAgICAgIGV2ZW50LmluaXRFdmVudChVTkhBTkRMRURSRUpFQ1RJT04sIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIGV4dGVuZChldmVudCwgZXZlbnREYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF9nbG9iYWwuQ3VzdG9tRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudCA9IG5ldyBDdXN0b21FdmVudChVTkhBTkRMRURSRUpFQ1RJT04sIHsgZGV0YWlsOiBldmVudERhdGEgfSk7XG4gICAgICAgICAgICAgICAgZXh0ZW5kKGV2ZW50LCBldmVudERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV2ZW50ICYmIF9nbG9iYWwuZGlzcGF0Y2hFdmVudCkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmICghX2dsb2JhbC5Qcm9taXNlUmVqZWN0aW9uRXZlbnQgJiYgX2dsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9nbG9iYWwub251bmhhbmRsZWRyZWplY3Rpb24oZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWJ1ZyAmJiBldmVudCAmJiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5oYW5kbGVkIHJlamVjdGlvbjogJHtlcnIuc3RhY2sgfHwgZXJyfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbn1cbnZhciByZWplY3Rpb24gPSBEZXhpZVByb21pc2UucmVqZWN0O1xuXG5mdW5jdGlvbiB0ZW1wVHJhbnNhY3Rpb24oZGIsIG1vZGUsIHN0b3JlTmFtZXMsIGZuKSB7XG4gICAgaWYgKCFkYi5pZGJkYiB8fCAoIWRiLl9zdGF0ZS5vcGVuQ29tcGxldGUgJiYgKCFQU0QubGV0VGhyb3VnaCAmJiAhZGIuX3ZpcCkpKSB7XG4gICAgICAgIGlmIChkYi5fc3RhdGUub3BlbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKGRiLl9zdGF0ZS5kYk9wZW5FcnJvcikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGIuX3N0YXRlLmlzQmVpbmdPcGVuZWQpIHtcbiAgICAgICAgICAgIGlmICghZGIuX29wdGlvbnMuYXV0b09wZW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZCgpKTtcbiAgICAgICAgICAgIGRiLm9wZW4oKS5jYXRjaChub3ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYi5fc3RhdGUuZGJSZWFkeVByb21pc2UudGhlbigoKSA9PiB0ZW1wVHJhbnNhY3Rpb24oZGIsIG1vZGUsIHN0b3JlTmFtZXMsIGZuKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgdHJhbnMgPSBkYi5fY3JlYXRlVHJhbnNhY3Rpb24obW9kZSwgc3RvcmVOYW1lcywgZGIuX2RiU2NoZW1hKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRyYW5zLmNyZWF0ZSgpO1xuICAgICAgICAgICAgZGIuX3N0YXRlLlBSMTM5OF9tYXhMb29wID0gMztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIGlmIChleC5uYW1lID09PSBlcnJuYW1lcy5JbnZhbGlkU3RhdGUgJiYgZGIuaXNPcGVuKCkgJiYgLS1kYi5fc3RhdGUuUFIxMzk4X21heExvb3AgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdEZXhpZTogTmVlZCB0byByZW9wZW4gZGInKTtcbiAgICAgICAgICAgICAgICBkYi5fY2xvc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGIub3BlbigpLnRoZW4oKCkgPT4gdGVtcFRyYW5zYWN0aW9uKGRiLCBtb2RlLCBzdG9yZU5hbWVzLCBmbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihleCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYW5zLl9wcm9taXNlKG1vZGUsIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXdTY29wZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgUFNELnRyYW5zID0gdHJhbnM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKHJlc29sdmUsIHJlamVjdCwgdHJhbnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0cmFucy5fY29tcGxldGlvbi50aGVuKCgpID0+IHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY29uc3QgREVYSUVfVkVSU0lPTiA9ICczLjIuNyc7XG5jb25zdCBtYXhTdHJpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDY1NTM1KTtcbmNvbnN0IG1pbktleSA9IC1JbmZpbml0eTtcbmNvbnN0IElOVkFMSURfS0VZX0FSR1VNRU5UID0gXCJJbnZhbGlkIGtleSBwcm92aWRlZC4gS2V5cyBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLCBudW1iZXIsIERhdGUgb3IgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgRGF0ZT4uXCI7XG5jb25zdCBTVFJJTkdfRVhQRUNURUQgPSBcIlN0cmluZyBleHBlY3RlZC5cIjtcbmNvbnN0IGNvbm5lY3Rpb25zID0gW107XG5jb25zdCBpc0lFT3JFZGdlID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgLyhNU0lFfFRyaWRlbnR8RWRnZSkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5jb25zdCBoYXNJRURlbGV0ZU9iamVjdFN0b3JlQnVnID0gaXNJRU9yRWRnZTtcbmNvbnN0IGhhbmdzT25EZWxldGVMYXJnZUtleVJhbmdlID0gaXNJRU9yRWRnZTtcbmNvbnN0IGRleGllU3RhY2tGcmFtZUZpbHRlciA9IGZyYW1lID0+ICEvKGRleGllXFwuanN8ZGV4aWVcXC5taW5cXC5qcykvLnRlc3QoZnJhbWUpO1xuY29uc3QgREJOQU1FU19EQiA9ICdfX2RibmFtZXMnO1xuY29uc3QgUkVBRE9OTFkgPSAncmVhZG9ubHknO1xuY29uc3QgUkVBRFdSSVRFID0gJ3JlYWR3cml0ZSc7XG5cbmZ1bmN0aW9uIGNvbWJpbmUoZmlsdGVyMSwgZmlsdGVyMikge1xuICAgIHJldHVybiBmaWx0ZXIxID9cbiAgICAgICAgZmlsdGVyMiA/XG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBmaWx0ZXIxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgJiYgZmlsdGVyMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IDpcbiAgICAgICAgICAgIGZpbHRlcjEgOlxuICAgICAgICBmaWx0ZXIyO1xufVxuXG5jb25zdCBBbnlSYW5nZSA9IHtcbiAgICB0eXBlOiAzICxcbiAgICBsb3dlcjogLUluZmluaXR5LFxuICAgIGxvd2VyT3BlbjogZmFsc2UsXG4gICAgdXBwZXI6IFtbXV0sXG4gICAgdXBwZXJPcGVuOiBmYWxzZVxufTtcblxuZnVuY3Rpb24gd29ya2Fyb3VuZEZvclVuZGVmaW5lZFByaW1LZXkoa2V5UGF0aCkge1xuICAgIHJldHVybiB0eXBlb2Yga2V5UGF0aCA9PT0gXCJzdHJpbmdcIiAmJiAhL1xcLi8udGVzdChrZXlQYXRoKVxuICAgICAgICA/IChvYmopID0+IHtcbiAgICAgICAgICAgIGlmIChvYmpba2V5UGF0aF0gPT09IHVuZGVmaW5lZCAmJiAoa2V5UGF0aCBpbiBvYmopKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gZGVlcENsb25lKG9iaik7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9ialtrZXlQYXRoXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgOiAob2JqKSA9PiBvYmo7XG59XG5cbmNsYXNzIFRhYmxlIHtcbiAgICBfdHJhbnMobW9kZSwgZm4sIHdyaXRlTG9ja2VkKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zID0gdGhpcy5fdHggfHwgUFNELnRyYW5zO1xuICAgICAgICBjb25zdCB0YWJsZU5hbWUgPSB0aGlzLm5hbWU7XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrVGFibGVJblRyYW5zYWN0aW9uKHJlc29sdmUsIHJlamVjdCwgdHJhbnMpIHtcbiAgICAgICAgICAgIGlmICghdHJhbnMuc2NoZW1hW3RhYmxlTmFtZV0pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTm90Rm91bmQoXCJUYWJsZSBcIiArIHRhYmxlTmFtZSArIFwiIG5vdCBwYXJ0IG9mIHRyYW5zYWN0aW9uXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZuKHRyYW5zLmlkYnRyYW5zLCB0cmFucyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2FzUm9vdEV4ZWMgPSBiZWdpbk1pY3JvVGlja1Njb3BlKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnMgJiYgdHJhbnMuZGIgPT09IHRoaXMuZGIgP1xuICAgICAgICAgICAgICAgIHRyYW5zID09PSBQU0QudHJhbnMgP1xuICAgICAgICAgICAgICAgICAgICB0cmFucy5fcHJvbWlzZShtb2RlLCBjaGVja1RhYmxlSW5UcmFuc2FjdGlvbiwgd3JpdGVMb2NrZWQpIDpcbiAgICAgICAgICAgICAgICAgICAgbmV3U2NvcGUoKCkgPT4gdHJhbnMuX3Byb21pc2UobW9kZSwgY2hlY2tUYWJsZUluVHJhbnNhY3Rpb24sIHdyaXRlTG9ja2VkKSwgeyB0cmFuczogdHJhbnMsIHRyYW5zbGVzczogUFNELnRyYW5zbGVzcyB8fCBQU0QgfSkgOlxuICAgICAgICAgICAgICAgIHRlbXBUcmFuc2FjdGlvbih0aGlzLmRiLCBtb2RlLCBbdGhpcy5uYW1lXSwgY2hlY2tUYWJsZUluVHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKHdhc1Jvb3RFeGVjKVxuICAgICAgICAgICAgICAgIGVuZE1pY3JvVGlja1Njb3BlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0KGtleU9yQ3JpdCwgY2IpIHtcbiAgICAgICAgaWYgKGtleU9yQ3JpdCAmJiBrZXlPckNyaXQuY29uc3RydWN0b3IgPT09IE9iamVjdClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndoZXJlKGtleU9yQ3JpdCkuZmlyc3QoY2IpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWRvbmx5JywgKHRyYW5zKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb3JlLmdldCh7IHRyYW5zLCBrZXk6IGtleU9yQ3JpdCB9KVxuICAgICAgICAgICAgICAgIC50aGVuKHJlcyA9PiB0aGlzLmhvb2sucmVhZGluZy5maXJlKHJlcykpO1xuICAgICAgICB9KS50aGVuKGNiKTtcbiAgICB9XG4gICAgd2hlcmUoaW5kZXhPckNyaXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbmRleE9yQ3JpdCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuZGIuV2hlcmVDbGF1c2UodGhpcywgaW5kZXhPckNyaXQpO1xuICAgICAgICBpZiAoaXNBcnJheShpbmRleE9yQ3JpdCkpXG4gICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuZGIuV2hlcmVDbGF1c2UodGhpcywgYFske2luZGV4T3JDcml0LmpvaW4oJysnKX1dYCk7XG4gICAgICAgIGNvbnN0IGtleVBhdGhzID0ga2V5cyhpbmRleE9yQ3JpdCk7XG4gICAgICAgIGlmIChrZXlQYXRocy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgICAgIC53aGVyZShrZXlQYXRoc1swXSlcbiAgICAgICAgICAgICAgICAuZXF1YWxzKGluZGV4T3JDcml0W2tleVBhdGhzWzBdXSk7XG4gICAgICAgIGNvbnN0IGNvbXBvdW5kSW5kZXggPSB0aGlzLnNjaGVtYS5pbmRleGVzLmNvbmNhdCh0aGlzLnNjaGVtYS5wcmltS2V5KS5maWx0ZXIoaXggPT4ge1xuICAgICAgICAgICAgaWYgKGl4LmNvbXBvdW5kICYmXG4gICAgICAgICAgICAgICAga2V5UGF0aHMuZXZlcnkoa2V5UGF0aCA9PiBpeC5rZXlQYXRoLmluZGV4T2Yoa2V5UGF0aCkgPj0gMCkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleVBhdGhzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlQYXRocy5pbmRleE9mKGl4LmtleVBhdGhbaV0pID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pLnNvcnQoKGEsIGIpID0+IGEua2V5UGF0aC5sZW5ndGggLSBiLmtleVBhdGgubGVuZ3RoKVswXTtcbiAgICAgICAgaWYgKGNvbXBvdW5kSW5kZXggJiYgdGhpcy5kYi5fbWF4S2V5ICE9PSBtYXhTdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleVBhdGhzSW5WYWxpZE9yZGVyID0gY29tcG91bmRJbmRleC5rZXlQYXRoLnNsaWNlKDAsIGtleVBhdGhzLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgICAgIC53aGVyZShrZXlQYXRoc0luVmFsaWRPcmRlcilcbiAgICAgICAgICAgICAgICAuZXF1YWxzKGtleVBhdGhzSW5WYWxpZE9yZGVyLm1hcChrcCA9PiBpbmRleE9yQ3JpdFtrcF0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbXBvdW5kSW5kZXggJiYgZGVidWcpXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFRoZSBxdWVyeSAke0pTT04uc3RyaW5naWZ5KGluZGV4T3JDcml0KX0gb24gJHt0aGlzLm5hbWV9IHdvdWxkIGJlbmVmaXQgb2YgYSBgICtcbiAgICAgICAgICAgICAgICBgY29tcG91bmQgaW5kZXggWyR7a2V5UGF0aHMuam9pbignKycpfV1gKTtcbiAgICAgICAgY29uc3QgeyBpZHhCeU5hbWUgfSA9IHRoaXMuc2NoZW1hO1xuICAgICAgICBjb25zdCBpZGIgPSB0aGlzLmRiLl9kZXBzLmluZGV4ZWREQjtcbiAgICAgICAgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkYi5jbXAoYSwgYikgPT09IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbaWR4LCBmaWx0ZXJGdW5jdGlvbl0gPSBrZXlQYXRocy5yZWR1Y2UoKFtwcmV2SW5kZXgsIHByZXZGaWx0ZXJGbl0sIGtleVBhdGgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gaWR4QnlOYW1lW2tleVBhdGhdO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpbmRleE9yQ3JpdFtrZXlQYXRoXTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgcHJldkluZGV4IHx8IGluZGV4LFxuICAgICAgICAgICAgICAgIHByZXZJbmRleCB8fCAhaW5kZXggP1xuICAgICAgICAgICAgICAgICAgICBjb21iaW5lKHByZXZGaWx0ZXJGbiwgaW5kZXggJiYgaW5kZXgubXVsdGkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcCA9IGdldEJ5S2V5UGF0aCh4LCBrZXlQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNBcnJheShwcm9wKSAmJiBwcm9wLnNvbWUoaXRlbSA9PiBlcXVhbHModmFsdWUsIGl0ZW0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gOiB4ID0+IGVxdWFscyh2YWx1ZSwgZ2V0QnlLZXlQYXRoKHgsIGtleVBhdGgpKSlcbiAgICAgICAgICAgICAgICAgICAgOiBwcmV2RmlsdGVyRm5cbiAgICAgICAgICAgIF07XG4gICAgICAgIH0sIFtudWxsLCBudWxsXSk7XG4gICAgICAgIHJldHVybiBpZHggP1xuICAgICAgICAgICAgdGhpcy53aGVyZShpZHgubmFtZSkuZXF1YWxzKGluZGV4T3JDcml0W2lkeC5rZXlQYXRoXSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZpbHRlckZ1bmN0aW9uKSA6XG4gICAgICAgICAgICBjb21wb3VuZEluZGV4ID9cbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcihmaWx0ZXJGdW5jdGlvbikgOlxuICAgICAgICAgICAgICAgIHRoaXMud2hlcmUoa2V5UGF0aHMpLmVxdWFscygnJyk7XG4gICAgfVxuICAgIGZpbHRlcihmaWx0ZXJGdW5jdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5hbmQoZmlsdGVyRnVuY3Rpb24pO1xuICAgIH1cbiAgICBjb3VudCh0aGVuU2hvcnRjdXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkuY291bnQodGhlblNob3J0Y3V0KTtcbiAgICB9XG4gICAgb2Zmc2V0KG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5vZmZzZXQob2Zmc2V0KTtcbiAgICB9XG4gICAgbGltaXQobnVtUm93cykge1xuICAgICAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5saW1pdChudW1Sb3dzKTtcbiAgICB9XG4gICAgZWFjaChjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5lYWNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgdG9BcnJheSh0aGVuU2hvcnRjdXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkudG9BcnJheSh0aGVuU2hvcnRjdXQpO1xuICAgIH1cbiAgICB0b0NvbGxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5kYi5Db2xsZWN0aW9uKG5ldyB0aGlzLmRiLldoZXJlQ2xhdXNlKHRoaXMpKTtcbiAgICB9XG4gICAgb3JkZXJCeShpbmRleCkge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuZGIuQ29sbGVjdGlvbihuZXcgdGhpcy5kYi5XaGVyZUNsYXVzZSh0aGlzLCBpc0FycmF5KGluZGV4KSA/XG4gICAgICAgICAgICBgWyR7aW5kZXguam9pbignKycpfV1gIDpcbiAgICAgICAgICAgIGluZGV4KSk7XG4gICAgfVxuICAgIHJldmVyc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLnJldmVyc2UoKTtcbiAgICB9XG4gICAgbWFwVG9DbGFzcyhjb25zdHJ1Y3Rvcikge1xuICAgICAgICB0aGlzLnNjaGVtYS5tYXBwZWRDbGFzcyA9IGNvbnN0cnVjdG9yO1xuICAgICAgICBjb25zdCByZWFkSG9vayA9IG9iaiA9PiB7XG4gICAgICAgICAgICBpZiAoIW9iailcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gT2JqZWN0LmNyZWF0ZShjb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgICAgICAgICAgZm9yICh2YXIgbSBpbiBvYmopXG4gICAgICAgICAgICAgICAgaWYgKGhhc093bihvYmosIG0pKVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzW21dID0gb2JqW21dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnNjaGVtYS5yZWFkSG9vaykge1xuICAgICAgICAgICAgdGhpcy5ob29rLnJlYWRpbmcudW5zdWJzY3JpYmUodGhpcy5zY2hlbWEucmVhZEhvb2spO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2NoZW1hLnJlYWRIb29rID0gcmVhZEhvb2s7XG4gICAgICAgIHRoaXMuaG9vayhcInJlYWRpbmdcIiwgcmVhZEhvb2spO1xuICAgICAgICByZXR1cm4gY29uc3RydWN0b3I7XG4gICAgfVxuICAgIGRlZmluZUNsYXNzKCkge1xuICAgICAgICBmdW5jdGlvbiBDbGFzcyhjb250ZW50KSB7XG4gICAgICAgICAgICBleHRlbmQodGhpcywgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubWFwVG9DbGFzcyhDbGFzcyk7XG4gICAgfVxuICAgIGFkZChvYmosIGtleSkge1xuICAgICAgICBjb25zdCB7IGF1dG8sIGtleVBhdGggfSA9IHRoaXMuc2NoZW1hLnByaW1LZXk7XG4gICAgICAgIGxldCBvYmpUb0FkZCA9IG9iajtcbiAgICAgICAgaWYgKGtleVBhdGggJiYgYXV0bykge1xuICAgICAgICAgICAgb2JqVG9BZGQgPSB3b3JrYXJvdW5kRm9yVW5kZWZpbmVkUHJpbUtleShrZXlQYXRoKShvYmopO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgdHJhbnMgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29yZS5tdXRhdGUoeyB0cmFucywgdHlwZTogJ2FkZCcsIGtleXM6IGtleSAhPSBudWxsID8gW2tleV0gOiBudWxsLCB2YWx1ZXM6IFtvYmpUb0FkZF0gfSk7XG4gICAgICAgIH0pLnRoZW4ocmVzID0+IHJlcy5udW1GYWlsdXJlcyA/IERleGllUHJvbWlzZS5yZWplY3QocmVzLmZhaWx1cmVzWzBdKSA6IHJlcy5sYXN0UmVzdWx0KVxuICAgICAgICAgICAgLnRoZW4obGFzdFJlc3VsdCA9PiB7XG4gICAgICAgICAgICBpZiAoa2V5UGF0aCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGgsIGxhc3RSZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGFzdFJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZShrZXlPck9iamVjdCwgbW9kaWZpY2F0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIGtleU9yT2JqZWN0ID09PSAnb2JqZWN0JyAmJiAhaXNBcnJheShrZXlPck9iamVjdCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGdldEJ5S2V5UGF0aChrZXlPck9iamVjdCwgdGhpcy5zY2hlbWEucHJpbUtleS5rZXlQYXRoKTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkdpdmVuIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGl0cyBwcmltYXJ5IGtleVwiKSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbW9kaWZpY2F0aW9ucyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleXMobW9kaWZpY2F0aW9ucykuZm9yRWFjaChrZXlQYXRoID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChrZXlPck9iamVjdCwga2V5UGF0aCwgbW9kaWZpY2F0aW9uc1trZXlQYXRoXSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpY2F0aW9ucyhrZXlPck9iamVjdCwgeyB2YWx1ZToga2V5T3JPYmplY3QsIHByaW1LZXk6IGtleSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLndoZXJlKFwiOmlkXCIpLmVxdWFscyhrZXkpLm1vZGlmeShtb2RpZmljYXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndoZXJlKFwiOmlkXCIpLmVxdWFscyhrZXlPck9iamVjdCkubW9kaWZ5KG1vZGlmaWNhdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHB1dChvYmosIGtleSkge1xuICAgICAgICBjb25zdCB7IGF1dG8sIGtleVBhdGggfSA9IHRoaXMuc2NoZW1hLnByaW1LZXk7XG4gICAgICAgIGxldCBvYmpUb0FkZCA9IG9iajtcbiAgICAgICAgaWYgKGtleVBhdGggJiYgYXV0bykge1xuICAgICAgICAgICAgb2JqVG9BZGQgPSB3b3JrYXJvdW5kRm9yVW5kZWZpbmVkUHJpbUtleShrZXlQYXRoKShvYmopO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgdHJhbnMgPT4gdGhpcy5jb3JlLm11dGF0ZSh7IHRyYW5zLCB0eXBlOiAncHV0JywgdmFsdWVzOiBbb2JqVG9BZGRdLCBrZXlzOiBrZXkgIT0gbnVsbCA/IFtrZXldIDogbnVsbCB9KSlcbiAgICAgICAgICAgIC50aGVuKHJlcyA9PiByZXMubnVtRmFpbHVyZXMgPyBEZXhpZVByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSkgOiByZXMubGFzdFJlc3VsdClcbiAgICAgICAgICAgIC50aGVuKGxhc3RSZXN1bHQgPT4ge1xuICAgICAgICAgICAgaWYgKGtleVBhdGgpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoLCBsYXN0UmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgdHJhbnMgPT4gdGhpcy5jb3JlLm11dGF0ZSh7IHRyYW5zLCB0eXBlOiAnZGVsZXRlJywga2V5czogW2tleV0gfSkpXG4gICAgICAgICAgICAudGhlbihyZXMgPT4gcmVzLm51bUZhaWx1cmVzID8gRGV4aWVQcm9taXNlLnJlamVjdChyZXMuZmFpbHVyZXNbMF0pIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgdHJhbnMgPT4gdGhpcy5jb3JlLm11dGF0ZSh7IHRyYW5zLCB0eXBlOiAnZGVsZXRlUmFuZ2UnLCByYW5nZTogQW55UmFuZ2UgfSkpXG4gICAgICAgICAgICAudGhlbihyZXMgPT4gcmVzLm51bUZhaWx1cmVzID8gRGV4aWVQcm9taXNlLnJlamVjdChyZXMuZmFpbHVyZXNbMF0pIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgYnVsa0dldChrZXlzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZG9ubHknLCB0cmFucyA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb3JlLmdldE1hbnkoe1xuICAgICAgICAgICAgICAgIGtleXMsXG4gICAgICAgICAgICAgICAgdHJhbnNcbiAgICAgICAgICAgIH0pLnRoZW4ocmVzdWx0ID0+IHJlc3VsdC5tYXAocmVzID0+IHRoaXMuaG9vay5yZWFkaW5nLmZpcmUocmVzKSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYnVsa0FkZChvYmplY3RzLCBrZXlzT3JPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBBcnJheS5pc0FycmF5KGtleXNPck9wdGlvbnMpID8ga2V5c09yT3B0aW9ucyA6IHVuZGVmaW5lZDtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgKGtleXMgPyB1bmRlZmluZWQgOiBrZXlzT3JPcHRpb25zKTtcbiAgICAgICAgY29uc3Qgd2FudFJlc3VsdHMgPSBvcHRpb25zID8gb3B0aW9ucy5hbGxLZXlzIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIHRyYW5zID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgYXV0bywga2V5UGF0aCB9ID0gdGhpcy5zY2hlbWEucHJpbUtleTtcbiAgICAgICAgICAgIGlmIChrZXlQYXRoICYmIGtleXMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiYnVsa0FkZCgpOiBrZXlzIGFyZ3VtZW50IGludmFsaWQgb24gdGFibGVzIHdpdGggaW5ib3VuZCBrZXlzXCIpO1xuICAgICAgICAgICAgaWYgKGtleXMgJiYga2V5cy5sZW5ndGggIT09IG9iamVjdHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkFyZ3VtZW50cyBvYmplY3RzIGFuZCBrZXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIik7XG4gICAgICAgICAgICBjb25zdCBudW1PYmplY3RzID0gb2JqZWN0cy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgb2JqZWN0c1RvQWRkID0ga2V5UGF0aCAmJiBhdXRvID9cbiAgICAgICAgICAgICAgICBvYmplY3RzLm1hcCh3b3JrYXJvdW5kRm9yVW5kZWZpbmVkUHJpbUtleShrZXlQYXRoKSkgOlxuICAgICAgICAgICAgICAgIG9iamVjdHM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb3JlLm11dGF0ZSh7IHRyYW5zLCB0eXBlOiAnYWRkJywga2V5czoga2V5cywgdmFsdWVzOiBvYmplY3RzVG9BZGQsIHdhbnRSZXN1bHRzIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKHsgbnVtRmFpbHVyZXMsIHJlc3VsdHMsIGxhc3RSZXN1bHQsIGZhaWx1cmVzIH0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB3YW50UmVzdWx0cyA/IHJlc3VsdHMgOiBsYXN0UmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChudW1GYWlsdXJlcyA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQnVsa0Vycm9yKGAke3RoaXMubmFtZX0uYnVsa0FkZCgpOiAke251bUZhaWx1cmVzfSBvZiAke251bU9iamVjdHN9IG9wZXJhdGlvbnMgZmFpbGVkYCwgZmFpbHVyZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBidWxrUHV0KG9iamVjdHMsIGtleXNPck9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IEFycmF5LmlzQXJyYXkoa2V5c09yT3B0aW9ucykgPyBrZXlzT3JPcHRpb25zIDogdW5kZWZpbmVkO1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCAoa2V5cyA/IHVuZGVmaW5lZCA6IGtleXNPck9wdGlvbnMpO1xuICAgICAgICBjb25zdCB3YW50UmVzdWx0cyA9IG9wdGlvbnMgPyBvcHRpb25zLmFsbEtleXMgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgdHJhbnMgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBhdXRvLCBrZXlQYXRoIH0gPSB0aGlzLnNjaGVtYS5wcmltS2V5O1xuICAgICAgICAgICAgaWYgKGtleVBhdGggJiYga2V5cylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJidWxrUHV0KCk6IGtleXMgYXJndW1lbnQgaW52YWxpZCBvbiB0YWJsZXMgd2l0aCBpbmJvdW5kIGtleXNcIik7XG4gICAgICAgICAgICBpZiAoa2V5cyAmJiBrZXlzLmxlbmd0aCAhPT0gb2JqZWN0cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiQXJndW1lbnRzIG9iamVjdHMgYW5kIGtleXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKTtcbiAgICAgICAgICAgIGNvbnN0IG51bU9iamVjdHMgPSBvYmplY3RzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBvYmplY3RzVG9QdXQgPSBrZXlQYXRoICYmIGF1dG8gP1xuICAgICAgICAgICAgICAgIG9iamVjdHMubWFwKHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5KGtleVBhdGgpKSA6XG4gICAgICAgICAgICAgICAgb2JqZWN0cztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvcmUubXV0YXRlKHsgdHJhbnMsIHR5cGU6ICdwdXQnLCBrZXlzOiBrZXlzLCB2YWx1ZXM6IG9iamVjdHNUb1B1dCwgd2FudFJlc3VsdHMgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoeyBudW1GYWlsdXJlcywgcmVzdWx0cywgbGFzdFJlc3VsdCwgZmFpbHVyZXMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHdhbnRSZXN1bHRzID8gcmVzdWx0cyA6IGxhc3RSZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKG51bUZhaWx1cmVzID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCdWxrRXJyb3IoYCR7dGhpcy5uYW1lfS5idWxrUHV0KCk6ICR7bnVtRmFpbHVyZXN9IG9mICR7bnVtT2JqZWN0c30gb3BlcmF0aW9ucyBmYWlsZWRgLCBmYWlsdXJlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJ1bGtEZWxldGUoa2V5cykge1xuICAgICAgICBjb25zdCBudW1LZXlzID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgdHJhbnMgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29yZS5tdXRhdGUoeyB0cmFucywgdHlwZTogJ2RlbGV0ZScsIGtleXM6IGtleXMgfSk7XG4gICAgICAgIH0pLnRoZW4oKHsgbnVtRmFpbHVyZXMsIGxhc3RSZXN1bHQsIGZhaWx1cmVzIH0pID0+IHtcbiAgICAgICAgICAgIGlmIChudW1GYWlsdXJlcyA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFzdFJlc3VsdDtcbiAgICAgICAgICAgIHRocm93IG5ldyBCdWxrRXJyb3IoYCR7dGhpcy5uYW1lfS5idWxrRGVsZXRlKCk6ICR7bnVtRmFpbHVyZXN9IG9mICR7bnVtS2V5c30gb3BlcmF0aW9ucyBmYWlsZWRgLCBmYWlsdXJlcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gRXZlbnRzKGN0eCkge1xuICAgIHZhciBldnMgPSB7fTtcbiAgICB2YXIgcnYgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBzdWJzY3JpYmVyKSB7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoaSAtIDEpO1xuICAgICAgICAgICAgd2hpbGUgKC0taSlcbiAgICAgICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGV2c1tldmVudE5hbWVdLnN1YnNjcmliZS5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgIHJldHVybiBjdHg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIChldmVudE5hbWUpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGV2c1tldmVudE5hbWVdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBydi5hZGRFdmVudFR5cGUgPSBhZGQ7XG4gICAgZm9yICh2YXIgaSA9IDEsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgIGFkZChhcmd1bWVudHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcnY7XG4gICAgZnVuY3Rpb24gYWRkKGV2ZW50TmFtZSwgY2hhaW5GdW5jdGlvbiwgZGVmYXVsdEZ1bmN0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnROYW1lID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHJldHVybiBhZGRDb25maWd1cmVkRXZlbnRzKGV2ZW50TmFtZSk7XG4gICAgICAgIGlmICghY2hhaW5GdW5jdGlvbilcbiAgICAgICAgICAgIGNoYWluRnVuY3Rpb24gPSByZXZlcnNlU3RvcHBhYmxlRXZlbnRDaGFpbjtcbiAgICAgICAgaWYgKCFkZWZhdWx0RnVuY3Rpb24pXG4gICAgICAgICAgICBkZWZhdWx0RnVuY3Rpb24gPSBub3A7XG4gICAgICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICAgICAgc3Vic2NyaWJlcnM6IFtdLFxuICAgICAgICAgICAgZmlyZTogZGVmYXVsdEZ1bmN0aW9uLFxuICAgICAgICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5zdWJzY3JpYmVycy5pbmRleE9mKGNiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdWJzY3JpYmVycy5wdXNoKGNiKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5maXJlID0gY2hhaW5GdW5jdGlvbihjb250ZXh0LmZpcmUsIGNiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Vic2NyaWJlcnMgPSBjb250ZXh0LnN1YnNjcmliZXJzLmZpbHRlcihmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuICE9PSBjYjsgfSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5maXJlID0gY29udGV4dC5zdWJzY3JpYmVycy5yZWR1Y2UoY2hhaW5GdW5jdGlvbiwgZGVmYXVsdEZ1bmN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZXZzW2V2ZW50TmFtZV0gPSBydltldmVudE5hbWVdID0gY29udGV4dDtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZENvbmZpZ3VyZWRFdmVudHMoY2ZnKSB7XG4gICAgICAgIGtleXMoY2ZnKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gY2ZnW2V2ZW50TmFtZV07XG4gICAgICAgICAgICBpZiAoaXNBcnJheShhcmdzKSkge1xuICAgICAgICAgICAgICAgIGFkZChldmVudE5hbWUsIGNmZ1tldmVudE5hbWVdWzBdLCBjZmdbZXZlbnROYW1lXVsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhcmdzID09PSAnYXNhcCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IGFkZChldmVudE5hbWUsIG1pcnJvciwgZnVuY3Rpb24gZmlyZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGkpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNhcCQxKGZ1bmN0aW9uIGZpcmVFdmVudCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJJbnZhbGlkIGV2ZW50IGNvbmZpZ1wiKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBtYWtlQ2xhc3NDb25zdHJ1Y3Rvcihwcm90b3R5cGUsIGNvbnN0cnVjdG9yKSB7XG4gICAgZGVyaXZlKGNvbnN0cnVjdG9yKS5mcm9tKHsgcHJvdG90eXBlIH0pO1xuICAgIHJldHVybiBjb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGFibGVDb25zdHJ1Y3RvcihkYikge1xuICAgIHJldHVybiBtYWtlQ2xhc3NDb25zdHJ1Y3RvcihUYWJsZS5wcm90b3R5cGUsIGZ1bmN0aW9uIFRhYmxlKG5hbWUsIHRhYmxlU2NoZW1hLCB0cmFucykge1xuICAgICAgICB0aGlzLmRiID0gZGI7XG4gICAgICAgIHRoaXMuX3R4ID0gdHJhbnM7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gdGFibGVTY2hlbWE7XG4gICAgICAgIHRoaXMuaG9vayA9IGRiLl9hbGxUYWJsZXNbbmFtZV0gPyBkYi5fYWxsVGFibGVzW25hbWVdLmhvb2sgOiBFdmVudHMobnVsbCwge1xuICAgICAgICAgICAgXCJjcmVhdGluZ1wiOiBbaG9va0NyZWF0aW5nQ2hhaW4sIG5vcF0sXG4gICAgICAgICAgICBcInJlYWRpbmdcIjogW3B1cmVGdW5jdGlvbkNoYWluLCBtaXJyb3JdLFxuICAgICAgICAgICAgXCJ1cGRhdGluZ1wiOiBbaG9va1VwZGF0aW5nQ2hhaW4sIG5vcF0sXG4gICAgICAgICAgICBcImRlbGV0aW5nXCI6IFtob29rRGVsZXRpbmdDaGFpbiwgbm9wXVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gaXNQbGFpbktleVJhbmdlKGN0eCwgaWdub3JlTGltaXRGaWx0ZXIpIHtcbiAgICByZXR1cm4gIShjdHguZmlsdGVyIHx8IGN0eC5hbGdvcml0aG0gfHwgY3R4Lm9yKSAmJlxuICAgICAgICAoaWdub3JlTGltaXRGaWx0ZXIgPyBjdHguanVzdExpbWl0IDogIWN0eC5yZXBsYXlGaWx0ZXIpO1xufVxuZnVuY3Rpb24gYWRkRmlsdGVyKGN0eCwgZm4pIHtcbiAgICBjdHguZmlsdGVyID0gY29tYmluZShjdHguZmlsdGVyLCBmbik7XG59XG5mdW5jdGlvbiBhZGRSZXBsYXlGaWx0ZXIoY3R4LCBmYWN0b3J5LCBpc0xpbWl0RmlsdGVyKSB7XG4gICAgdmFyIGN1cnIgPSBjdHgucmVwbGF5RmlsdGVyO1xuICAgIGN0eC5yZXBsYXlGaWx0ZXIgPSBjdXJyID8gKCkgPT4gY29tYmluZShjdXJyKCksIGZhY3RvcnkoKSkgOiBmYWN0b3J5O1xuICAgIGN0eC5qdXN0TGltaXQgPSBpc0xpbWl0RmlsdGVyICYmICFjdXJyO1xufVxuZnVuY3Rpb24gYWRkTWF0Y2hGaWx0ZXIoY3R4LCBmbikge1xuICAgIGN0eC5pc01hdGNoID0gY29tYmluZShjdHguaXNNYXRjaCwgZm4pO1xufVxuZnVuY3Rpb24gZ2V0SW5kZXhPclN0b3JlKGN0eCwgY29yZVNjaGVtYSkge1xuICAgIGlmIChjdHguaXNQcmltS2V5KVxuICAgICAgICByZXR1cm4gY29yZVNjaGVtYS5wcmltYXJ5S2V5O1xuICAgIGNvbnN0IGluZGV4ID0gY29yZVNjaGVtYS5nZXRJbmRleEJ5S2V5UGF0aChjdHguaW5kZXgpO1xuICAgIGlmICghaW5kZXgpXG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlNjaGVtYShcIktleVBhdGggXCIgKyBjdHguaW5kZXggKyBcIiBvbiBvYmplY3Qgc3RvcmUgXCIgKyBjb3JlU2NoZW1hLm5hbWUgKyBcIiBpcyBub3QgaW5kZXhlZFwiKTtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBvcGVuQ3Vyc29yKGN0eCwgY29yZVRhYmxlLCB0cmFucykge1xuICAgIGNvbnN0IGluZGV4ID0gZ2V0SW5kZXhPclN0b3JlKGN0eCwgY29yZVRhYmxlLnNjaGVtYSk7XG4gICAgcmV0dXJuIGNvcmVUYWJsZS5vcGVuQ3Vyc29yKHtcbiAgICAgICAgdHJhbnMsXG4gICAgICAgIHZhbHVlczogIWN0eC5rZXlzT25seSxcbiAgICAgICAgcmV2ZXJzZTogY3R4LmRpciA9PT0gJ3ByZXYnLFxuICAgICAgICB1bmlxdWU6ICEhY3R4LnVuaXF1ZSxcbiAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgcmFuZ2U6IGN0eC5yYW5nZVxuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpdGVyKGN0eCwgZm4sIGNvcmVUcmFucywgY29yZVRhYmxlKSB7XG4gICAgY29uc3QgZmlsdGVyID0gY3R4LnJlcGxheUZpbHRlciA/IGNvbWJpbmUoY3R4LmZpbHRlciwgY3R4LnJlcGxheUZpbHRlcigpKSA6IGN0eC5maWx0ZXI7XG4gICAgaWYgKCFjdHgub3IpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdGUob3BlbkN1cnNvcihjdHgsIGNvcmVUYWJsZSwgY29yZVRyYW5zKSwgY29tYmluZShjdHguYWxnb3JpdGhtLCBmaWx0ZXIpLCBmbiwgIWN0eC5rZXlzT25seSAmJiBjdHgudmFsdWVNYXBwZXIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgc2V0ID0ge307XG4gICAgICAgIGNvbnN0IHVuaW9uID0gKGl0ZW0sIGN1cnNvciwgYWR2YW5jZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGN1cnNvciwgYWR2YW5jZSwgcmVzdWx0ID0+IGN1cnNvci5zdG9wKHJlc3VsdCksIGVyciA9PiBjdXJzb3IuZmFpbChlcnIpKSkge1xuICAgICAgICAgICAgICAgIHZhciBwcmltYXJ5S2V5ID0gY3Vyc29yLnByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9ICcnICsgcHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKVxuICAgICAgICAgICAgICAgICAgICBrZXkgPSAnJyArIG5ldyBVaW50OEFycmF5KHByaW1hcnlLZXkpO1xuICAgICAgICAgICAgICAgIGlmICghaGFzT3duKHNldCwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGZuKGl0ZW0sIGN1cnNvciwgYWR2YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgY3R4Lm9yLl9pdGVyYXRlKHVuaW9uLCBjb3JlVHJhbnMpLFxuICAgICAgICAgICAgaXRlcmF0ZShvcGVuQ3Vyc29yKGN0eCwgY29yZVRhYmxlLCBjb3JlVHJhbnMpLCBjdHguYWxnb3JpdGhtLCB1bmlvbiwgIWN0eC5rZXlzT25seSAmJiBjdHgudmFsdWVNYXBwZXIpXG4gICAgICAgIF0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGl0ZXJhdGUoY3Vyc29yUHJvbWlzZSwgZmlsdGVyLCBmbiwgdmFsdWVNYXBwZXIpIHtcbiAgICB2YXIgbWFwcGVkRm4gPSB2YWx1ZU1hcHBlciA/ICh4LCBjLCBhKSA9PiBmbih2YWx1ZU1hcHBlcih4KSwgYywgYSkgOiBmbjtcbiAgICB2YXIgd3JhcHBlZEZuID0gd3JhcChtYXBwZWRGbik7XG4gICAgcmV0dXJuIGN1cnNvclByb21pc2UudGhlbihjdXJzb3IgPT4ge1xuICAgICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgICAgICByZXR1cm4gY3Vyc29yLnN0YXJ0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9ICgpID0+IGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgICAgICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihjdXJzb3IsIGFkdmFuY2VyID0+IGMgPSBhZHZhbmNlciwgdmFsID0+IHsgY3Vyc29yLnN0b3AodmFsKTsgYyA9IG5vcDsgfSwgZSA9PiB7IGN1cnNvci5mYWlsKGUpOyBjID0gbm9wOyB9KSlcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlZEZuKGN1cnNvci52YWx1ZSwgY3Vyc29yLCBhZHZhbmNlciA9PiBjID0gYWR2YW5jZXIpO1xuICAgICAgICAgICAgICAgIGMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGNtcChhLCBiKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdGEgPSB0eXBlKGEpO1xuICAgICAgICBjb25zdCB0YiA9IHR5cGUoYik7XG4gICAgICAgIGlmICh0YSAhPT0gdGIpIHtcbiAgICAgICAgICAgIGlmICh0YSA9PT0gJ0FycmF5JylcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGlmICh0YiA9PT0gJ0FycmF5JylcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICBpZiAodGEgPT09ICdiaW5hcnknKVxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgaWYgKHRiID09PSAnYmluYXJ5JylcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICBpZiAodGEgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgaWYgKHRiID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICBpZiAodGEgPT09ICdEYXRlJylcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGlmICh0YiAhPT0gJ0RhdGUnKVxuICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0YSkge1xuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYSA+IGIgPyAxIDogYSA8IGIgPyAtMSA6IDA7XG4gICAgICAgICAgICBjYXNlICdiaW5hcnknOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVVaW50OEFycmF5cyhnZXRVaW50OEFycmF5KGEpLCBnZXRVaW50OEFycmF5KGIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZUFycmF5cyhhLCBiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoX2EpIHsgfVxuICAgIHJldHVybiBOYU47XG59XG5mdW5jdGlvbiBjb21wYXJlQXJyYXlzKGEsIGIpIHtcbiAgICBjb25zdCBhbCA9IGEubGVuZ3RoO1xuICAgIGNvbnN0IGJsID0gYi5sZW5ndGg7XG4gICAgY29uc3QgbCA9IGFsIDwgYmwgPyBhbCA6IGJsO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGNtcChhW2ldLCBiW2ldKTtcbiAgICAgICAgaWYgKHJlcyAhPT0gMClcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHJldHVybiBhbCA9PT0gYmwgPyAwIDogYWwgPCBibCA/IC0xIDogMTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVVaW50OEFycmF5cyhhLCBiKSB7XG4gICAgY29uc3QgYWwgPSBhLmxlbmd0aDtcbiAgICBjb25zdCBibCA9IGIubGVuZ3RoO1xuICAgIGNvbnN0IGwgPSBhbCA8IGJsID8gYWwgOiBibDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7ICsraSkge1xuICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSlcbiAgICAgICAgICAgIHJldHVybiBhW2ldIDwgYltpXSA/IC0xIDogMTtcbiAgICB9XG4gICAgcmV0dXJuIGFsID09PSBibCA/IDAgOiBhbCA8IGJsID8gLTEgOiAxO1xufVxuZnVuY3Rpb24gdHlwZSh4KSB7XG4gICAgY29uc3QgdCA9IHR5cGVvZiB4O1xuICAgIGlmICh0ICE9PSAnb2JqZWN0JylcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh4KSlcbiAgICAgICAgcmV0dXJuICdiaW5hcnknO1xuICAgIGNvbnN0IHRzVGFnID0gdG9TdHJpbmdUYWcoeCk7XG4gICAgcmV0dXJuIHRzVGFnID09PSAnQXJyYXlCdWZmZXInID8gJ2JpbmFyeScgOiB0c1RhZztcbn1cbmZ1bmN0aW9uIGdldFVpbnQ4QXJyYXkoYSkge1xuICAgIGlmIChhIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhhKSlcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGEuYnVmZmVyLCBhLmJ5dGVPZmZzZXQsIGEuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGEpO1xufVxuXG5jbGFzcyBDb2xsZWN0aW9uIHtcbiAgICBfcmVhZChmbiwgY2IpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgcmV0dXJuIGN0eC5lcnJvciA/XG4gICAgICAgICAgICBjdHgudGFibGUuX3RyYW5zKG51bGwsIHJlamVjdGlvbi5iaW5kKG51bGwsIGN0eC5lcnJvcikpIDpcbiAgICAgICAgICAgIGN0eC50YWJsZS5fdHJhbnMoJ3JlYWRvbmx5JywgZm4pLnRoZW4oY2IpO1xuICAgIH1cbiAgICBfd3JpdGUoZm4pIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgcmV0dXJuIGN0eC5lcnJvciA/XG4gICAgICAgICAgICBjdHgudGFibGUuX3RyYW5zKG51bGwsIHJlamVjdGlvbi5iaW5kKG51bGwsIGN0eC5lcnJvcikpIDpcbiAgICAgICAgICAgIGN0eC50YWJsZS5fdHJhbnMoJ3JlYWR3cml0ZScsIGZuLCBcImxvY2tlZFwiKTtcbiAgICB9XG4gICAgX2FkZEFsZ29yaXRobShmbikge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICBjdHguYWxnb3JpdGhtID0gY29tYmluZShjdHguYWxnb3JpdGhtLCBmbik7XG4gICAgfVxuICAgIF9pdGVyYXRlKGZuLCBjb3JlVHJhbnMpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXIodGhpcy5fY3R4LCBmbiwgY29yZVRyYW5zLCB0aGlzLl9jdHgudGFibGUuY29yZSk7XG4gICAgfVxuICAgIGNsb25lKHByb3BzKSB7XG4gICAgICAgIHZhciBydiA9IE9iamVjdC5jcmVhdGUodGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUpLCBjdHggPSBPYmplY3QuY3JlYXRlKHRoaXMuX2N0eCk7XG4gICAgICAgIGlmIChwcm9wcylcbiAgICAgICAgICAgIGV4dGVuZChjdHgsIHByb3BzKTtcbiAgICAgICAgcnYuX2N0eCA9IGN0eDtcbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgIH1cbiAgICByYXcoKSB7XG4gICAgICAgIHRoaXMuX2N0eC52YWx1ZU1hcHBlciA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBlYWNoKGZuKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkKHRyYW5zID0+IGl0ZXIoY3R4LCBmbiwgdHJhbnMsIGN0eC50YWJsZS5jb3JlKSk7XG4gICAgfVxuICAgIGNvdW50KGNiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkKHRyYW5zID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgICAgIGNvbnN0IGNvcmVUYWJsZSA9IGN0eC50YWJsZS5jb3JlO1xuICAgICAgICAgICAgaWYgKGlzUGxhaW5LZXlSYW5nZShjdHgsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvcmVUYWJsZS5jb3VudCh7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGdldEluZGV4T3JTdG9yZShjdHgsIGNvcmVUYWJsZS5zY2hlbWEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IGN0eC5yYW5nZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkudGhlbihjb3VudCA9PiBNYXRoLm1pbihjb3VudCwgY3R4LmxpbWl0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyKGN0eCwgKCkgPT4geyArK2NvdW50OyByZXR1cm4gZmFsc2U7IH0sIHRyYW5zLCBjb3JlVGFibGUpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IGNvdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkudGhlbihjYik7XG4gICAgfVxuICAgIHNvcnRCeShrZXlQYXRoLCBjYikge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IGtleVBhdGguc3BsaXQoJy4nKS5yZXZlcnNlKCksIGxhc3RQYXJ0ID0gcGFydHNbMF0sIGxhc3RJbmRleCA9IHBhcnRzLmxlbmd0aCAtIDE7XG4gICAgICAgIGZ1bmN0aW9uIGdldHZhbChvYmosIGkpIHtcbiAgICAgICAgICAgIGlmIChpKVxuICAgICAgICAgICAgICAgIHJldHVybiBnZXR2YWwob2JqW3BhcnRzW2ldXSwgaSAtIDEpO1xuICAgICAgICAgICAgcmV0dXJuIG9ialtsYXN0UGFydF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9yZGVyID0gdGhpcy5fY3R4LmRpciA9PT0gXCJuZXh0XCIgPyAxIDogLTE7XG4gICAgICAgIGZ1bmN0aW9uIHNvcnRlcihhLCBiKSB7XG4gICAgICAgICAgICB2YXIgYVZhbCA9IGdldHZhbChhLCBsYXN0SW5kZXgpLCBiVmFsID0gZ2V0dmFsKGIsIGxhc3RJbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gYVZhbCA8IGJWYWwgPyAtb3JkZXIgOiBhVmFsID4gYlZhbCA/IG9yZGVyIDogMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50b0FycmF5KGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5zb3J0KHNvcnRlcik7XG4gICAgICAgIH0pLnRoZW4oY2IpO1xuICAgIH1cbiAgICB0b0FycmF5KGNiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkKHRyYW5zID0+IHtcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgICAgICBpZiAoY3R4LmRpciA9PT0gJ25leHQnICYmIGlzUGxhaW5LZXlSYW5nZShjdHgsIHRydWUpICYmIGN0eC5saW1pdCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlTWFwcGVyIH0gPSBjdHg7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBnZXRJbmRleE9yU3RvcmUoY3R4LCBjdHgudGFibGUuY29yZS5zY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjdHgudGFibGUuY29yZS5xdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zLFxuICAgICAgICAgICAgICAgICAgICBsaW1pdDogY3R4LmxpbWl0LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBjdHgucmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLnRoZW4oKHsgcmVzdWx0IH0pID0+IHZhbHVlTWFwcGVyID8gcmVzdWx0Lm1hcCh2YWx1ZU1hcHBlcikgOiByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IFtdO1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyKGN0eCwgaXRlbSA9PiBhLnB1c2goaXRlbSksIHRyYW5zLCBjdHgudGFibGUuY29yZSkudGhlbigoKSA9PiBhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgY2IpO1xuICAgIH1cbiAgICBvZmZzZXQob2Zmc2V0KSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgIGlmIChvZmZzZXQgPD0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBjdHgub2Zmc2V0ICs9IG9mZnNldDtcbiAgICAgICAgaWYgKGlzUGxhaW5LZXlSYW5nZShjdHgpKSB7XG4gICAgICAgICAgICBhZGRSZXBsYXlGaWx0ZXIoY3R4LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldExlZnQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChjdXJzb3IsIGFkdmFuY2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldExlZnQgPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldExlZnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC0tb2Zmc2V0TGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5hZHZhbmNlKG9mZnNldExlZnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0TGVmdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWRkUmVwbGF5RmlsdGVyKGN0eCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRMZWZ0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiAoLS1vZmZzZXRMZWZ0IDwgMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbGltaXQobnVtUm93cykge1xuICAgICAgICB0aGlzLl9jdHgubGltaXQgPSBNYXRoLm1pbih0aGlzLl9jdHgubGltaXQsIG51bVJvd3MpO1xuICAgICAgICBhZGRSZXBsYXlGaWx0ZXIodGhpcy5fY3R4LCAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgcm93c0xlZnQgPSBudW1Sb3dzO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjdXJzb3IsIGFkdmFuY2UsIHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoLS1yb3dzTGVmdCA8PSAwKVxuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByb3dzTGVmdCA+PSAwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB1bnRpbChmaWx0ZXJGdW5jdGlvbiwgYkluY2x1ZGVTdG9wRW50cnkpIHtcbiAgICAgICAgYWRkRmlsdGVyKHRoaXMuX2N0eCwgZnVuY3Rpb24gKGN1cnNvciwgYWR2YW5jZSwgcmVzb2x2ZSkge1xuICAgICAgICAgICAgaWYgKGZpbHRlckZ1bmN0aW9uKGN1cnNvci52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBhZHZhbmNlKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBiSW5jbHVkZVN0b3BFbnRyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZpcnN0KGNiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbWl0KDEpLnRvQXJyYXkoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGFbMF07IH0pLnRoZW4oY2IpO1xuICAgIH1cbiAgICBsYXN0KGNiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKS5maXJzdChjYik7XG4gICAgfVxuICAgIGZpbHRlcihmaWx0ZXJGdW5jdGlvbikge1xuICAgICAgICBhZGRGaWx0ZXIodGhpcy5fY3R4LCBmdW5jdGlvbiAoY3Vyc29yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyRnVuY3Rpb24oY3Vyc29yLnZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFkZE1hdGNoRmlsdGVyKHRoaXMuX2N0eCwgZmlsdGVyRnVuY3Rpb24pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYW5kKGZpbHRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZmlsdGVyKTtcbiAgICB9XG4gICAgb3IoaW5kZXhOYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5kYi5XaGVyZUNsYXVzZSh0aGlzLl9jdHgudGFibGUsIGluZGV4TmFtZSwgdGhpcyk7XG4gICAgfVxuICAgIHJldmVyc2UoKSB7XG4gICAgICAgIHRoaXMuX2N0eC5kaXIgPSAodGhpcy5fY3R4LmRpciA9PT0gXCJwcmV2XCIgPyBcIm5leHRcIiA6IFwicHJldlwiKTtcbiAgICAgICAgaWYgKHRoaXMuX29uZGlyZWN0aW9uY2hhbmdlKVxuICAgICAgICAgICAgdGhpcy5fb25kaXJlY3Rpb25jaGFuZ2UodGhpcy5fY3R4LmRpcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZXNjKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCk7XG4gICAgfVxuICAgIGVhY2hLZXkoY2IpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgICAgY3R4LmtleXNPbmx5ID0gIWN0eC5pc01hdGNoO1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICh2YWwsIGN1cnNvcikgeyBjYihjdXJzb3Iua2V5LCBjdXJzb3IpOyB9KTtcbiAgICB9XG4gICAgZWFjaFVuaXF1ZUtleShjYikge1xuICAgICAgICB0aGlzLl9jdHgudW5pcXVlID0gXCJ1bmlxdWVcIjtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaEtleShjYik7XG4gICAgfVxuICAgIGVhY2hQcmltYXJ5S2V5KGNiKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgIGN0eC5rZXlzT25seSA9ICFjdHguaXNNYXRjaDtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAodmFsLCBjdXJzb3IpIHsgY2IoY3Vyc29yLnByaW1hcnlLZXksIGN1cnNvcik7IH0pO1xuICAgIH1cbiAgICBrZXlzKGNiKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgIGN0eC5rZXlzT25seSA9ICFjdHguaXNNYXRjaDtcbiAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaXRlbSwgY3Vyc29yKSB7XG4gICAgICAgICAgICBhLnB1c2goY3Vyc29yLmtleSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH0pLnRoZW4oY2IpO1xuICAgIH1cbiAgICBwcmltYXJ5S2V5cyhjYikge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICBpZiAoY3R4LmRpciA9PT0gJ25leHQnICYmIGlzUGxhaW5LZXlSYW5nZShjdHgsIHRydWUpICYmIGN0eC5saW1pdCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkKHRyYW5zID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleE9yU3RvcmUoY3R4LCBjdHgudGFibGUuY29yZS5zY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjdHgudGFibGUuY29yZS5xdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBsaW1pdDogY3R4LmxpbWl0LFxuICAgICAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogY3R4LnJhbmdlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLnRoZW4oKHsgcmVzdWx0IH0pID0+IHJlc3VsdCkudGhlbihjYik7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmtleXNPbmx5ID0gIWN0eC5pc01hdGNoO1xuICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChpdGVtLCBjdXJzb3IpIHtcbiAgICAgICAgICAgIGEucHVzaChjdXJzb3IucHJpbWFyeUtleSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH0pLnRoZW4oY2IpO1xuICAgIH1cbiAgICB1bmlxdWVLZXlzKGNiKSB7XG4gICAgICAgIHRoaXMuX2N0eC51bmlxdWUgPSBcInVuaXF1ZVwiO1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlzKGNiKTtcbiAgICB9XG4gICAgZmlyc3RLZXkoY2IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGltaXQoMSkua2V5cyhmdW5jdGlvbiAoYSkgeyByZXR1cm4gYVswXTsgfSkudGhlbihjYik7XG4gICAgfVxuICAgIGxhc3RLZXkoY2IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLmZpcnN0S2V5KGNiKTtcbiAgICB9XG4gICAgZGlzdGluY3QoKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHgsIGlkeCA9IGN0eC5pbmRleCAmJiBjdHgudGFibGUuc2NoZW1hLmlkeEJ5TmFtZVtjdHguaW5kZXhdO1xuICAgICAgICBpZiAoIWlkeCB8fCAhaWR4Lm11bHRpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHZhciBzZXQgPSB7fTtcbiAgICAgICAgYWRkRmlsdGVyKHRoaXMuX2N0eCwgZnVuY3Rpb24gKGN1cnNvcikge1xuICAgICAgICAgICAgdmFyIHN0cktleSA9IGN1cnNvci5wcmltYXJ5S2V5LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB2YXIgZm91bmQgPSBoYXNPd24oc2V0LCBzdHJLZXkpO1xuICAgICAgICAgICAgc2V0W3N0cktleV0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuICFmb3VuZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBtb2RpZnkoY2hhbmdlcykge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGUodHJhbnMgPT4ge1xuICAgICAgICAgICAgdmFyIG1vZGlmeWVyO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFuZ2VzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgbW9kaWZ5ZXIgPSBjaGFuZ2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleVBhdGhzID0ga2V5cyhjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB2YXIgbnVtS2V5cyA9IGtleVBhdGhzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBtb2RpZnllciA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbnl0aGluZ01vZGlmaWVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtS2V5czsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5UGF0aCA9IGtleVBhdGhzW2ldLCB2YWwgPSBjaGFuZ2VzW2tleVBhdGhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdldEJ5S2V5UGF0aChpdGVtLCBrZXlQYXRoKSAhPT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKGl0ZW0sIGtleVBhdGgsIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW55dGhpbmdNb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFueXRoaW5nTW9kaWZpZWQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvcmVUYWJsZSA9IGN0eC50YWJsZS5jb3JlO1xuICAgICAgICAgICAgY29uc3QgeyBvdXRib3VuZCwgZXh0cmFjdEtleSB9ID0gY29yZVRhYmxlLnNjaGVtYS5wcmltYXJ5S2V5O1xuICAgICAgICAgICAgY29uc3QgbGltaXQgPSB0aGlzLmRiLl9vcHRpb25zLm1vZGlmeUNodW5rU2l6ZSB8fCAyMDA7XG4gICAgICAgICAgICBjb25zdCB0b3RhbEZhaWx1cmVzID0gW107XG4gICAgICAgICAgICBsZXQgc3VjY2Vzc0NvdW50ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGZhaWxlZEtleXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGFwcGx5TXV0YXRlUmVzdWx0ID0gKGV4cGVjdGVkQ291bnQsIHJlcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZmFpbHVyZXMsIG51bUZhaWx1cmVzIH0gPSByZXM7XG4gICAgICAgICAgICAgICAgc3VjY2Vzc0NvdW50ICs9IGV4cGVjdGVkQ291bnQgLSBudW1GYWlsdXJlcztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3Mgb2Yga2V5cyhmYWlsdXJlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdG90YWxGYWlsdXJlcy5wdXNoKGZhaWx1cmVzW3Bvc10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnByaW1hcnlLZXlzKCkudGhlbihrZXlzID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q2h1bmsgPSAob2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gTWF0aC5taW4obGltaXQsIGtleXMubGVuZ3RoIC0gb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcmVUYWJsZS5nZXRNYW55KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5czoga2V5cy5zbGljZShvZmZzZXQsIG9mZnNldCArIGNvdW50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlOiBcImltbXV0YWJsZVwiXG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4odmFsdWVzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFkZFZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHV0VmFsdWVzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwdXRLZXlzID0gb3V0Ym91bmQgPyBbXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWxldGVLZXlzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnVmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3R4ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZGVlcENsb25lKG9yaWdWYWx1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1LZXk6IGtleXNbb2Zmc2V0ICsgaV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RpZnllci5jYWxsKGN0eCwgY3R4LnZhbHVlLCBjdHgpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3R4LnZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUtleXMucHVzaChrZXlzW29mZnNldCArIGldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghb3V0Ym91bmQgJiYgY21wKGV4dHJhY3RLZXkob3JpZ1ZhbHVlKSwgZXh0cmFjdEtleShjdHgudmFsdWUpKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlS2V5cy5wdXNoKGtleXNbb2Zmc2V0ICsgaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkVmFsdWVzLnB1c2goY3R4LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1dFZhbHVlcy5wdXNoKGN0eC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0Ym91bmQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHV0S2V5cy5wdXNoKGtleXNbb2Zmc2V0ICsgaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3JpdGVyaWEgPSBpc1BsYWluS2V5UmFuZ2UoY3R4KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW1pdCA9PT0gSW5maW5pdHkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGNoYW5nZXMgIT09ICdmdW5jdGlvbicgfHwgY2hhbmdlcyA9PT0gZGVsZXRlQ2FsbGJhY2spICYmIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogY3R4LmluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBjdHgucmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGFkZFZhbHVlcy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZVRhYmxlLm11dGF0ZSh7IHRyYW5zLCB0eXBlOiAnYWRkJywgdmFsdWVzOiBhZGRWYWx1ZXMgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4ocmVzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcG9zIGluIHJlcy5mYWlsdXJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlS2V5cy5zcGxpY2UocGFyc2VJbnQocG9zKSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlNdXRhdGVSZXN1bHQoYWRkVmFsdWVzLmxlbmd0aCwgcmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkudGhlbigoKSA9PiAocHV0VmFsdWVzLmxlbmd0aCA+IDAgfHwgKGNyaXRlcmlhICYmIHR5cGVvZiBjaGFuZ2VzID09PSAnb2JqZWN0JykpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZVRhYmxlLm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncHV0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5czogcHV0S2V5cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBwdXRWYWx1ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyaXRlcmlhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VTcGVjOiB0eXBlb2YgY2hhbmdlcyAhPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgY2hhbmdlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4ocmVzID0+IGFwcGx5TXV0YXRlUmVzdWx0KHB1dFZhbHVlcy5sZW5ndGgsIHJlcykpKS50aGVuKCgpID0+IChkZWxldGVLZXlzLmxlbmd0aCA+IDAgfHwgKGNyaXRlcmlhICYmIGNoYW5nZXMgPT09IGRlbGV0ZUNhbGxiYWNrKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JlVGFibGUubXV0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkZWxldGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzOiBkZWxldGVLZXlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcml0ZXJpYVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4ocmVzID0+IGFwcGx5TXV0YXRlUmVzdWx0KGRlbGV0ZUtleXMubGVuZ3RoLCByZXMpKSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleXMubGVuZ3RoID4gb2Zmc2V0ICsgY291bnQgJiYgbmV4dENodW5rKG9mZnNldCArIGxpbWl0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0Q2h1bmsoMCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3RhbEZhaWx1cmVzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTW9kaWZ5RXJyb3IoXCJFcnJvciBtb2RpZnlpbmcgb25lIG9yIG1vcmUgb2JqZWN0c1wiLCB0b3RhbEZhaWx1cmVzLCBzdWNjZXNzQ291bnQsIGZhaWxlZEtleXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlbGV0ZSgpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eCwgcmFuZ2UgPSBjdHgucmFuZ2U7XG4gICAgICAgIGlmIChpc1BsYWluS2V5UmFuZ2UoY3R4KSAmJlxuICAgICAgICAgICAgKChjdHguaXNQcmltS2V5ICYmICFoYW5nc09uRGVsZXRlTGFyZ2VLZXlSYW5nZSkgfHwgcmFuZ2UudHlwZSA9PT0gMyApKVxuICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlKHRyYW5zID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHByaW1hcnlLZXkgfSA9IGN0eC50YWJsZS5jb3JlLnNjaGVtYTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3JlUmFuZ2UgPSByYW5nZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4LnRhYmxlLmNvcmUuY291bnQoeyB0cmFucywgcXVlcnk6IHsgaW5kZXg6IHByaW1hcnlLZXksIHJhbmdlOiBjb3JlUmFuZ2UgfSB9KS50aGVuKGNvdW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC50YWJsZS5jb3JlLm11dGF0ZSh7IHRyYW5zLCB0eXBlOiAnZGVsZXRlUmFuZ2UnLCByYW5nZTogY29yZVJhbmdlIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoeyBmYWlsdXJlcywgbGFzdFJlc3VsdCwgcmVzdWx0cywgbnVtRmFpbHVyZXMgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bUZhaWx1cmVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNb2RpZnlFcnJvcihcIkNvdWxkIG5vdCBkZWxldGUgc29tZSB2YWx1ZXNcIiwgT2JqZWN0LmtleXMoZmFpbHVyZXMpLm1hcChwb3MgPT4gZmFpbHVyZXNbcG9zXSksIGNvdW50IC0gbnVtRmFpbHVyZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvdW50IC0gbnVtRmFpbHVyZXM7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubW9kaWZ5KGRlbGV0ZUNhbGxiYWNrKTtcbiAgICB9XG59XG5jb25zdCBkZWxldGVDYWxsYmFjayA9ICh2YWx1ZSwgY3R4KSA9PiBjdHgudmFsdWUgPSBudWxsO1xuXG5mdW5jdGlvbiBjcmVhdGVDb2xsZWN0aW9uQ29uc3RydWN0b3IoZGIpIHtcbiAgICByZXR1cm4gbWFrZUNsYXNzQ29uc3RydWN0b3IoQ29sbGVjdGlvbi5wcm90b3R5cGUsIGZ1bmN0aW9uIENvbGxlY3Rpb24od2hlcmVDbGF1c2UsIGtleVJhbmdlR2VuZXJhdG9yKSB7XG4gICAgICAgIHRoaXMuZGIgPSBkYjtcbiAgICAgICAgbGV0IGtleVJhbmdlID0gQW55UmFuZ2UsIGVycm9yID0gbnVsbDtcbiAgICAgICAgaWYgKGtleVJhbmdlR2VuZXJhdG9yKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBrZXlSYW5nZSA9IGtleVJhbmdlR2VuZXJhdG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICBjb25zdCB3aGVyZUN0eCA9IHdoZXJlQ2xhdXNlLl9jdHg7XG4gICAgICAgIGNvbnN0IHRhYmxlID0gd2hlcmVDdHgudGFibGU7XG4gICAgICAgIGNvbnN0IHJlYWRpbmdIb29rID0gdGFibGUuaG9vay5yZWFkaW5nLmZpcmU7XG4gICAgICAgIHRoaXMuX2N0eCA9IHtcbiAgICAgICAgICAgIHRhYmxlOiB0YWJsZSxcbiAgICAgICAgICAgIGluZGV4OiB3aGVyZUN0eC5pbmRleCxcbiAgICAgICAgICAgIGlzUHJpbUtleTogKCF3aGVyZUN0eC5pbmRleCB8fCAodGFibGUuc2NoZW1hLnByaW1LZXkua2V5UGF0aCAmJiB3aGVyZUN0eC5pbmRleCA9PT0gdGFibGUuc2NoZW1hLnByaW1LZXkubmFtZSkpLFxuICAgICAgICAgICAgcmFuZ2U6IGtleVJhbmdlLFxuICAgICAgICAgICAga2V5c09ubHk6IGZhbHNlLFxuICAgICAgICAgICAgZGlyOiBcIm5leHRcIixcbiAgICAgICAgICAgIHVuaXF1ZTogXCJcIixcbiAgICAgICAgICAgIGFsZ29yaXRobTogbnVsbCxcbiAgICAgICAgICAgIGZpbHRlcjogbnVsbCxcbiAgICAgICAgICAgIHJlcGxheUZpbHRlcjogbnVsbCxcbiAgICAgICAgICAgIGp1c3RMaW1pdDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTWF0Y2g6IG51bGwsXG4gICAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgICBsaW1pdDogSW5maW5pdHksXG4gICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICBvcjogd2hlcmVDdHgub3IsXG4gICAgICAgICAgICB2YWx1ZU1hcHBlcjogcmVhZGluZ0hvb2sgIT09IG1pcnJvciA/IHJlYWRpbmdIb29rIDogbnVsbFxuICAgICAgICB9O1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVDb21wYXJlKGEsIGIpIHtcbiAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPT09IGIgPyAwIDogMTtcbn1cbmZ1bmN0aW9uIHNpbXBsZUNvbXBhcmVSZXZlcnNlKGEsIGIpIHtcbiAgICByZXR1cm4gYSA+IGIgPyAtMSA6IGEgPT09IGIgPyAwIDogMTtcbn1cblxuZnVuY3Rpb24gZmFpbChjb2xsZWN0aW9uT3JXaGVyZUNsYXVzZSwgZXJyLCBUKSB7XG4gICAgdmFyIGNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uT3JXaGVyZUNsYXVzZSBpbnN0YW5jZW9mIFdoZXJlQ2xhdXNlID9cbiAgICAgICAgbmV3IGNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlLkNvbGxlY3Rpb24oY29sbGVjdGlvbk9yV2hlcmVDbGF1c2UpIDpcbiAgICAgICAgY29sbGVjdGlvbk9yV2hlcmVDbGF1c2U7XG4gICAgY29sbGVjdGlvbi5fY3R4LmVycm9yID0gVCA/IG5ldyBUKGVycikgOiBuZXcgVHlwZUVycm9yKGVycik7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG59XG5mdW5jdGlvbiBlbXB0eUNvbGxlY3Rpb24od2hlcmVDbGF1c2UpIHtcbiAgICByZXR1cm4gbmV3IHdoZXJlQ2xhdXNlLkNvbGxlY3Rpb24od2hlcmVDbGF1c2UsICgpID0+IHJhbmdlRXF1YWwoXCJcIikpLmxpbWl0KDApO1xufVxuZnVuY3Rpb24gdXBwZXJGYWN0b3J5KGRpcikge1xuICAgIHJldHVybiBkaXIgPT09IFwibmV4dFwiID9cbiAgICAgICAgKHMpID0+IHMudG9VcHBlckNhc2UoKSA6XG4gICAgICAgIChzKSA9PiBzLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBsb3dlckZhY3RvcnkoZGlyKSB7XG4gICAgcmV0dXJuIGRpciA9PT0gXCJuZXh0XCIgP1xuICAgICAgICAocykgPT4gcy50b0xvd2VyQ2FzZSgpIDpcbiAgICAgICAgKHMpID0+IHMudG9VcHBlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIG5leHRDYXNpbmcoa2V5LCBsb3dlcktleSwgdXBwZXJOZWVkbGUsIGxvd2VyTmVlZGxlLCBjbXAsIGRpcikge1xuICAgIHZhciBsZW5ndGggPSBNYXRoLm1pbihrZXkubGVuZ3RoLCBsb3dlck5lZWRsZS5sZW5ndGgpO1xuICAgIHZhciBsbHAgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBsd3JLZXlDaGFyID0gbG93ZXJLZXlbaV07XG4gICAgICAgIGlmIChsd3JLZXlDaGFyICE9PSBsb3dlck5lZWRsZVtpXSkge1xuICAgICAgICAgICAgaWYgKGNtcChrZXlbaV0sIHVwcGVyTmVlZGxlW2ldKSA8IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleS5zdWJzdHIoMCwgaSkgKyB1cHBlck5lZWRsZVtpXSArIHVwcGVyTmVlZGxlLnN1YnN0cihpICsgMSk7XG4gICAgICAgICAgICBpZiAoY21wKGtleVtpXSwgbG93ZXJOZWVkbGVbaV0pIDwgMClcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5LnN1YnN0cigwLCBpKSArIGxvd2VyTmVlZGxlW2ldICsgdXBwZXJOZWVkbGUuc3Vic3RyKGkgKyAxKTtcbiAgICAgICAgICAgIGlmIChsbHAgPj0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5LnN1YnN0cigwLCBsbHApICsgbG93ZXJLZXlbbGxwXSArIHVwcGVyTmVlZGxlLnN1YnN0cihsbHAgKyAxKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbXAoa2V5W2ldLCBsd3JLZXlDaGFyKSA8IDApXG4gICAgICAgICAgICBsbHAgPSBpO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoIDwgbG93ZXJOZWVkbGUubGVuZ3RoICYmIGRpciA9PT0gXCJuZXh0XCIpXG4gICAgICAgIHJldHVybiBrZXkgKyB1cHBlck5lZWRsZS5zdWJzdHIoa2V5Lmxlbmd0aCk7XG4gICAgaWYgKGxlbmd0aCA8IGtleS5sZW5ndGggJiYgZGlyID09PSBcInByZXZcIilcbiAgICAgICAgcmV0dXJuIGtleS5zdWJzdHIoMCwgdXBwZXJOZWVkbGUubGVuZ3RoKTtcbiAgICByZXR1cm4gKGxscCA8IDAgPyBudWxsIDoga2V5LnN1YnN0cigwLCBsbHApICsgbG93ZXJOZWVkbGVbbGxwXSArIHVwcGVyTmVlZGxlLnN1YnN0cihsbHAgKyAxKSk7XG59XG5mdW5jdGlvbiBhZGRJZ25vcmVDYXNlQWxnb3JpdGhtKHdoZXJlQ2xhdXNlLCBtYXRjaCwgbmVlZGxlcywgc3VmZml4KSB7XG4gICAgdmFyIHVwcGVyLCBsb3dlciwgY29tcGFyZSwgdXBwZXJOZWVkbGVzLCBsb3dlck5lZWRsZXMsIGRpcmVjdGlvbiwgbmV4dEtleVN1ZmZpeCwgbmVlZGxlc0xlbiA9IG5lZWRsZXMubGVuZ3RoO1xuICAgIGlmICghbmVlZGxlcy5ldmVyeShzID0+IHR5cGVvZiBzID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgcmV0dXJuIGZhaWwod2hlcmVDbGF1c2UsIFNUUklOR19FWFBFQ1RFRCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluaXREaXJlY3Rpb24oZGlyKSB7XG4gICAgICAgIHVwcGVyID0gdXBwZXJGYWN0b3J5KGRpcik7XG4gICAgICAgIGxvd2VyID0gbG93ZXJGYWN0b3J5KGRpcik7XG4gICAgICAgIGNvbXBhcmUgPSAoZGlyID09PSBcIm5leHRcIiA/IHNpbXBsZUNvbXBhcmUgOiBzaW1wbGVDb21wYXJlUmV2ZXJzZSk7XG4gICAgICAgIHZhciBuZWVkbGVCb3VuZHMgPSBuZWVkbGVzLm1hcChmdW5jdGlvbiAobmVlZGxlKSB7XG4gICAgICAgICAgICByZXR1cm4geyBsb3dlcjogbG93ZXIobmVlZGxlKSwgdXBwZXI6IHVwcGVyKG5lZWRsZSkgfTtcbiAgICAgICAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmUoYS5sb3dlciwgYi5sb3dlcik7XG4gICAgICAgIH0pO1xuICAgICAgICB1cHBlck5lZWRsZXMgPSBuZWVkbGVCb3VuZHMubWFwKGZ1bmN0aW9uIChuYikgeyByZXR1cm4gbmIudXBwZXI7IH0pO1xuICAgICAgICBsb3dlck5lZWRsZXMgPSBuZWVkbGVCb3VuZHMubWFwKGZ1bmN0aW9uIChuYikgeyByZXR1cm4gbmIubG93ZXI7IH0pO1xuICAgICAgICBkaXJlY3Rpb24gPSBkaXI7XG4gICAgICAgIG5leHRLZXlTdWZmaXggPSAoZGlyID09PSBcIm5leHRcIiA/IFwiXCIgOiBzdWZmaXgpO1xuICAgIH1cbiAgICBpbml0RGlyZWN0aW9uKFwibmV4dFwiKTtcbiAgICB2YXIgYyA9IG5ldyB3aGVyZUNsYXVzZS5Db2xsZWN0aW9uKHdoZXJlQ2xhdXNlLCAoKSA9PiBjcmVhdGVSYW5nZSh1cHBlck5lZWRsZXNbMF0sIGxvd2VyTmVlZGxlc1tuZWVkbGVzTGVuIC0gMV0gKyBzdWZmaXgpKTtcbiAgICBjLl9vbmRpcmVjdGlvbmNoYW5nZSA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICAgICAgaW5pdERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIH07XG4gICAgdmFyIGZpcnN0UG9zc2libGVOZWVkbGUgPSAwO1xuICAgIGMuX2FkZEFsZ29yaXRobShmdW5jdGlvbiAoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSB7XG4gICAgICAgIHZhciBrZXkgPSBjdXJzb3Iua2V5O1xuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBsb3dlcktleSA9IGxvd2VyKGtleSk7XG4gICAgICAgIGlmIChtYXRjaChsb3dlcktleSwgbG93ZXJOZWVkbGVzLCBmaXJzdFBvc3NpYmxlTmVlZGxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbG93ZXN0UG9zc2libGVDYXNpbmcgPSBudWxsO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGZpcnN0UG9zc2libGVOZWVkbGU7IGkgPCBuZWVkbGVzTGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FzaW5nID0gbmV4dENhc2luZyhrZXksIGxvd2VyS2V5LCB1cHBlck5lZWRsZXNbaV0sIGxvd2VyTmVlZGxlc1tpXSwgY29tcGFyZSwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FzaW5nID09PSBudWxsICYmIGxvd2VzdFBvc3NpYmxlQ2FzaW5nID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBmaXJzdFBvc3NpYmxlTmVlZGxlID0gaSArIDE7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobG93ZXN0UG9zc2libGVDYXNpbmcgPT09IG51bGwgfHwgY29tcGFyZShsb3dlc3RQb3NzaWJsZUNhc2luZywgY2FzaW5nKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbG93ZXN0UG9zc2libGVDYXNpbmcgPSBjYXNpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxvd2VzdFBvc3NpYmxlQ2FzaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYWR2YW5jZShmdW5jdGlvbiAoKSB7IGN1cnNvci5jb250aW51ZShsb3dlc3RQb3NzaWJsZUNhc2luZyArIG5leHRLZXlTdWZmaXgpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkdmFuY2UocmVzb2x2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJhbmdlKGxvd2VyLCB1cHBlciwgbG93ZXJPcGVuLCB1cHBlck9wZW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAyICxcbiAgICAgICAgbG93ZXIsXG4gICAgICAgIHVwcGVyLFxuICAgICAgICBsb3dlck9wZW4sXG4gICAgICAgIHVwcGVyT3BlblxuICAgIH07XG59XG5mdW5jdGlvbiByYW5nZUVxdWFsKHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMSAsXG4gICAgICAgIGxvd2VyOiB2YWx1ZSxcbiAgICAgICAgdXBwZXI6IHZhbHVlXG4gICAgfTtcbn1cblxuY2xhc3MgV2hlcmVDbGF1c2Uge1xuICAgIGdldCBDb2xsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3R4LnRhYmxlLmRiLkNvbGxlY3Rpb247XG4gICAgfVxuICAgIGJldHdlZW4obG93ZXIsIHVwcGVyLCBpbmNsdWRlTG93ZXIsIGluY2x1ZGVVcHBlcikge1xuICAgICAgICBpbmNsdWRlTG93ZXIgPSBpbmNsdWRlTG93ZXIgIT09IGZhbHNlO1xuICAgICAgICBpbmNsdWRlVXBwZXIgPSBpbmNsdWRlVXBwZXIgPT09IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoKHRoaXMuX2NtcChsb3dlciwgdXBwZXIpID4gMCkgfHxcbiAgICAgICAgICAgICAgICAodGhpcy5fY21wKGxvd2VyLCB1cHBlcikgPT09IDAgJiYgKGluY2x1ZGVMb3dlciB8fCBpbmNsdWRlVXBwZXIpICYmICEoaW5jbHVkZUxvd2VyICYmIGluY2x1ZGVVcHBlcikpKVxuICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eUNvbGxlY3Rpb24odGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCAoKSA9PiBjcmVhdGVSYW5nZShsb3dlciwgdXBwZXIsICFpbmNsdWRlTG93ZXIsICFpbmNsdWRlVXBwZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVxdWFscyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgKCkgPT4gcmFuZ2VFcXVhbCh2YWx1ZSkpO1xuICAgIH1cbiAgICBhYm92ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgKCkgPT4gY3JlYXRlUmFuZ2UodmFsdWUsIHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH1cbiAgICBhYm92ZU9yRXF1YWwodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsICgpID0+IGNyZWF0ZVJhbmdlKHZhbHVlLCB1bmRlZmluZWQsIGZhbHNlKSk7XG4gICAgfVxuICAgIGJlbG93KHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCAoKSA9PiBjcmVhdGVSYW5nZSh1bmRlZmluZWQsIHZhbHVlLCBmYWxzZSwgdHJ1ZSkpO1xuICAgIH1cbiAgICBiZWxvd09yRXF1YWwodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsICgpID0+IGNyZWF0ZVJhbmdlKHVuZGVmaW5lZCwgdmFsdWUpKTtcbiAgICB9XG4gICAgc3RhcnRzV2l0aChzdHIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgU1RSSU5HX0VYUEVDVEVEKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmV0d2VlbihzdHIsIHN0ciArIG1heFN0cmluZywgdHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHN0YXJ0c1dpdGhJZ25vcmVDYXNlKHN0cikge1xuICAgICAgICBpZiAoc3RyID09PSBcIlwiKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRzV2l0aChzdHIpO1xuICAgICAgICByZXR1cm4gYWRkSWdub3JlQ2FzZUFsZ29yaXRobSh0aGlzLCAoeCwgYSkgPT4geC5pbmRleE9mKGFbMF0pID09PSAwLCBbc3RyXSwgbWF4U3RyaW5nKTtcbiAgICB9XG4gICAgZXF1YWxzSWdub3JlQ2FzZShzdHIpIHtcbiAgICAgICAgcmV0dXJuIGFkZElnbm9yZUNhc2VBbGdvcml0aG0odGhpcywgKHgsIGEpID0+IHggPT09IGFbMF0sIFtzdHJdLCBcIlwiKTtcbiAgICB9XG4gICAgYW55T2ZJZ25vcmVDYXNlKCkge1xuICAgICAgICB2YXIgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAoc2V0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBlbXB0eUNvbGxlY3Rpb24odGhpcyk7XG4gICAgICAgIHJldHVybiBhZGRJZ25vcmVDYXNlQWxnb3JpdGhtKHRoaXMsICh4LCBhKSA9PiBhLmluZGV4T2YoeCkgIT09IC0xLCBzZXQsIFwiXCIpO1xuICAgIH1cbiAgICBzdGFydHNXaXRoQW55T2ZJZ25vcmVDYXNlKCkge1xuICAgICAgICB2YXIgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAoc2V0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBlbXB0eUNvbGxlY3Rpb24odGhpcyk7XG4gICAgICAgIHJldHVybiBhZGRJZ25vcmVDYXNlQWxnb3JpdGhtKHRoaXMsICh4LCBhKSA9PiBhLnNvbWUobiA9PiB4LmluZGV4T2YobikgPT09IDApLCBzZXQsIG1heFN0cmluZyk7XG4gICAgfVxuICAgIGFueU9mKCkge1xuICAgICAgICBjb25zdCBzZXQgPSBnZXRBcnJheU9mLmFwcGx5KE5PX0NIQVJfQVJSQVksIGFyZ3VtZW50cyk7XG4gICAgICAgIGxldCBjb21wYXJlID0gdGhpcy5fY21wO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2V0LnNvcnQoY29tcGFyZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBlbXB0eUNvbGxlY3Rpb24odGhpcyk7XG4gICAgICAgIGNvbnN0IGMgPSBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsICgpID0+IGNyZWF0ZVJhbmdlKHNldFswXSwgc2V0W3NldC5sZW5ndGggLSAxXSkpO1xuICAgICAgICBjLl9vbmRpcmVjdGlvbmNoYW5nZSA9IGRpcmVjdGlvbiA9PiB7XG4gICAgICAgICAgICBjb21wYXJlID0gKGRpcmVjdGlvbiA9PT0gXCJuZXh0XCIgP1xuICAgICAgICAgICAgICAgIHRoaXMuX2FzY2VuZGluZyA6XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVzY2VuZGluZyk7XG4gICAgICAgICAgICBzZXQuc29ydChjb21wYXJlKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBjLl9hZGRBbGdvcml0aG0oKGN1cnNvciwgYWR2YW5jZSwgcmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gY3Vyc29yLmtleTtcbiAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKGtleSwgc2V0W2ldKSA+IDApIHtcbiAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IHNldC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb21wYXJlKGtleSwgc2V0W2ldKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWR2YW5jZSgoKSA9PiB7IGN1cnNvci5jb250aW51ZShzZXRbaV0pOyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgbm90RXF1YWwodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5BbnlSYW5nZShbW21pbktleSwgdmFsdWVdLCBbdmFsdWUsIHRoaXMuZGIuX21heEtleV1dLCB7IGluY2x1ZGVMb3dlcnM6IGZhbHNlLCBpbmNsdWRlVXBwZXJzOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgbm9uZU9mKCkge1xuICAgICAgICBjb25zdCBzZXQgPSBnZXRBcnJheU9mLmFwcGx5KE5PX0NIQVJfQVJSQVksIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChzZXQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZXQuc29ydCh0aGlzLl9hc2NlbmRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmFuZ2VzID0gc2V0LnJlZHVjZSgocmVzLCB2YWwpID0+IHJlcyA/XG4gICAgICAgICAgICByZXMuY29uY2F0KFtbcmVzW3Jlcy5sZW5ndGggLSAxXVsxXSwgdmFsXV0pIDpcbiAgICAgICAgICAgIFtbbWluS2V5LCB2YWxdXSwgbnVsbCk7XG4gICAgICAgIHJhbmdlcy5wdXNoKFtzZXRbc2V0Lmxlbmd0aCAtIDFdLCB0aGlzLmRiLl9tYXhLZXldKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5BbnlSYW5nZShyYW5nZXMsIHsgaW5jbHVkZUxvd2VyczogZmFsc2UsIGluY2x1ZGVVcHBlcnM6IGZhbHNlIH0pO1xuICAgIH1cbiAgICBpbkFueVJhbmdlKHJhbmdlcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjbXAgPSB0aGlzLl9jbXAsIGFzY2VuZGluZyA9IHRoaXMuX2FzY2VuZGluZywgZGVzY2VuZGluZyA9IHRoaXMuX2Rlc2NlbmRpbmcsIG1pbiA9IHRoaXMuX21pbiwgbWF4ID0gdGhpcy5fbWF4O1xuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBlbXB0eUNvbGxlY3Rpb24odGhpcyk7XG4gICAgICAgIGlmICghcmFuZ2VzLmV2ZXJ5KHJhbmdlID0+IHJhbmdlWzBdICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHJhbmdlWzFdICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGFzY2VuZGluZyhyYW5nZVswXSwgcmFuZ2VbMV0pIDw9IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBcIkZpcnN0IGFyZ3VtZW50IHRvIGluQW55UmFuZ2UoKSBtdXN0IGJlIGFuIEFycmF5IG9mIHR3by12YWx1ZSBBcnJheXMgW2xvd2VyLHVwcGVyXSB3aGVyZSB1cHBlciBtdXN0IG5vdCBiZSBsb3dlciB0aGFuIGxvd2VyXCIsIGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmNsdWRlTG93ZXJzID0gIW9wdGlvbnMgfHwgb3B0aW9ucy5pbmNsdWRlTG93ZXJzICE9PSBmYWxzZTtcbiAgICAgICAgY29uc3QgaW5jbHVkZVVwcGVycyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5pbmNsdWRlVXBwZXJzID09PSB0cnVlO1xuICAgICAgICBmdW5jdGlvbiBhZGRSYW5nZShyYW5nZXMsIG5ld1JhbmdlKSB7XG4gICAgICAgICAgICBsZXQgaSA9IDAsIGwgPSByYW5nZXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoY21wKG5ld1JhbmdlWzBdLCByYW5nZVsxXSkgPCAwICYmIGNtcChuZXdSYW5nZVsxXSwgcmFuZ2VbMF0pID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByYW5nZVswXSA9IG1pbihyYW5nZVswXSwgbmV3UmFuZ2VbMF0pO1xuICAgICAgICAgICAgICAgICAgICByYW5nZVsxXSA9IG1heChyYW5nZVsxXSwgbmV3UmFuZ2VbMV0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA9PT0gbClcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChuZXdSYW5nZSk7XG4gICAgICAgICAgICByZXR1cm4gcmFuZ2VzO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzb3J0RGlyZWN0aW9uID0gYXNjZW5kaW5nO1xuICAgICAgICBmdW5jdGlvbiByYW5nZVNvcnRlcihhLCBiKSB7IHJldHVybiBzb3J0RGlyZWN0aW9uKGFbMF0sIGJbMF0pOyB9XG4gICAgICAgIGxldCBzZXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZXQgPSByYW5nZXMucmVkdWNlKGFkZFJhbmdlLCBbXSk7XG4gICAgICAgICAgICBzZXQuc29ydChyYW5nZVNvcnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJhbmdlUG9zID0gMDtcbiAgICAgICAgY29uc3Qga2V5SXNCZXlvbmRDdXJyZW50RW50cnkgPSBpbmNsdWRlVXBwZXJzID9cbiAgICAgICAgICAgIGtleSA9PiBhc2NlbmRpbmcoa2V5LCBzZXRbcmFuZ2VQb3NdWzFdKSA+IDAgOlxuICAgICAgICAgICAga2V5ID0+IGFzY2VuZGluZyhrZXksIHNldFtyYW5nZVBvc11bMV0pID49IDA7XG4gICAgICAgIGNvbnN0IGtleUlzQmVmb3JlQ3VycmVudEVudHJ5ID0gaW5jbHVkZUxvd2VycyA/XG4gICAgICAgICAgICBrZXkgPT4gZGVzY2VuZGluZyhrZXksIHNldFtyYW5nZVBvc11bMF0pID4gMCA6XG4gICAgICAgICAgICBrZXkgPT4gZGVzY2VuZGluZyhrZXksIHNldFtyYW5nZVBvc11bMF0pID49IDA7XG4gICAgICAgIGZ1bmN0aW9uIGtleVdpdGhpbkN1cnJlbnRSYW5nZShrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiAha2V5SXNCZXlvbmRDdXJyZW50RW50cnkoa2V5KSAmJiAha2V5SXNCZWZvcmVDdXJyZW50RW50cnkoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hlY2tLZXkgPSBrZXlJc0JleW9uZEN1cnJlbnRFbnRyeTtcbiAgICAgICAgY29uc3QgYyA9IG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgKCkgPT4gY3JlYXRlUmFuZ2Uoc2V0WzBdWzBdLCBzZXRbc2V0Lmxlbmd0aCAtIDFdWzFdLCAhaW5jbHVkZUxvd2VycywgIWluY2x1ZGVVcHBlcnMpKTtcbiAgICAgICAgYy5fb25kaXJlY3Rpb25jaGFuZ2UgPSBkaXJlY3Rpb24gPT4ge1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAgICAgICBjaGVja0tleSA9IGtleUlzQmV5b25kQ3VycmVudEVudHJ5O1xuICAgICAgICAgICAgICAgIHNvcnREaXJlY3Rpb24gPSBhc2NlbmRpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGVja0tleSA9IGtleUlzQmVmb3JlQ3VycmVudEVudHJ5O1xuICAgICAgICAgICAgICAgIHNvcnREaXJlY3Rpb24gPSBkZXNjZW5kaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0LnNvcnQocmFuZ2VTb3J0ZXIpO1xuICAgICAgICB9O1xuICAgICAgICBjLl9hZGRBbGdvcml0aG0oKGN1cnNvciwgYWR2YW5jZSwgcmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgdmFyIGtleSA9IGN1cnNvci5rZXk7XG4gICAgICAgICAgICB3aGlsZSAoY2hlY2tLZXkoa2V5KSkge1xuICAgICAgICAgICAgICAgICsrcmFuZ2VQb3M7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlUG9zID09PSBzZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5V2l0aGluQ3VycmVudFJhbmdlKGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2NtcChrZXksIHNldFtyYW5nZVBvc11bMV0pID09PSAwIHx8IHRoaXMuX2NtcChrZXksIHNldFtyYW5nZVBvc11bMF0pID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWR2YW5jZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3J0RGlyZWN0aW9uID09PSBhc2NlbmRpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoc2V0W3JhbmdlUG9zXVswXSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZShzZXRbcmFuZ2VQb3NdWzFdKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgc3RhcnRzV2l0aEFueU9mKCkge1xuICAgICAgICBjb25zdCBzZXQgPSBnZXRBcnJheU9mLmFwcGx5KE5PX0NIQVJfQVJSQVksIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICghc2V0LmV2ZXJ5KHMgPT4gdHlwZW9mIHMgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhaWwodGhpcywgXCJzdGFydHNXaXRoQW55T2YoKSBvbmx5IHdvcmtzIHdpdGggc3RyaW5nc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBlbXB0eUNvbGxlY3Rpb24odGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmluQW55UmFuZ2Uoc2V0Lm1hcCgoc3RyKSA9PiBbc3RyLCBzdHIgKyBtYXhTdHJpbmddKSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVXaGVyZUNsYXVzZUNvbnN0cnVjdG9yKGRiKSB7XG4gICAgcmV0dXJuIG1ha2VDbGFzc0NvbnN0cnVjdG9yKFdoZXJlQ2xhdXNlLnByb3RvdHlwZSwgZnVuY3Rpb24gV2hlcmVDbGF1c2UodGFibGUsIGluZGV4LCBvckNvbGxlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5kYiA9IGRiO1xuICAgICAgICB0aGlzLl9jdHggPSB7XG4gICAgICAgICAgICB0YWJsZTogdGFibGUsXG4gICAgICAgICAgICBpbmRleDogaW5kZXggPT09IFwiOmlkXCIgPyBudWxsIDogaW5kZXgsXG4gICAgICAgICAgICBvcjogb3JDb2xsZWN0aW9uXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGluZGV4ZWREQiA9IGRiLl9kZXBzLmluZGV4ZWREQjtcbiAgICAgICAgaWYgKCFpbmRleGVkREIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5NaXNzaW5nQVBJKCk7XG4gICAgICAgIHRoaXMuX2NtcCA9IHRoaXMuX2FzY2VuZGluZyA9IGluZGV4ZWREQi5jbXAuYmluZChpbmRleGVkREIpO1xuICAgICAgICB0aGlzLl9kZXNjZW5kaW5nID0gKGEsIGIpID0+IGluZGV4ZWREQi5jbXAoYiwgYSk7XG4gICAgICAgIHRoaXMuX21heCA9IChhLCBiKSA9PiBpbmRleGVkREIuY21wKGEsIGIpID4gMCA/IGEgOiBiO1xuICAgICAgICB0aGlzLl9taW4gPSAoYSwgYikgPT4gaW5kZXhlZERCLmNtcChhLCBiKSA8IDAgPyBhIDogYjtcbiAgICAgICAgdGhpcy5fSURCS2V5UmFuZ2UgPSBkYi5fZGVwcy5JREJLZXlSYW5nZTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCkge1xuICAgIHJldHVybiB3cmFwKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBwcmV2ZW50RGVmYXVsdChldmVudCk7XG4gICAgICAgIHJlamVjdChldmVudC50YXJnZXQuZXJyb3IpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldmVudCkge1xuICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdClcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn1cblxuY29uc3QgREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUgPSAnc3RvcmFnZW11dGF0ZWQnO1xuY29uc3QgU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FID0gJ3gtc3RvcmFnZW11dGF0ZWQtMSc7XG5jb25zdCBnbG9iYWxFdmVudHMgPSBFdmVudHMobnVsbCwgREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUpO1xuXG5jbGFzcyBUcmFuc2FjdGlvbiB7XG4gICAgX2xvY2soKSB7XG4gICAgICAgIGFzc2VydCghUFNELmdsb2JhbCk7XG4gICAgICAgICsrdGhpcy5fcmVjdWxvY2s7XG4gICAgICAgIGlmICh0aGlzLl9yZWN1bG9jayA9PT0gMSAmJiAhUFNELmdsb2JhbClcbiAgICAgICAgICAgIFBTRC5sb2NrT3duZXJGb3IgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgX3VubG9jaygpIHtcbiAgICAgICAgYXNzZXJ0KCFQU0QuZ2xvYmFsKTtcbiAgICAgICAgaWYgKC0tdGhpcy5fcmVjdWxvY2sgPT09IDApIHtcbiAgICAgICAgICAgIGlmICghUFNELmdsb2JhbClcbiAgICAgICAgICAgICAgICBQU0QubG9ja093bmVyRm9yID0gbnVsbDtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLl9ibG9ja2VkRnVuY3MubGVuZ3RoID4gMCAmJiAhdGhpcy5fbG9ja2VkKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZm5BbmRQU0QgPSB0aGlzLl9ibG9ja2VkRnVuY3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB1c2VQU0QoZm5BbmRQU0RbMV0sIGZuQW5kUFNEWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBfbG9ja2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVjdWxvY2sgJiYgUFNELmxvY2tPd25lckZvciAhPT0gdGhpcztcbiAgICB9XG4gICAgY3JlYXRlKGlkYnRyYW5zKSB7XG4gICAgICAgIGlmICghdGhpcy5tb2RlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGNvbnN0IGlkYmRiID0gdGhpcy5kYi5pZGJkYjtcbiAgICAgICAgY29uc3QgZGJPcGVuRXJyb3IgPSB0aGlzLmRiLl9zdGF0ZS5kYk9wZW5FcnJvcjtcbiAgICAgICAgYXNzZXJ0KCF0aGlzLmlkYnRyYW5zKTtcbiAgICAgICAgaWYgKCFpZGJ0cmFucyAmJiAhaWRiZGIpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZGJPcGVuRXJyb3IgJiYgZGJPcGVuRXJyb3IubmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJEYXRhYmFzZUNsb3NlZEVycm9yXCI6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKGRiT3BlbkVycm9yKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiTWlzc2luZ0FQSUVycm9yXCI6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk1pc3NpbmdBUEkoZGJPcGVuRXJyb3IubWVzc2FnZSwgZGJPcGVuRXJyb3IpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk9wZW5GYWlsZWQoZGJPcGVuRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5UcmFuc2FjdGlvbkluYWN0aXZlKCk7XG4gICAgICAgIGFzc2VydCh0aGlzLl9jb21wbGV0aW9uLl9zdGF0ZSA9PT0gbnVsbCk7XG4gICAgICAgIGlkYnRyYW5zID0gdGhpcy5pZGJ0cmFucyA9IGlkYnRyYW5zIHx8XG4gICAgICAgICAgICAodGhpcy5kYi5jb3JlXG4gICAgICAgICAgICAgICAgPyB0aGlzLmRiLmNvcmUudHJhbnNhY3Rpb24odGhpcy5zdG9yZU5hbWVzLCB0aGlzLm1vZGUsIHsgZHVyYWJpbGl0eTogdGhpcy5jaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHkgfSlcbiAgICAgICAgICAgICAgICA6IGlkYmRiLnRyYW5zYWN0aW9uKHRoaXMuc3RvcmVOYW1lcywgdGhpcy5tb2RlLCB7IGR1cmFiaWxpdHk6IHRoaXMuY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5IH0pKTtcbiAgICAgICAgaWRidHJhbnMub25lcnJvciA9IHdyYXAoZXYgPT4ge1xuICAgICAgICAgICAgcHJldmVudERlZmF1bHQoZXYpO1xuICAgICAgICAgICAgdGhpcy5fcmVqZWN0KGlkYnRyYW5zLmVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlkYnRyYW5zLm9uYWJvcnQgPSB3cmFwKGV2ID0+IHtcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGV2KTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlICYmIHRoaXMuX3JlamVjdChuZXcgZXhjZXB0aW9ucy5BYm9ydChpZGJ0cmFucy5lcnJvcikpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMub24oXCJhYm9ydFwiKS5maXJlKGV2KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlkYnRyYW5zLm9uY29tcGxldGUgPSB3cmFwKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlKCk7XG4gICAgICAgICAgICBpZiAoJ211dGF0ZWRQYXJ0cycgaW4gaWRidHJhbnMpIHtcbiAgICAgICAgICAgICAgICBnbG9iYWxFdmVudHMuc3RvcmFnZW11dGF0ZWQuZmlyZShpZGJ0cmFuc1tcIm11dGF0ZWRQYXJ0c1wiXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgX3Byb21pc2UobW9kZSwgZm4sIGJXcml0ZUxvY2spIHtcbiAgICAgICAgaWYgKG1vZGUgPT09ICdyZWFkd3JpdGUnICYmIHRoaXMubW9kZSAhPT0gJ3JlYWR3cml0ZScpXG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLlJlYWRPbmx5KFwiVHJhbnNhY3Rpb24gaXMgcmVhZG9ubHlcIikpO1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5UcmFuc2FjdGlvbkluYWN0aXZlKCkpO1xuICAgICAgICBpZiAodGhpcy5fbG9ja2VkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ibG9ja2VkRnVuY3MucHVzaChbKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvbWlzZShtb2RlLCBmbiwgYldyaXRlTG9jaykudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9LCBQU0RdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJXcml0ZUxvY2spIHtcbiAgICAgICAgICAgIHJldHVybiBuZXdTY29wZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBuZXcgRGV4aWVQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9jaygpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBydiA9IGZuKHJlc29sdmUsIHJlamVjdCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChydiAmJiBydi50aGVuKVxuICAgICAgICAgICAgICAgICAgICAgICAgcnYudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHAuZmluYWxseSgoKSA9PiB0aGlzLl91bmxvY2soKSk7XG4gICAgICAgICAgICAgICAgcC5fbGliID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHAgPSBuZXcgRGV4aWVQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgcnYgPSBmbihyZXNvbHZlLCByZWplY3QsIHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmIChydiAmJiBydi50aGVuKVxuICAgICAgICAgICAgICAgICAgICBydi50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHAuX2xpYiA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuX3Jvb3QoKSA6IHRoaXM7XG4gICAgfVxuICAgIHdhaXRGb3IocHJvbWlzZUxpa2UpIHtcbiAgICAgICAgdmFyIHJvb3QgPSB0aGlzLl9yb290KCk7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBEZXhpZVByb21pc2UucmVzb2x2ZShwcm9taXNlTGlrZSk7XG4gICAgICAgIGlmIChyb290Ll93YWl0aW5nRm9yKSB7XG4gICAgICAgICAgICByb290Ll93YWl0aW5nRm9yID0gcm9vdC5fd2FpdGluZ0Zvci50aGVuKCgpID0+IHByb21pc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcm9vdC5fd2FpdGluZ0ZvciA9IHByb21pc2U7XG4gICAgICAgICAgICByb290Ll93YWl0aW5nUXVldWUgPSBbXTtcbiAgICAgICAgICAgIHZhciBzdG9yZSA9IHJvb3QuaWRidHJhbnMub2JqZWN0U3RvcmUocm9vdC5zdG9yZU5hbWVzWzBdKTtcbiAgICAgICAgICAgIChmdW5jdGlvbiBzcGluKCkge1xuICAgICAgICAgICAgICAgICsrcm9vdC5fc3BpbkNvdW50O1xuICAgICAgICAgICAgICAgIHdoaWxlIChyb290Ll93YWl0aW5nUXVldWUubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAocm9vdC5fd2FpdGluZ1F1ZXVlLnNoaWZ0KCkpKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJvb3QuX3dhaXRpbmdGb3IpXG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLmdldCgtSW5maW5pdHkpLm9uc3VjY2VzcyA9IHNwaW47XG4gICAgICAgICAgICB9KCkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJyZW50V2FpdFByb21pc2UgPSByb290Ll93YWl0aW5nRm9yO1xuICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBwcm9taXNlLnRoZW4ocmVzID0+IHJvb3QuX3dhaXRpbmdRdWV1ZS5wdXNoKHdyYXAocmVzb2x2ZS5iaW5kKG51bGwsIHJlcykpKSwgZXJyID0+IHJvb3QuX3dhaXRpbmdRdWV1ZS5wdXNoKHdyYXAocmVqZWN0LmJpbmQobnVsbCwgZXJyKSkpKS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocm9vdC5fd2FpdGluZ0ZvciA9PT0gY3VycmVudFdhaXRQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3QuX3dhaXRpbmdGb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWJvcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkYnRyYW5zKVxuICAgICAgICAgICAgICAgIHRoaXMuaWRidHJhbnMuYWJvcnQoKTtcbiAgICAgICAgICAgIHRoaXMuX3JlamVjdChuZXcgZXhjZXB0aW9ucy5BYm9ydCgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0YWJsZSh0YWJsZU5hbWUpIHtcbiAgICAgICAgY29uc3QgbWVtb2l6ZWRUYWJsZXMgPSAodGhpcy5fbWVtb2l6ZWRUYWJsZXMgfHwgKHRoaXMuX21lbW9pemVkVGFibGVzID0ge30pKTtcbiAgICAgICAgaWYgKGhhc093bihtZW1vaXplZFRhYmxlcywgdGFibGVOYW1lKSlcbiAgICAgICAgICAgIHJldHVybiBtZW1vaXplZFRhYmxlc1t0YWJsZU5hbWVdO1xuICAgICAgICBjb25zdCB0YWJsZVNjaGVtYSA9IHRoaXMuc2NoZW1hW3RhYmxlTmFtZV07XG4gICAgICAgIGlmICghdGFibGVTY2hlbWEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk5vdEZvdW5kKFwiVGFibGUgXCIgKyB0YWJsZU5hbWUgKyBcIiBub3QgcGFydCBvZiB0cmFuc2FjdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbkJvdW5kVGFibGUgPSBuZXcgdGhpcy5kYi5UYWJsZSh0YWJsZU5hbWUsIHRhYmxlU2NoZW1hLCB0aGlzKTtcbiAgICAgICAgdHJhbnNhY3Rpb25Cb3VuZFRhYmxlLmNvcmUgPSB0aGlzLmRiLmNvcmUudGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgbWVtb2l6ZWRUYWJsZXNbdGFibGVOYW1lXSA9IHRyYW5zYWN0aW9uQm91bmRUYWJsZTtcbiAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uQm91bmRUYWJsZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zYWN0aW9uQ29uc3RydWN0b3IoZGIpIHtcbiAgICByZXR1cm4gbWFrZUNsYXNzQ29uc3RydWN0b3IoVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBmdW5jdGlvbiBUcmFuc2FjdGlvbihtb2RlLCBzdG9yZU5hbWVzLCBkYnNjaGVtYSwgY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5LCBwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5kYiA9IGRiO1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICB0aGlzLnN0b3JlTmFtZXMgPSBzdG9yZU5hbWVzO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IGRic2NoZW1hO1xuICAgICAgICB0aGlzLmNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eSA9IGNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eTtcbiAgICAgICAgdGhpcy5pZGJ0cmFucyA9IG51bGw7XG4gICAgICAgIHRoaXMub24gPSBFdmVudHModGhpcywgXCJjb21wbGV0ZVwiLCBcImVycm9yXCIsIFwiYWJvcnRcIik7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50IHx8IG51bGw7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcmVjdWxvY2sgPSAwO1xuICAgICAgICB0aGlzLl9ibG9ja2VkRnVuY3MgPSBbXTtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3JlamVjdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3dhaXRpbmdGb3IgPSBudWxsO1xuICAgICAgICB0aGlzLl93YWl0aW5nUXVldWUgPSBudWxsO1xuICAgICAgICB0aGlzLl9zcGluQ291bnQgPSAwO1xuICAgICAgICB0aGlzLl9jb21wbGV0aW9uID0gbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIHRoaXMuX3JlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2NvbXBsZXRpb24udGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5vbi5jb21wbGV0ZS5maXJlKCk7XG4gICAgICAgIH0sIGUgPT4ge1xuICAgICAgICAgICAgdmFyIHdhc0FjdGl2ZSA9IHRoaXMuYWN0aXZlO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMub24uZXJyb3IuZmlyZShlKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID9cbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5fcmVqZWN0KGUpIDpcbiAgICAgICAgICAgICAgICB3YXNBY3RpdmUgJiYgdGhpcy5pZGJ0cmFucyAmJiB0aGlzLmlkYnRyYW5zLmFib3J0KCk7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5kZXhTcGVjKG5hbWUsIGtleVBhdGgsIHVuaXF1ZSwgbXVsdGksIGF1dG8sIGNvbXBvdW5kLCBpc1ByaW1LZXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lLFxuICAgICAgICBrZXlQYXRoLFxuICAgICAgICB1bmlxdWUsXG4gICAgICAgIG11bHRpLFxuICAgICAgICBhdXRvLFxuICAgICAgICBjb21wb3VuZCxcbiAgICAgICAgc3JjOiAodW5pcXVlICYmICFpc1ByaW1LZXkgPyAnJicgOiAnJykgKyAobXVsdGkgPyAnKicgOiAnJykgKyAoYXV0byA/IFwiKytcIiA6IFwiXCIpICsgbmFtZUZyb21LZXlQYXRoKGtleVBhdGgpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG5hbWVGcm9tS2V5UGF0aChrZXlQYXRoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJyA/XG4gICAgICAgIGtleVBhdGggOlxuICAgICAgICBrZXlQYXRoID8gKCdbJyArIFtdLmpvaW4uY2FsbChrZXlQYXRoLCAnKycpICsgJ10nKSA6IFwiXCI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRhYmxlU2NoZW1hKG5hbWUsIHByaW1LZXksIGluZGV4ZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lLFxuICAgICAgICBwcmltS2V5LFxuICAgICAgICBpbmRleGVzLFxuICAgICAgICBtYXBwZWRDbGFzczogbnVsbCxcbiAgICAgICAgaWR4QnlOYW1lOiBhcnJheVRvT2JqZWN0KGluZGV4ZXMsIGluZGV4ID0+IFtpbmRleC5uYW1lLCBpbmRleF0pXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gc2FmYXJpTXVsdGlTdG9yZUZpeChzdG9yZU5hbWVzKSB7XG4gICAgcmV0dXJuIHN0b3JlTmFtZXMubGVuZ3RoID09PSAxID8gc3RvcmVOYW1lc1swXSA6IHN0b3JlTmFtZXM7XG59XG5sZXQgZ2V0TWF4S2V5ID0gKElkYktleVJhbmdlKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgSWRiS2V5UmFuZ2Uub25seShbW11dKTtcbiAgICAgICAgZ2V0TWF4S2V5ID0gKCkgPT4gW1tdXTtcbiAgICAgICAgcmV0dXJuIFtbXV07XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGdldE1heEtleSA9ICgpID0+IG1heFN0cmluZztcbiAgICAgICAgcmV0dXJuIG1heFN0cmluZztcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBnZXRLZXlFeHRyYWN0b3Ioa2V5UGF0aCkge1xuICAgIGlmIChrZXlQYXRoID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBnZXRTaW5nbGVQYXRoS2V5RXh0cmFjdG9yKGtleVBhdGgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9iaiA9PiBnZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRTaW5nbGVQYXRoS2V5RXh0cmFjdG9yKGtleVBhdGgpIHtcbiAgICBjb25zdCBzcGxpdCA9IGtleVBhdGguc3BsaXQoJy4nKTtcbiAgICBpZiAoc3BsaXQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBvYmogPT4gb2JqW2tleVBhdGhdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9iaiA9PiBnZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFycmF5aWZ5KGFycmF5TGlrZSkge1xuICAgIHJldHVybiBbXS5zbGljZS5jYWxsKGFycmF5TGlrZSk7XG59XG5sZXQgX2lkX2NvdW50ZXIgPSAwO1xuZnVuY3Rpb24gZ2V0S2V5UGF0aEFsaWFzKGtleVBhdGgpIHtcbiAgICByZXR1cm4ga2V5UGF0aCA9PSBudWxsID9cbiAgICAgICAgXCI6aWRcIiA6XG4gICAgICAgIHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJyA/XG4gICAgICAgICAgICBrZXlQYXRoIDpcbiAgICAgICAgICAgIGBbJHtrZXlQYXRoLmpvaW4oJysnKX1dYDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURCQ29yZShkYiwgSWRiS2V5UmFuZ2UsIHRtcFRyYW5zKSB7XG4gICAgZnVuY3Rpb24gZXh0cmFjdFNjaGVtYShkYiwgdHJhbnMpIHtcbiAgICAgICAgY29uc3QgdGFibGVzID0gYXJyYXlpZnkoZGIub2JqZWN0U3RvcmVOYW1lcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBkYi5uYW1lLFxuICAgICAgICAgICAgICAgIHRhYmxlczogdGFibGVzLm1hcCh0YWJsZSA9PiB0cmFucy5vYmplY3RTdG9yZSh0YWJsZSkpLm1hcChzdG9yZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsga2V5UGF0aCwgYXV0b0luY3JlbWVudCB9ID0gc3RvcmU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvdW5kID0gaXNBcnJheShrZXlQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3V0Ym91bmQgPSBrZXlQYXRoID09IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4QnlLZXlQYXRoID0ge307XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHN0b3JlLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5S2V5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ByaW1hcnlLZXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0Ym91bmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG91bmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvSW5jcmVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYWN0S2V5OiBnZXRLZXlFeHRyYWN0b3Ioa2V5UGF0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleGVzOiBhcnJheWlmeShzdG9yZS5pbmRleE5hbWVzKS5tYXAoaW5kZXhOYW1lID0+IHN0b3JlLmluZGV4KGluZGV4TmFtZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChpbmRleCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBuYW1lLCB1bmlxdWUsIG11bHRpRW50cnksIGtleVBhdGggfSA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvdW5kID0gaXNBcnJheShrZXlQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvdW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpRW50cnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhY3RLZXk6IGdldEtleUV4dHJhY3RvcihrZXlQYXRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhCeUtleVBhdGhbZ2V0S2V5UGF0aEFsaWFzKGtleVBhdGgpXSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRJbmRleEJ5S2V5UGF0aDogKGtleVBhdGgpID0+IGluZGV4QnlLZXlQYXRoW2dldEtleVBhdGhBbGlhcyhrZXlQYXRoKV1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhCeUtleVBhdGhbXCI6aWRcIl0gPSByZXN1bHQucHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleVBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhCeUtleVBhdGhbZ2V0S2V5UGF0aEFsaWFzKGtleVBhdGgpXSA9IHJlc3VsdC5wcmltYXJ5S2V5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYXNHZXRBbGw6IHRhYmxlcy5sZW5ndGggPiAwICYmICgnZ2V0QWxsJyBpbiB0cmFucy5vYmplY3RTdG9yZSh0YWJsZXNbMF0pKSAmJlxuICAgICAgICAgICAgICAgICEodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL1NhZmFyaS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJlxuICAgICAgICAgICAgICAgICAgICAhLyhDaHJvbWVcXC98RWRnZVxcLykvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcbiAgICAgICAgICAgICAgICAgICAgW10uY29uY2F0KG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1NhZmFyaVxcLyhcXGQqKS8pKVsxXSA8IDYwNClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZUlEQktleVJhbmdlKHJhbmdlKSB7XG4gICAgICAgIGlmIChyYW5nZS50eXBlID09PSAzIClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAocmFuZ2UudHlwZSA9PT0gNCApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29udmVydCBuZXZlciB0eXBlIHRvIElEQktleVJhbmdlXCIpO1xuICAgICAgICBjb25zdCB7IGxvd2VyLCB1cHBlciwgbG93ZXJPcGVuLCB1cHBlck9wZW4gfSA9IHJhbmdlO1xuICAgICAgICBjb25zdCBpZGJSYW5nZSA9IGxvd2VyID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgdXBwZXIgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgbnVsbCA6XG4gICAgICAgICAgICAgICAgSWRiS2V5UmFuZ2UudXBwZXJCb3VuZCh1cHBlciwgISF1cHBlck9wZW4pIDpcbiAgICAgICAgICAgIHVwcGVyID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIElkYktleVJhbmdlLmxvd2VyQm91bmQobG93ZXIsICEhbG93ZXJPcGVuKSA6XG4gICAgICAgICAgICAgICAgSWRiS2V5UmFuZ2UuYm91bmQobG93ZXIsIHVwcGVyLCAhIWxvd2VyT3BlbiwgISF1cHBlck9wZW4pO1xuICAgICAgICByZXR1cm4gaWRiUmFuZ2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZURiQ29yZVRhYmxlKHRhYmxlU2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRhYmxlU2NoZW1hLm5hbWU7XG4gICAgICAgIGZ1bmN0aW9uIG11dGF0ZSh7IHRyYW5zLCB0eXBlLCBrZXlzLCB2YWx1ZXMsIHJhbmdlIH0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHdyYXAocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RvcmUgPSB0cmFucy5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dGJvdW5kID0gc3RvcmUua2V5UGF0aCA9PSBudWxsO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQWRkT3JQdXQgPSB0eXBlID09PSBcInB1dFwiIHx8IHR5cGUgPT09IFwiYWRkXCI7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0FkZE9yUHV0ICYmIHR5cGUgIT09ICdkZWxldGUnICYmIHR5cGUgIT09ICdkZWxldGVSYW5nZScpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgb3BlcmF0aW9uIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBsZW5ndGggfSA9IGtleXMgfHwgdmFsdWVzIHx8IHsgbGVuZ3RoOiAxIH07XG4gICAgICAgICAgICAgICAgaWYgKGtleXMgJiYgdmFsdWVzICYmIGtleXMubGVuZ3RoICE9PSB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdpdmVuIGtleXMgYXJyYXkgbXVzdCBoYXZlIHNhbWUgbGVuZ3RoIGFzIGdpdmVuIHZhbHVlcyBhcnJheS5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHsgbnVtRmFpbHVyZXM6IDAsIGZhaWx1cmVzOiB7fSwgcmVzdWx0czogW10sIGxhc3RSZXN1bHQ6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICAgICAgICBsZXQgcmVxO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXMgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBmYWlsdXJlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCBudW1GYWlsdXJlcyA9IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JIYW5kbGVyID0gZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICArK251bUZhaWx1cmVzO1xuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChldmVudCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2RlbGV0ZVJhbmdlJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2UudHlwZSA9PT0gNCApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7IG51bUZhaWx1cmVzLCBmYWlsdXJlcywgcmVzdWx0czogW10sIGxhc3RSZXN1bHQ6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlLnR5cGUgPT09IDMgKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxcy5wdXNoKHJlcSA9IHN0b3JlLmNsZWFyKCkpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXFzLnB1c2gocmVxID0gc3RvcmUuZGVsZXRlKG1ha2VJREJLZXlSYW5nZShyYW5nZSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFthcmdzMSwgYXJnczJdID0gaXNBZGRPclB1dCA/XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRib3VuZCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3ZhbHVlcywga2V5c10gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt2YWx1ZXMsIG51bGxdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIFtrZXlzLCBudWxsXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQWRkT3JQdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXFzLnB1c2gocmVxID0gKGFyZ3MyICYmIGFyZ3MyW2ldICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZVt0eXBlXShhcmdzMVtpXSwgYXJnczJbaV0pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVbdHlwZV0oYXJnczFbaV0pKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBlcnJvckhhbmRsZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxcy5wdXNoKHJlcSA9IHN0b3JlW3R5cGVdKGFyZ3MxW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBlcnJvckhhbmRsZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZG9uZSA9IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdFJlc3VsdCA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIHJlcXMuZm9yRWFjaCgocmVxLCBpKSA9PiByZXEuZXJyb3IgIT0gbnVsbCAmJiAoZmFpbHVyZXNbaV0gPSByZXEuZXJyb3IpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1GYWlsdXJlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWx1cmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0czogdHlwZSA9PT0gXCJkZWxldGVcIiA/IGtleXMgOiByZXFzLm1hcChyZXEgPT4gcmVxLnJlc3VsdCksXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0UmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ySGFuZGxlcihldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGRvbmU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvcGVuQ3Vyc29yKHsgdHJhbnMsIHZhbHVlcywgcXVlcnksIHJldmVyc2UsIHVuaXF1ZSB9KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUgPSB3cmFwKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaW5kZXgsIHJhbmdlIH0gPSBxdWVyeTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9yZSA9IHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlID0gaW5kZXguaXNQcmltYXJ5S2V5ID9cbiAgICAgICAgICAgICAgICAgICAgc3RvcmUgOlxuICAgICAgICAgICAgICAgICAgICBzdG9yZS5pbmRleChpbmRleC5uYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSByZXZlcnNlID9cbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlID9cbiAgICAgICAgICAgICAgICAgICAgICAgIFwicHJldnVuaXF1ZVwiIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicHJldlwiIDpcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlID9cbiAgICAgICAgICAgICAgICAgICAgICAgIFwibmV4dHVuaXF1ZVwiIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibmV4dFwiO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcSA9IHZhbHVlcyB8fCAhKCdvcGVuS2V5Q3Vyc29yJyBpbiBzb3VyY2UpID9cbiAgICAgICAgICAgICAgICAgICAgc291cmNlLm9wZW5DdXJzb3IobWFrZUlEQktleVJhbmdlKHJhbmdlKSwgZGlyZWN0aW9uKSA6XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZS5vcGVuS2V5Q3Vyc29yKG1ha2VJREJLZXlSYW5nZShyYW5nZSksIGRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gd3JhcChldiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnNvciA9IHJlcS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5fX19pZCA9ICsrX2lkX2NvdW50ZXI7XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IF9jdXJzb3JDb250aW51ZSA9IGN1cnNvci5jb250aW51ZS5iaW5kKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBfY3Vyc29yQ29udGludWVQcmltYXJ5S2V5ID0gY3Vyc29yLmNvbnRpbnVlUHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jdXJzb3JDb250aW51ZVByaW1hcnlLZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBfY3Vyc29yQ29udGludWVQcmltYXJ5S2V5ID0gX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleS5iaW5kKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IF9jdXJzb3JBZHZhbmNlID0gY3Vyc29yLmFkdmFuY2UuYmluZChjdXJzb3IpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb1Rocm93Q3Vyc29ySXNOb3RTdGFydGVkID0gKCkgPT4geyB0aHJvdyBuZXcgRXJyb3IoXCJDdXJzb3Igbm90IHN0YXJ0ZWRcIik7IH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvVGhyb3dDdXJzb3JJc1N0b3BwZWQgPSAoKSA9PiB7IHRocm93IG5ldyBFcnJvcihcIkN1cnNvciBub3Qgc3RvcHBlZFwiKTsgfTtcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnRyYW5zID0gdHJhbnM7XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5zdG9wID0gY3Vyc29yLmNvbnRpbnVlID0gY3Vyc29yLmNvbnRpbnVlUHJpbWFyeUtleSA9IGN1cnNvci5hZHZhbmNlID0gZG9UaHJvd0N1cnNvcklzTm90U3RhcnRlZDtcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmZhaWwgPSB3cmFwKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGdvdE9uZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydCgoKSA9PiBnb3RPbmUtLSA/IHRoaXMuY29udGludWUoKSA6IHRoaXMuc3RvcCgpKS50aGVuKCgpID0+IHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjdXJzb3Iuc3RhcnQgPSAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZXJhdGlvblByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZUl0ZXJhdGlvbiwgcmVqZWN0SXRlcmF0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUl0ZXJhdGlvbiA9IHdyYXAocmVzb2x2ZUl0ZXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0SXRlcmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuZmFpbCA9IHJlamVjdEl0ZXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3Iuc3RvcCA9IHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnN0b3AgPSBjdXJzb3IuY29udGludWUgPSBjdXJzb3IuY29udGludWVQcmltYXJ5S2V5ID0gY3Vyc29yLmFkdmFuY2UgPSBkb1Rocm93Q3Vyc29ySXNTdG9wcGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlSXRlcmF0aW9uKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBndWFyZGVkQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcS5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmZhaWwoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3Iuc3RhcnQgPSAoKSA9PiB7IHRocm93IG5ldyBFcnJvcihcIkN1cnNvciBiZWhpbmQgbGFzdCBlbnRyeVwiKTsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHdyYXAoZXYgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBndWFyZGVkQ2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3VhcmRlZENhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSA9IF9jdXJzb3JDb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZVByaW1hcnlLZXkgPSBfY3Vyc29yQ29udGludWVQcmltYXJ5S2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmFkdmFuY2UgPSBfY3Vyc29yQWR2YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGd1YXJkZWRDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdGlvblByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcXVlcnkoaGFzR2V0QWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlID0gd3JhcChyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB0cmFucywgdmFsdWVzLCBsaW1pdCwgcXVlcnkgfSA9IHJlcXVlc3Q7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vbkluZmluaXRMaW1pdCA9IGxpbWl0ID09PSBJbmZpbml0eSA/IHVuZGVmaW5lZCA6IGxpbWl0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGluZGV4LCByYW5nZSB9ID0gcXVlcnk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc291cmNlID0gaW5kZXguaXNQcmltYXJ5S2V5ID8gc3RvcmUgOiBzdG9yZS5pbmRleChpbmRleC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWRiS2V5UmFuZ2UgPSBtYWtlSURCS2V5UmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGltaXQgPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7IHJlc3VsdDogW10gfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNHZXRBbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcSA9IHZhbHVlcyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLmdldEFsbChpZGJLZXlSYW5nZSwgbm9uSW5maW5pdExpbWl0KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLmdldEFsbEtleXMoaWRiS2V5UmFuZ2UsIG5vbkluZmluaXRMaW1pdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZXZlbnQgPT4gcmVzb2x2ZSh7IHJlc3VsdDogZXZlbnQudGFyZ2V0LnJlc3VsdCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxID0gdmFsdWVzIHx8ICEoJ29wZW5LZXlDdXJzb3InIGluIHNvdXJjZSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZS5vcGVuQ3Vyc29yKGlkYktleVJhbmdlKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLm9wZW5LZXlDdXJzb3IoaWRiS2V5UmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnNvciA9IHJlcS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHsgcmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlcyA/IGN1cnNvci52YWx1ZSA6IGN1cnNvci5wcmltYXJ5S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKytjb3VudCA9PT0gbGltaXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHsgcmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IHRhYmxlTmFtZSxcbiAgICAgICAgICAgIHNjaGVtYTogdGFibGVTY2hlbWEsXG4gICAgICAgICAgICBtdXRhdGUsXG4gICAgICAgICAgICBnZXRNYW55KHsgdHJhbnMsIGtleXMgfSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUgPSB3cmFwKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdG9yZSA9IHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGtleUNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNhbGxiYWNrQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVxO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWNjZXNzSGFuZGxlciA9IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcSA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocmVzdWx0W3JlcS5fcG9zXSA9IHJlcS5yZXN1bHQpICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCsrY2FsbGJhY2tDb3VudCA9PT0ga2V5Q291bnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvckhhbmRsZXIgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcSA9IHN0b3JlLmdldChrZXlzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEuX3BvcyA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHN1Y2Nlc3NIYW5kbGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXJyb3JIYW5kbGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsra2V5Q291bnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleUNvdW50ID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCh7IHRyYW5zLCBrZXkgfSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUgPSB3cmFwKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdG9yZSA9IHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcSA9IHN0b3JlLmdldChrZXkpO1xuICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZXZlbnQgPT4gcmVzb2x2ZShldmVudC50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBxdWVyeTogcXVlcnkoaGFzR2V0QWxsKSxcbiAgICAgICAgICAgIG9wZW5DdXJzb3IsXG4gICAgICAgICAgICBjb3VudCh7IHF1ZXJ5LCB0cmFucyB9KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpbmRleCwgcmFuZ2UgfSA9IHF1ZXJ5O1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc291cmNlID0gaW5kZXguaXNQcmltYXJ5S2V5ID8gc3RvcmUgOiBzdG9yZS5pbmRleChpbmRleC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWRiS2V5UmFuZ2UgPSBtYWtlSURCS2V5UmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXEgPSBpZGJLZXlSYW5nZSA/IHNvdXJjZS5jb3VudChpZGJLZXlSYW5nZSkgOiBzb3VyY2UuY291bnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHdyYXAoZXYgPT4gcmVzb2x2ZShldi50YXJnZXQucmVzdWx0KSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHsgc2NoZW1hLCBoYXNHZXRBbGwgfSA9IGV4dHJhY3RTY2hlbWEoZGIsIHRtcFRyYW5zKTtcbiAgICBjb25zdCB0YWJsZXMgPSBzY2hlbWEudGFibGVzLm1hcCh0YWJsZVNjaGVtYSA9PiBjcmVhdGVEYkNvcmVUYWJsZSh0YWJsZVNjaGVtYSkpO1xuICAgIGNvbnN0IHRhYmxlTWFwID0ge307XG4gICAgdGFibGVzLmZvckVhY2godGFibGUgPT4gdGFibGVNYXBbdGFibGUubmFtZV0gPSB0YWJsZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhY2s6IFwiZGJjb3JlXCIsXG4gICAgICAgIHRyYW5zYWN0aW9uOiBkYi50cmFuc2FjdGlvbi5iaW5kKGRiKSxcbiAgICAgICAgdGFibGUobmFtZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGFibGVNYXBbbmFtZV07XG4gICAgICAgICAgICBpZiAoIXJlc3VsdClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRhYmxlICcke25hbWV9JyBub3QgZm91bmRgKTtcbiAgICAgICAgICAgIHJldHVybiB0YWJsZU1hcFtuYW1lXTtcbiAgICAgICAgfSxcbiAgICAgICAgTUlOX0tFWTogLUluZmluaXR5LFxuICAgICAgICBNQVhfS0VZOiBnZXRNYXhLZXkoSWRiS2V5UmFuZ2UpLFxuICAgICAgICBzY2hlbWFcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNaWRkbGV3YXJlU3RhY2soc3RhY2tJbXBsLCBtaWRkbGV3YXJlcykge1xuICAgIHJldHVybiBtaWRkbGV3YXJlcy5yZWR1Y2UoKGRvd24sIHsgY3JlYXRlIH0pID0+ICh7IC4uLmRvd24sIC4uLmNyZWF0ZShkb3duKSB9KSwgc3RhY2tJbXBsKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1pZGRsZXdhcmVTdGFja3MobWlkZGxld2FyZXMsIGlkYmRiLCB7IElEQktleVJhbmdlLCBpbmRleGVkREIgfSwgdG1wVHJhbnMpIHtcbiAgICBjb25zdCBkYmNvcmUgPSBjcmVhdGVNaWRkbGV3YXJlU3RhY2soY3JlYXRlREJDb3JlKGlkYmRiLCBJREJLZXlSYW5nZSwgdG1wVHJhbnMpLCBtaWRkbGV3YXJlcy5kYmNvcmUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRiY29yZVxuICAgIH07XG59XG5mdW5jdGlvbiBnZW5lcmF0ZU1pZGRsZXdhcmVTdGFja3MoeyBfbm92aXA6IGRiIH0sIHRtcFRyYW5zKSB7XG4gICAgY29uc3QgaWRiZGIgPSB0bXBUcmFucy5kYjtcbiAgICBjb25zdCBzdGFja3MgPSBjcmVhdGVNaWRkbGV3YXJlU3RhY2tzKGRiLl9taWRkbGV3YXJlcywgaWRiZGIsIGRiLl9kZXBzLCB0bXBUcmFucyk7XG4gICAgZGIuY29yZSA9IHN0YWNrcy5kYmNvcmU7XG4gICAgZGIudGFibGVzLmZvckVhY2godGFibGUgPT4ge1xuICAgICAgICBjb25zdCB0YWJsZU5hbWUgPSB0YWJsZS5uYW1lO1xuICAgICAgICBpZiAoZGIuY29yZS5zY2hlbWEudGFibGVzLnNvbWUodGJsID0+IHRibC5uYW1lID09PSB0YWJsZU5hbWUpKSB7XG4gICAgICAgICAgICB0YWJsZS5jb3JlID0gZGIuY29yZS50YWJsZSh0YWJsZU5hbWUpO1xuICAgICAgICAgICAgaWYgKGRiW3RhYmxlTmFtZV0gaW5zdGFuY2VvZiBkYi5UYWJsZSkge1xuICAgICAgICAgICAgICAgIGRiW3RhYmxlTmFtZV0uY29yZSA9IHRhYmxlLmNvcmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gc2V0QXBpT25QbGFjZSh7IF9ub3ZpcDogZGIgfSwgb2JqcywgdGFibGVOYW1lcywgZGJzY2hlbWEpIHtcbiAgICB0YWJsZU5hbWVzLmZvckVhY2godGFibGVOYW1lID0+IHtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gZGJzY2hlbWFbdGFibGVOYW1lXTtcbiAgICAgICAgb2Jqcy5mb3JFYWNoKG9iaiA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9wRGVzYyA9IGdldFByb3BlcnR5RGVzY3JpcHRvcihvYmosIHRhYmxlTmFtZSk7XG4gICAgICAgICAgICBpZiAoIXByb3BEZXNjIHx8IChcInZhbHVlXCIgaW4gcHJvcERlc2MgJiYgcHJvcERlc2MudmFsdWUgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqID09PSBkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGUgfHwgb2JqIGluc3RhbmNlb2YgZGIuVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0UHJvcChvYmosIHRhYmxlTmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0KCkgeyByZXR1cm4gdGhpcy50YWJsZSh0YWJsZU5hbWUpOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5lUHJvcGVydHkodGhpcywgdGFibGVOYW1lLCB7IHZhbHVlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialt0YWJsZU5hbWVdID0gbmV3IGRiLlRhYmxlKHRhYmxlTmFtZSwgc2NoZW1hKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcmVtb3ZlVGFibGVzQXBpKHsgX25vdmlwOiBkYiB9LCBvYmpzKSB7XG4gICAgb2Jqcy5mb3JFYWNoKG9iaiA9PiB7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmpba2V5XSBpbnN0YW5jZW9mIGRiLlRhYmxlKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gbG93ZXJWZXJzaW9uRmlyc3QoYSwgYikge1xuICAgIHJldHVybiBhLl9jZmcudmVyc2lvbiAtIGIuX2NmZy52ZXJzaW9uO1xufVxuZnVuY3Rpb24gcnVuVXBncmFkZXJzKGRiLCBvbGRWZXJzaW9uLCBpZGJVcGdyYWRlVHJhbnMsIHJlamVjdCkge1xuICAgIGNvbnN0IGdsb2JhbFNjaGVtYSA9IGRiLl9kYlNjaGVtYTtcbiAgICBjb25zdCB0cmFucyA9IGRiLl9jcmVhdGVUcmFuc2FjdGlvbigncmVhZHdyaXRlJywgZGIuX3N0b3JlTmFtZXMsIGdsb2JhbFNjaGVtYSk7XG4gICAgdHJhbnMuY3JlYXRlKGlkYlVwZ3JhZGVUcmFucyk7XG4gICAgdHJhbnMuX2NvbXBsZXRpb24uY2F0Y2gocmVqZWN0KTtcbiAgICBjb25zdCByZWplY3RUcmFuc2FjdGlvbiA9IHRyYW5zLl9yZWplY3QuYmluZCh0cmFucyk7XG4gICAgY29uc3QgdHJhbnNsZXNzID0gUFNELnRyYW5zbGVzcyB8fCBQU0Q7XG4gICAgbmV3U2NvcGUoKCkgPT4ge1xuICAgICAgICBQU0QudHJhbnMgPSB0cmFucztcbiAgICAgICAgUFNELnRyYW5zbGVzcyA9IHRyYW5zbGVzcztcbiAgICAgICAgaWYgKG9sZFZlcnNpb24gPT09IDApIHtcbiAgICAgICAgICAgIGtleXMoZ2xvYmFsU2NoZW1hKS5mb3JFYWNoKHRhYmxlTmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgY3JlYXRlVGFibGUoaWRiVXBncmFkZVRyYW5zLCB0YWJsZU5hbWUsIGdsb2JhbFNjaGVtYVt0YWJsZU5hbWVdLnByaW1LZXksIGdsb2JhbFNjaGVtYVt0YWJsZU5hbWVdLmluZGV4ZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBnZW5lcmF0ZU1pZGRsZXdhcmVTdGFja3MoZGIsIGlkYlVwZ3JhZGVUcmFucyk7XG4gICAgICAgICAgICBEZXhpZVByb21pc2UuZm9sbG93KCgpID0+IGRiLm9uLnBvcHVsYXRlLmZpcmUodHJhbnMpKS5jYXRjaChyZWplY3RUcmFuc2FjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdXBkYXRlVGFibGVzQW5kSW5kZXhlcyhkYiwgb2xkVmVyc2lvbiwgdHJhbnMsIGlkYlVwZ3JhZGVUcmFucykuY2F0Y2gocmVqZWN0VHJhbnNhY3Rpb24pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gdXBkYXRlVGFibGVzQW5kSW5kZXhlcyh7IF9ub3ZpcDogZGIgfSwgb2xkVmVyc2lvbiwgdHJhbnMsIGlkYlVwZ3JhZGVUcmFucykge1xuICAgIGNvbnN0IHF1ZXVlID0gW107XG4gICAgY29uc3QgdmVyc2lvbnMgPSBkYi5fdmVyc2lvbnM7XG4gICAgbGV0IGdsb2JhbFNjaGVtYSA9IGRiLl9kYlNjaGVtYSA9IGJ1aWxkR2xvYmFsU2NoZW1hKGRiLCBkYi5pZGJkYiwgaWRiVXBncmFkZVRyYW5zKTtcbiAgICBsZXQgYW55Q29udGVudFVwZ3JhZGVySGFzUnVuID0gZmFsc2U7XG4gICAgY29uc3QgdmVyc1RvUnVuID0gdmVyc2lvbnMuZmlsdGVyKHYgPT4gdi5fY2ZnLnZlcnNpb24gPj0gb2xkVmVyc2lvbik7XG4gICAgdmVyc1RvUnVuLmZvckVhY2godmVyc2lvbiA9PiB7XG4gICAgICAgIHF1ZXVlLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb2xkU2NoZW1hID0gZ2xvYmFsU2NoZW1hO1xuICAgICAgICAgICAgY29uc3QgbmV3U2NoZW1hID0gdmVyc2lvbi5fY2ZnLmRic2NoZW1hO1xuICAgICAgICAgICAgYWRqdXN0VG9FeGlzdGluZ0luZGV4TmFtZXMoZGIsIG9sZFNjaGVtYSwgaWRiVXBncmFkZVRyYW5zKTtcbiAgICAgICAgICAgIGFkanVzdFRvRXhpc3RpbmdJbmRleE5hbWVzKGRiLCBuZXdTY2hlbWEsIGlkYlVwZ3JhZGVUcmFucyk7XG4gICAgICAgICAgICBnbG9iYWxTY2hlbWEgPSBkYi5fZGJTY2hlbWEgPSBuZXdTY2hlbWE7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gZ2V0U2NoZW1hRGlmZihvbGRTY2hlbWEsIG5ld1NjaGVtYSk7XG4gICAgICAgICAgICBkaWZmLmFkZC5mb3JFYWNoKHR1cGxlID0+IHtcbiAgICAgICAgICAgICAgICBjcmVhdGVUYWJsZShpZGJVcGdyYWRlVHJhbnMsIHR1cGxlWzBdLCB0dXBsZVsxXS5wcmltS2V5LCB0dXBsZVsxXS5pbmRleGVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGlmZi5jaGFuZ2UuZm9yRWFjaChjaGFuZ2UgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UucmVjcmVhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuVXBncmFkZShcIk5vdCB5ZXQgc3VwcG9ydCBmb3IgY2hhbmdpbmcgcHJpbWFyeSBrZXlcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdG9yZSA9IGlkYlVwZ3JhZGVUcmFucy5vYmplY3RTdG9yZShjaGFuZ2UubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZS5hZGQuZm9yRWFjaChpZHggPT4gYWRkSW5kZXgoc3RvcmUsIGlkeCkpO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2UuY2hhbmdlLmZvckVhY2goaWR4ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlLmRlbGV0ZUluZGV4KGlkeC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEluZGV4KHN0b3JlLCBpZHgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmRlbC5mb3JFYWNoKGlkeE5hbWUgPT4gc3RvcmUuZGVsZXRlSW5kZXgoaWR4TmFtZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgY29udGVudFVwZ3JhZGUgPSB2ZXJzaW9uLl9jZmcuY29udGVudFVwZ3JhZGU7XG4gICAgICAgICAgICBpZiAoY29udGVudFVwZ3JhZGUgJiYgdmVyc2lvbi5fY2ZnLnZlcnNpb24gPiBvbGRWZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVNaWRkbGV3YXJlU3RhY2tzKGRiLCBpZGJVcGdyYWRlVHJhbnMpO1xuICAgICAgICAgICAgICAgIHRyYW5zLl9tZW1vaXplZFRhYmxlcyA9IHt9O1xuICAgICAgICAgICAgICAgIGFueUNvbnRlbnRVcGdyYWRlckhhc1J1biA9IHRydWU7XG4gICAgICAgICAgICAgICAgbGV0IHVwZ3JhZGVTY2hlbWEgPSBzaGFsbG93Q2xvbmUobmV3U2NoZW1hKTtcbiAgICAgICAgICAgICAgICBkaWZmLmRlbC5mb3JFYWNoKHRhYmxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdXBncmFkZVNjaGVtYVt0YWJsZV0gPSBvbGRTY2hlbWFbdGFibGVdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlbW92ZVRhYmxlc0FwaShkYiwgW2RiLlRyYW5zYWN0aW9uLnByb3RvdHlwZV0pO1xuICAgICAgICAgICAgICAgIHNldEFwaU9uUGxhY2UoZGIsIFtkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGVdLCBrZXlzKHVwZ3JhZGVTY2hlbWEpLCB1cGdyYWRlU2NoZW1hKTtcbiAgICAgICAgICAgICAgICB0cmFucy5zY2hlbWEgPSB1cGdyYWRlU2NoZW1hO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRVcGdyYWRlSXNBc3luYyA9IGlzQXN5bmNGdW5jdGlvbihjb250ZW50VXBncmFkZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRVcGdyYWRlSXNBc3luYykge1xuICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmV0dXJuVmFsdWU7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZUZvbGxvd2VkID0gRGV4aWVQcm9taXNlLmZvbGxvdygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gY29udGVudFVwZ3JhZGUodHJhbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50VXBncmFkZUlzQXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVjcmVtZW50b3IgPSBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cy5iaW5kKG51bGwsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlLnRoZW4oZGVjcmVtZW50b3IsIGRlY3JlbWVudG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAocmV0dXJuVmFsdWUgJiYgdHlwZW9mIHJldHVyblZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgICAgICAgICBEZXhpZVByb21pc2UucmVzb2x2ZShyZXR1cm5WYWx1ZSkgOiBwcm9taXNlRm9sbG93ZWQudGhlbigoKSA9PiByZXR1cm5WYWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcXVldWUucHVzaChpZGJ0cmFucyA9PiB7XG4gICAgICAgICAgICBpZiAoIWFueUNvbnRlbnRVcGdyYWRlckhhc1J1biB8fCAhaGFzSUVEZWxldGVPYmplY3RTdG9yZUJ1Zykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1NjaGVtYSA9IHZlcnNpb24uX2NmZy5kYnNjaGVtYTtcbiAgICAgICAgICAgICAgICBkZWxldGVSZW1vdmVkVGFibGVzKG5ld1NjaGVtYSwgaWRidHJhbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVtb3ZlVGFibGVzQXBpKGRiLCBbZGIuVHJhbnNhY3Rpb24ucHJvdG90eXBlXSk7XG4gICAgICAgICAgICBzZXRBcGlPblBsYWNlKGRiLCBbZGIuVHJhbnNhY3Rpb24ucHJvdG90eXBlXSwgZGIuX3N0b3JlTmFtZXMsIGRiLl9kYlNjaGVtYSk7XG4gICAgICAgICAgICB0cmFucy5zY2hlbWEgPSBkYi5fZGJTY2hlbWE7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHJ1blF1ZXVlKCkge1xuICAgICAgICByZXR1cm4gcXVldWUubGVuZ3RoID8gRGV4aWVQcm9taXNlLnJlc29sdmUocXVldWUuc2hpZnQoKSh0cmFucy5pZGJ0cmFucykpLnRoZW4ocnVuUXVldWUpIDpcbiAgICAgICAgICAgIERleGllUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHJldHVybiBydW5RdWV1ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBjcmVhdGVNaXNzaW5nVGFibGVzKGdsb2JhbFNjaGVtYSwgaWRiVXBncmFkZVRyYW5zKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldFNjaGVtYURpZmYob2xkU2NoZW1hLCBuZXdTY2hlbWEpIHtcbiAgICBjb25zdCBkaWZmID0ge1xuICAgICAgICBkZWw6IFtdLFxuICAgICAgICBhZGQ6IFtdLFxuICAgICAgICBjaGFuZ2U6IFtdXG4gICAgfTtcbiAgICBsZXQgdGFibGU7XG4gICAgZm9yICh0YWJsZSBpbiBvbGRTY2hlbWEpIHtcbiAgICAgICAgaWYgKCFuZXdTY2hlbWFbdGFibGVdKVxuICAgICAgICAgICAgZGlmZi5kZWwucHVzaCh0YWJsZSk7XG4gICAgfVxuICAgIGZvciAodGFibGUgaW4gbmV3U2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IG9sZERlZiA9IG9sZFNjaGVtYVt0YWJsZV0sIG5ld0RlZiA9IG5ld1NjaGVtYVt0YWJsZV07XG4gICAgICAgIGlmICghb2xkRGVmKSB7XG4gICAgICAgICAgICBkaWZmLmFkZC5wdXNoKFt0YWJsZSwgbmV3RGVmXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogdGFibGUsXG4gICAgICAgICAgICAgICAgZGVmOiBuZXdEZWYsXG4gICAgICAgICAgICAgICAgcmVjcmVhdGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGRlbDogW10sXG4gICAgICAgICAgICAgICAgYWRkOiBbXSxcbiAgICAgICAgICAgICAgICBjaGFuZ2U6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKChcbiAgICAgICAgICAgICcnICsgKG9sZERlZi5wcmltS2V5LmtleVBhdGggfHwgJycpKSAhPT0gKCcnICsgKG5ld0RlZi5wcmltS2V5LmtleVBhdGggfHwgJycpKSB8fFxuICAgICAgICAgICAgICAgIChvbGREZWYucHJpbUtleS5hdXRvICE9PSBuZXdEZWYucHJpbUtleS5hdXRvICYmICFpc0lFT3JFZGdlKSlcbiAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2hhbmdlLnJlY3JlYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBkaWZmLmNoYW5nZS5wdXNoKGNoYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRJbmRleGVzID0gb2xkRGVmLmlkeEJ5TmFtZTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdJbmRleGVzID0gbmV3RGVmLmlkeEJ5TmFtZTtcbiAgICAgICAgICAgICAgICBsZXQgaWR4TmFtZTtcbiAgICAgICAgICAgICAgICBmb3IgKGlkeE5hbWUgaW4gb2xkSW5kZXhlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld0luZGV4ZXNbaWR4TmFtZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UuZGVsLnB1c2goaWR4TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoaWR4TmFtZSBpbiBuZXdJbmRleGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZElkeCA9IG9sZEluZGV4ZXNbaWR4TmFtZV0sIG5ld0lkeCA9IG5ld0luZGV4ZXNbaWR4TmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghb2xkSWR4KVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmFkZC5wdXNoKG5ld0lkeCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9sZElkeC5zcmMgIT09IG5ld0lkeC5zcmMpXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UuY2hhbmdlLnB1c2gobmV3SWR4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZS5kZWwubGVuZ3RoID4gMCB8fCBjaGFuZ2UuYWRkLmxlbmd0aCA+IDAgfHwgY2hhbmdlLmNoYW5nZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZmYuY2hhbmdlLnB1c2goY2hhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpZmY7XG59XG5mdW5jdGlvbiBjcmVhdGVUYWJsZShpZGJ0cmFucywgdGFibGVOYW1lLCBwcmltS2V5LCBpbmRleGVzKSB7XG4gICAgY29uc3Qgc3RvcmUgPSBpZGJ0cmFucy5kYi5jcmVhdGVPYmplY3RTdG9yZSh0YWJsZU5hbWUsIHByaW1LZXkua2V5UGF0aCA/XG4gICAgICAgIHsga2V5UGF0aDogcHJpbUtleS5rZXlQYXRoLCBhdXRvSW5jcmVtZW50OiBwcmltS2V5LmF1dG8gfSA6XG4gICAgICAgIHsgYXV0b0luY3JlbWVudDogcHJpbUtleS5hdXRvIH0pO1xuICAgIGluZGV4ZXMuZm9yRWFjaChpZHggPT4gYWRkSW5kZXgoc3RvcmUsIGlkeCkpO1xuICAgIHJldHVybiBzdG9yZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1pc3NpbmdUYWJsZXMobmV3U2NoZW1hLCBpZGJ0cmFucykge1xuICAgIGtleXMobmV3U2NoZW1hKS5mb3JFYWNoKHRhYmxlTmFtZSA9PiB7XG4gICAgICAgIGlmICghaWRidHJhbnMuZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyh0YWJsZU5hbWUpKSB7XG4gICAgICAgICAgICBjcmVhdGVUYWJsZShpZGJ0cmFucywgdGFibGVOYW1lLCBuZXdTY2hlbWFbdGFibGVOYW1lXS5wcmltS2V5LCBuZXdTY2hlbWFbdGFibGVOYW1lXS5pbmRleGVzKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gZGVsZXRlUmVtb3ZlZFRhYmxlcyhuZXdTY2hlbWEsIGlkYnRyYW5zKSB7XG4gICAgW10uc2xpY2UuY2FsbChpZGJ0cmFucy5kYi5vYmplY3RTdG9yZU5hbWVzKS5mb3JFYWNoKHN0b3JlTmFtZSA9PiBuZXdTY2hlbWFbc3RvcmVOYW1lXSA9PSBudWxsICYmIGlkYnRyYW5zLmRiLmRlbGV0ZU9iamVjdFN0b3JlKHN0b3JlTmFtZSkpO1xufVxuZnVuY3Rpb24gYWRkSW5kZXgoc3RvcmUsIGlkeCkge1xuICAgIHN0b3JlLmNyZWF0ZUluZGV4KGlkeC5uYW1lLCBpZHgua2V5UGF0aCwgeyB1bmlxdWU6IGlkeC51bmlxdWUsIG11bHRpRW50cnk6IGlkeC5tdWx0aSB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkR2xvYmFsU2NoZW1hKGRiLCBpZGJkYiwgdG1wVHJhbnMpIHtcbiAgICBjb25zdCBnbG9iYWxTY2hlbWEgPSB7fTtcbiAgICBjb25zdCBkYlN0b3JlTmFtZXMgPSBzbGljZShpZGJkYi5vYmplY3RTdG9yZU5hbWVzLCAwKTtcbiAgICBkYlN0b3JlTmFtZXMuZm9yRWFjaChzdG9yZU5hbWUgPT4ge1xuICAgICAgICBjb25zdCBzdG9yZSA9IHRtcFRyYW5zLm9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XG4gICAgICAgIGxldCBrZXlQYXRoID0gc3RvcmUua2V5UGF0aDtcbiAgICAgICAgY29uc3QgcHJpbUtleSA9IGNyZWF0ZUluZGV4U3BlYyhuYW1lRnJvbUtleVBhdGgoa2V5UGF0aCksIGtleVBhdGggfHwgXCJcIiwgZmFsc2UsIGZhbHNlLCAhIXN0b3JlLmF1dG9JbmNyZW1lbnQsIGtleVBhdGggJiYgdHlwZW9mIGtleVBhdGggIT09IFwic3RyaW5nXCIsIHRydWUpO1xuICAgICAgICBjb25zdCBpbmRleGVzID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3RvcmUuaW5kZXhOYW1lcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgY29uc3QgaWRiaW5kZXggPSBzdG9yZS5pbmRleChzdG9yZS5pbmRleE5hbWVzW2pdKTtcbiAgICAgICAgICAgIGtleVBhdGggPSBpZGJpbmRleC5rZXlQYXRoO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gY3JlYXRlSW5kZXhTcGVjKGlkYmluZGV4Lm5hbWUsIGtleVBhdGgsICEhaWRiaW5kZXgudW5pcXVlLCAhIWlkYmluZGV4Lm11bHRpRW50cnksIGZhbHNlLCBrZXlQYXRoICYmIHR5cGVvZiBrZXlQYXRoICE9PSBcInN0cmluZ1wiLCBmYWxzZSk7XG4gICAgICAgICAgICBpbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGdsb2JhbFNjaGVtYVtzdG9yZU5hbWVdID0gY3JlYXRlVGFibGVTY2hlbWEoc3RvcmVOYW1lLCBwcmltS2V5LCBpbmRleGVzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZ2xvYmFsU2NoZW1hO1xufVxuZnVuY3Rpb24gcmVhZEdsb2JhbFNjaGVtYSh7IF9ub3ZpcDogZGIgfSwgaWRiZGIsIHRtcFRyYW5zKSB7XG4gICAgZGIudmVybm8gPSBpZGJkYi52ZXJzaW9uIC8gMTA7XG4gICAgY29uc3QgZ2xvYmFsU2NoZW1hID0gZGIuX2RiU2NoZW1hID0gYnVpbGRHbG9iYWxTY2hlbWEoZGIsIGlkYmRiLCB0bXBUcmFucyk7XG4gICAgZGIuX3N0b3JlTmFtZXMgPSBzbGljZShpZGJkYi5vYmplY3RTdG9yZU5hbWVzLCAwKTtcbiAgICBzZXRBcGlPblBsYWNlKGRiLCBbZGIuX2FsbFRhYmxlc10sIGtleXMoZ2xvYmFsU2NoZW1hKSwgZ2xvYmFsU2NoZW1hKTtcbn1cbmZ1bmN0aW9uIHZlcmlmeUluc3RhbGxlZFNjaGVtYShkYiwgdG1wVHJhbnMpIHtcbiAgICBjb25zdCBpbnN0YWxsZWRTY2hlbWEgPSBidWlsZEdsb2JhbFNjaGVtYShkYiwgZGIuaWRiZGIsIHRtcFRyYW5zKTtcbiAgICBjb25zdCBkaWZmID0gZ2V0U2NoZW1hRGlmZihpbnN0YWxsZWRTY2hlbWEsIGRiLl9kYlNjaGVtYSk7XG4gICAgcmV0dXJuICEoZGlmZi5hZGQubGVuZ3RoIHx8IGRpZmYuY2hhbmdlLnNvbWUoY2ggPT4gY2guYWRkLmxlbmd0aCB8fCBjaC5jaGFuZ2UubGVuZ3RoKSk7XG59XG5mdW5jdGlvbiBhZGp1c3RUb0V4aXN0aW5nSW5kZXhOYW1lcyh7IF9ub3ZpcDogZGIgfSwgc2NoZW1hLCBpZGJ0cmFucykge1xuICAgIGNvbnN0IHN0b3JlTmFtZXMgPSBpZGJ0cmFucy5kYi5vYmplY3RTdG9yZU5hbWVzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RvcmVOYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBzdG9yZU5hbWUgPSBzdG9yZU5hbWVzW2ldO1xuICAgICAgICBjb25zdCBzdG9yZSA9IGlkYnRyYW5zLm9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XG4gICAgICAgIGRiLl9oYXNHZXRBbGwgPSAnZ2V0QWxsJyBpbiBzdG9yZTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzdG9yZS5pbmRleE5hbWVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleE5hbWUgPSBzdG9yZS5pbmRleE5hbWVzW2pdO1xuICAgICAgICAgICAgY29uc3Qga2V5UGF0aCA9IHN0b3JlLmluZGV4KGluZGV4TmFtZSkua2V5UGF0aDtcbiAgICAgICAgICAgIGNvbnN0IGRleGllTmFtZSA9IHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJyA/IGtleVBhdGggOiBcIltcIiArIHNsaWNlKGtleVBhdGgpLmpvaW4oJysnKSArIFwiXVwiO1xuICAgICAgICAgICAgaWYgKHNjaGVtYVtzdG9yZU5hbWVdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXhTcGVjID0gc2NoZW1hW3N0b3JlTmFtZV0uaWR4QnlOYW1lW2RleGllTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4U3BlYykge1xuICAgICAgICAgICAgICAgICAgICBpbmRleFNwZWMubmFtZSA9IGluZGV4TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYVtzdG9yZU5hbWVdLmlkeEJ5TmFtZVtkZXhpZU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBzY2hlbWFbc3RvcmVOYW1lXS5pZHhCeU5hbWVbaW5kZXhOYW1lXSA9IGluZGV4U3BlYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9TYWZhcmkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcbiAgICAgICAgIS8oQ2hyb21lXFwvfEVkZ2VcXC8pLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmXG4gICAgICAgIF9nbG9iYWwuV29ya2VyR2xvYmFsU2NvcGUgJiYgX2dsb2JhbCBpbnN0YW5jZW9mIF9nbG9iYWwuV29ya2VyR2xvYmFsU2NvcGUgJiZcbiAgICAgICAgW10uY29uY2F0KG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1NhZmFyaVxcLyhcXGQqKS8pKVsxXSA8IDYwNCkge1xuICAgICAgICBkYi5faGFzR2V0QWxsID0gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VJbmRleFN5bnRheChwcmltS2V5QW5kSW5kZXhlcykge1xuICAgIHJldHVybiBwcmltS2V5QW5kSW5kZXhlcy5zcGxpdCgnLCcpLm1hcCgoaW5kZXgsIGluZGV4TnVtKSA9PiB7XG4gICAgICAgIGluZGV4ID0gaW5kZXgudHJpbSgpO1xuICAgICAgICBjb25zdCBuYW1lID0gaW5kZXgucmVwbGFjZSgvKFsmKl18XFwrXFwrKS9nLCBcIlwiKTtcbiAgICAgICAgY29uc3Qga2V5UGF0aCA9IC9eXFxbLy50ZXN0KG5hbWUpID8gbmFtZS5tYXRjaCgvXlxcWyguKilcXF0kLylbMV0uc3BsaXQoJysnKSA6IG5hbWU7XG4gICAgICAgIHJldHVybiBjcmVhdGVJbmRleFNwZWMobmFtZSwga2V5UGF0aCB8fCBudWxsLCAvXFwmLy50ZXN0KGluZGV4KSwgL1xcKi8udGVzdChpbmRleCksIC9cXCtcXCsvLnRlc3QoaW5kZXgpLCBpc0FycmF5KGtleVBhdGgpLCBpbmRleE51bSA9PT0gMCk7XG4gICAgfSk7XG59XG5cbmNsYXNzIFZlcnNpb24ge1xuICAgIF9wYXJzZVN0b3Jlc1NwZWMoc3RvcmVzLCBvdXRTY2hlbWEpIHtcbiAgICAgICAga2V5cyhzdG9yZXMpLmZvckVhY2godGFibGVOYW1lID0+IHtcbiAgICAgICAgICAgIGlmIChzdG9yZXNbdGFibGVOYW1lXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleGVzID0gcGFyc2VJbmRleFN5bnRheChzdG9yZXNbdGFibGVOYW1lXSk7XG4gICAgICAgICAgICAgICAgdmFyIHByaW1LZXkgPSBpbmRleGVzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHByaW1LZXkubXVsdGkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlNjaGVtYShcIlByaW1hcnkga2V5IGNhbm5vdCBiZSBtdWx0aS12YWx1ZWRcIik7XG4gICAgICAgICAgICAgICAgaW5kZXhlcy5mb3JFYWNoKGlkeCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZHguYXV0bylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlNjaGVtYShcIk9ubHkgcHJpbWFyeSBrZXkgY2FuIGJlIG1hcmtlZCBhcyBhdXRvSW5jcmVtZW50ICgrKylcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaWR4LmtleVBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5TY2hlbWEoXCJJbmRleCBtdXN0IGhhdmUgYSBuYW1lIGFuZCBjYW5ub3QgYmUgYW4gZW1wdHkgc3RyaW5nXCIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG91dFNjaGVtYVt0YWJsZU5hbWVdID0gY3JlYXRlVGFibGVTY2hlbWEodGFibGVOYW1lLCBwcmltS2V5LCBpbmRleGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0b3JlcyhzdG9yZXMpIHtcbiAgICAgICAgY29uc3QgZGIgPSB0aGlzLmRiO1xuICAgICAgICB0aGlzLl9jZmcuc3RvcmVzU291cmNlID0gdGhpcy5fY2ZnLnN0b3Jlc1NvdXJjZSA/XG4gICAgICAgICAgICBleHRlbmQodGhpcy5fY2ZnLnN0b3Jlc1NvdXJjZSwgc3RvcmVzKSA6XG4gICAgICAgICAgICBzdG9yZXM7XG4gICAgICAgIGNvbnN0IHZlcnNpb25zID0gZGIuX3ZlcnNpb25zO1xuICAgICAgICBjb25zdCBzdG9yZXNTcGVjID0ge307XG4gICAgICAgIGxldCBkYnNjaGVtYSA9IHt9O1xuICAgICAgICB2ZXJzaW9ucy5mb3JFYWNoKHZlcnNpb24gPT4ge1xuICAgICAgICAgICAgZXh0ZW5kKHN0b3Jlc1NwZWMsIHZlcnNpb24uX2NmZy5zdG9yZXNTb3VyY2UpO1xuICAgICAgICAgICAgZGJzY2hlbWEgPSAodmVyc2lvbi5fY2ZnLmRic2NoZW1hID0ge30pO1xuICAgICAgICAgICAgdmVyc2lvbi5fcGFyc2VTdG9yZXNTcGVjKHN0b3Jlc1NwZWMsIGRic2NoZW1hKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRiLl9kYlNjaGVtYSA9IGRic2NoZW1hO1xuICAgICAgICByZW1vdmVUYWJsZXNBcGkoZGIsIFtkYi5fYWxsVGFibGVzLCBkYiwgZGIuVHJhbnNhY3Rpb24ucHJvdG90eXBlXSk7XG4gICAgICAgIHNldEFwaU9uUGxhY2UoZGIsIFtkYi5fYWxsVGFibGVzLCBkYiwgZGIuVHJhbnNhY3Rpb24ucHJvdG90eXBlLCB0aGlzLl9jZmcudGFibGVzXSwga2V5cyhkYnNjaGVtYSksIGRic2NoZW1hKTtcbiAgICAgICAgZGIuX3N0b3JlTmFtZXMgPSBrZXlzKGRic2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVwZ3JhZGUodXBncmFkZUZ1bmN0aW9uKSB7XG4gICAgICAgIHRoaXMuX2NmZy5jb250ZW50VXBncmFkZSA9IHByb21pc2FibGVDaGFpbih0aGlzLl9jZmcuY29udGVudFVwZ3JhZGUgfHwgbm9wLCB1cGdyYWRlRnVuY3Rpb24pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVZlcnNpb25Db25zdHJ1Y3RvcihkYikge1xuICAgIHJldHVybiBtYWtlQ2xhc3NDb25zdHJ1Y3RvcihWZXJzaW9uLnByb3RvdHlwZSwgZnVuY3Rpb24gVmVyc2lvbih2ZXJzaW9uTnVtYmVyKSB7XG4gICAgICAgIHRoaXMuZGIgPSBkYjtcbiAgICAgICAgdGhpcy5fY2ZnID0ge1xuICAgICAgICAgICAgdmVyc2lvbjogdmVyc2lvbk51bWJlcixcbiAgICAgICAgICAgIHN0b3Jlc1NvdXJjZTogbnVsbCxcbiAgICAgICAgICAgIGRic2NoZW1hOiB7fSxcbiAgICAgICAgICAgIHRhYmxlczoge30sXG4gICAgICAgICAgICBjb250ZW50VXBncmFkZTogbnVsbFxuICAgICAgICB9O1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBnZXREYk5hbWVzVGFibGUoaW5kZXhlZERCLCBJREJLZXlSYW5nZSkge1xuICAgIGxldCBkYk5hbWVzREIgPSBpbmRleGVkREJbXCJfZGJOYW1lc0RCXCJdO1xuICAgIGlmICghZGJOYW1lc0RCKSB7XG4gICAgICAgIGRiTmFtZXNEQiA9IGluZGV4ZWREQltcIl9kYk5hbWVzREJcIl0gPSBuZXcgRGV4aWUkMShEQk5BTUVTX0RCLCB7XG4gICAgICAgICAgICBhZGRvbnM6IFtdLFxuICAgICAgICAgICAgaW5kZXhlZERCLFxuICAgICAgICAgICAgSURCS2V5UmFuZ2UsXG4gICAgICAgIH0pO1xuICAgICAgICBkYk5hbWVzREIudmVyc2lvbigxKS5zdG9yZXMoeyBkYm5hbWVzOiBcIm5hbWVcIiB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRiTmFtZXNEQi50YWJsZShcImRibmFtZXNcIik7XG59XG5mdW5jdGlvbiBoYXNEYXRhYmFzZXNOYXRpdmUoaW5kZXhlZERCKSB7XG4gICAgcmV0dXJuIGluZGV4ZWREQiAmJiB0eXBlb2YgaW5kZXhlZERCLmRhdGFiYXNlcyA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gZ2V0RGF0YWJhc2VOYW1lcyh7IGluZGV4ZWREQiwgSURCS2V5UmFuZ2UsIH0pIHtcbiAgICByZXR1cm4gaGFzRGF0YWJhc2VzTmF0aXZlKGluZGV4ZWREQilcbiAgICAgICAgPyBQcm9taXNlLnJlc29sdmUoaW5kZXhlZERCLmRhdGFiYXNlcygpKS50aGVuKChpbmZvcykgPT4gaW5mb3NcbiAgICAgICAgICAgIC5tYXAoKGluZm8pID0+IGluZm8ubmFtZSlcbiAgICAgICAgICAgIC5maWx0ZXIoKG5hbWUpID0+IG5hbWUgIT09IERCTkFNRVNfREIpKVxuICAgICAgICA6IGdldERiTmFtZXNUYWJsZShpbmRleGVkREIsIElEQktleVJhbmdlKS50b0NvbGxlY3Rpb24oKS5wcmltYXJ5S2V5cygpO1xufVxuZnVuY3Rpb24gX29uRGF0YWJhc2VDcmVhdGVkKHsgaW5kZXhlZERCLCBJREJLZXlSYW5nZSB9LCBuYW1lKSB7XG4gICAgIWhhc0RhdGFiYXNlc05hdGl2ZShpbmRleGVkREIpICYmXG4gICAgICAgIG5hbWUgIT09IERCTkFNRVNfREIgJiZcbiAgICAgICAgZ2V0RGJOYW1lc1RhYmxlKGluZGV4ZWREQiwgSURCS2V5UmFuZ2UpLnB1dCh7IG5hbWUgfSkuY2F0Y2gobm9wKTtcbn1cbmZ1bmN0aW9uIF9vbkRhdGFiYXNlRGVsZXRlZCh7IGluZGV4ZWREQiwgSURCS2V5UmFuZ2UgfSwgbmFtZSkge1xuICAgICFoYXNEYXRhYmFzZXNOYXRpdmUoaW5kZXhlZERCKSAmJlxuICAgICAgICBuYW1lICE9PSBEQk5BTUVTX0RCICYmXG4gICAgICAgIGdldERiTmFtZXNUYWJsZShpbmRleGVkREIsIElEQktleVJhbmdlKS5kZWxldGUobmFtZSkuY2F0Y2gobm9wKTtcbn1cblxuZnVuY3Rpb24gdmlwKGZuKSB7XG4gICAgcmV0dXJuIG5ld1Njb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgUFNELmxldFRocm91Z2ggPSB0cnVlO1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gaWRiUmVhZHkoKSB7XG4gICAgdmFyIGlzU2FmYXJpID0gIW5hdmlnYXRvci51c2VyQWdlbnREYXRhICYmXG4gICAgICAgIC9TYWZhcmlcXC8vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcbiAgICAgICAgIS9DaHJvbShlfGl1bSlcXC8vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgaWYgKCFpc1NhZmFyaSB8fCAhaW5kZXhlZERCLmRhdGFiYXNlcylcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHZhciBpbnRlcnZhbElkO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICB2YXIgdHJ5SWRiID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhlZERCLmRhdGFiYXNlcygpLmZpbmFsbHkocmVzb2x2ZSk7IH07XG4gICAgICAgIGludGVydmFsSWQgPSBzZXRJbnRlcnZhbCh0cnlJZGIsIDEwMCk7XG4gICAgICAgIHRyeUlkYigpO1xuICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24gKCkgeyByZXR1cm4gY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTsgfSk7XG59XG5cbmZ1bmN0aW9uIGRleGllT3BlbihkYikge1xuICAgIGNvbnN0IHN0YXRlID0gZGIuX3N0YXRlO1xuICAgIGNvbnN0IHsgaW5kZXhlZERCIH0gPSBkYi5fZGVwcztcbiAgICBpZiAoc3RhdGUuaXNCZWluZ09wZW5lZCB8fCBkYi5pZGJkYilcbiAgICAgICAgcmV0dXJuIHN0YXRlLmRiUmVhZHlQcm9taXNlLnRoZW4oKCkgPT4gc3RhdGUuZGJPcGVuRXJyb3IgP1xuICAgICAgICAgICAgcmVqZWN0aW9uKHN0YXRlLmRiT3BlbkVycm9yKSA6XG4gICAgICAgICAgICBkYik7XG4gICAgZGVidWcgJiYgKHN0YXRlLm9wZW5DYW5jZWxsZXIuX3N0YWNrSG9sZGVyID0gZ2V0RXJyb3JXaXRoU3RhY2soKSk7XG4gICAgc3RhdGUuaXNCZWluZ09wZW5lZCA9IHRydWU7XG4gICAgc3RhdGUuZGJPcGVuRXJyb3IgPSBudWxsO1xuICAgIHN0YXRlLm9wZW5Db21wbGV0ZSA9IGZhbHNlO1xuICAgIGNvbnN0IG9wZW5DYW5jZWxsZXIgPSBzdGF0ZS5vcGVuQ2FuY2VsbGVyO1xuICAgIGZ1bmN0aW9uIHRocm93SWZDYW5jZWxsZWQoKSB7XG4gICAgICAgIGlmIChzdGF0ZS5vcGVuQ2FuY2VsbGVyICE9PSBvcGVuQ2FuY2VsbGVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoJ2RiLm9wZW4oKSB3YXMgY2FuY2VsbGVkJyk7XG4gICAgfVxuICAgIGxldCByZXNvbHZlRGJSZWFkeSA9IHN0YXRlLmRiUmVhZHlSZXNvbHZlLFxuICAgIHVwZ3JhZGVUcmFuc2FjdGlvbiA9IG51bGwsIHdhc0NyZWF0ZWQgPSBmYWxzZTtcbiAgICBjb25zdCB0cnlPcGVuREIgPSAoKSA9PiBuZXcgRGV4aWVQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdGhyb3dJZkNhbmNlbGxlZCgpO1xuICAgICAgICBpZiAoIWluZGV4ZWREQilcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk1pc3NpbmdBUEkoKTtcbiAgICAgICAgY29uc3QgZGJOYW1lID0gZGIubmFtZTtcbiAgICAgICAgY29uc3QgcmVxID0gc3RhdGUuYXV0b1NjaGVtYSA/XG4gICAgICAgICAgICBpbmRleGVkREIub3BlbihkYk5hbWUpIDpcbiAgICAgICAgICAgIGluZGV4ZWREQi5vcGVuKGRiTmFtZSwgTWF0aC5yb3VuZChkYi52ZXJubyAqIDEwKSk7XG4gICAgICAgIGlmICghcmVxKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTWlzc2luZ0FQSSgpO1xuICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICByZXEub25ibG9ja2VkID0gd3JhcChkYi5fZmlyZU9uQmxvY2tlZCk7XG4gICAgICAgIHJlcS5vbnVwZ3JhZGVuZWVkZWQgPSB3cmFwKGUgPT4ge1xuICAgICAgICAgICAgdXBncmFkZVRyYW5zYWN0aW9uID0gcmVxLnRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgaWYgKHN0YXRlLmF1dG9TY2hlbWEgJiYgIWRiLl9vcHRpb25zLmFsbG93RW1wdHlEQikge1xuICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gcHJldmVudERlZmF1bHQ7XG4gICAgICAgICAgICAgICAgdXBncmFkZVRyYW5zYWN0aW9uLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgcmVxLnJlc3VsdC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbHJlcSA9IGluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShkYk5hbWUpO1xuICAgICAgICAgICAgICAgIGRlbHJlcS5vbnN1Y2Nlc3MgPSBkZWxyZXEub25lcnJvciA9IHdyYXAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IGV4Y2VwdGlvbnMuTm9TdWNoRGF0YWJhc2UoYERhdGFiYXNlICR7ZGJOYW1lfSBkb2VzbnQgZXhpc3RgKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24ub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgICAgIHZhciBvbGRWZXIgPSBlLm9sZFZlcnNpb24gPiBNYXRoLnBvdygyLCA2MikgPyAwIDogZS5vbGRWZXJzaW9uO1xuICAgICAgICAgICAgICAgIHdhc0NyZWF0ZWQgPSBvbGRWZXIgPCAxO1xuICAgICAgICAgICAgICAgIGRiLl9ub3ZpcC5pZGJkYiA9IHJlcS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgcnVuVXBncmFkZXJzKGRiLCBvbGRWZXIgLyAxMCwgdXBncmFkZVRyYW5zYWN0aW9uLCByZWplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICByZXEub25zdWNjZXNzID0gd3JhcCgoKSA9PiB7XG4gICAgICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgaWRiZGIgPSBkYi5fbm92aXAuaWRiZGIgPSByZXEucmVzdWx0O1xuICAgICAgICAgICAgY29uc3Qgb2JqZWN0U3RvcmVOYW1lcyA9IHNsaWNlKGlkYmRiLm9iamVjdFN0b3JlTmFtZXMpO1xuICAgICAgICAgICAgaWYgKG9iamVjdFN0b3JlTmFtZXMubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0bXBUcmFucyA9IGlkYmRiLnRyYW5zYWN0aW9uKHNhZmFyaU11bHRpU3RvcmVGaXgob2JqZWN0U3RvcmVOYW1lcyksICdyZWFkb25seScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuYXV0b1NjaGVtYSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRHbG9iYWxTY2hlbWEoZGIsIGlkYmRiLCB0bXBUcmFucyk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRqdXN0VG9FeGlzdGluZ0luZGV4TmFtZXMoZGIsIGRiLl9kYlNjaGVtYSwgdG1wVHJhbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2ZXJpZnlJbnN0YWxsZWRTY2hlbWEoZGIsIHRtcFRyYW5zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRGV4aWUgU2NoZW1hRGlmZjogU2NoZW1hIHdhcyBleHRlbmRlZCB3aXRob3V0IGluY3JlYXNpbmcgdGhlIG51bWJlciBwYXNzZWQgdG8gZGIudmVyc2lvbigpLiBTb21lIHF1ZXJpZXMgbWF5IGZhaWwuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVNaWRkbGV3YXJlU3RhY2tzKGRiLCB0bXBUcmFucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29ubmVjdGlvbnMucHVzaChkYik7XG4gICAgICAgICAgICBpZGJkYi5vbnZlcnNpb25jaGFuZ2UgPSB3cmFwKGV2ID0+IHtcbiAgICAgICAgICAgICAgICBzdGF0ZS52Y0ZpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBkYi5vbihcInZlcnNpb25jaGFuZ2VcIikuZmlyZShldik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlkYmRiLm9uY2xvc2UgPSB3cmFwKGV2ID0+IHtcbiAgICAgICAgICAgICAgICBkYi5vbihcImNsb3NlXCIpLmZpcmUoZXYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAod2FzQ3JlYXRlZClcbiAgICAgICAgICAgICAgICBfb25EYXRhYmFzZUNyZWF0ZWQoZGIuX2RlcHMsIGRiTmFtZSk7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgaWYgKGVyciAmJiBlcnIubmFtZSA9PT0gJ1Vua25vd25FcnJvcicgJiYgc3RhdGUuUFIxMzk4X21heExvb3AgPiAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5QUjEzOThfbWF4TG9vcC0tO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdEZXhpZTogV29ya2Fyb3VuZCBmb3IgQ2hyb21lIFVua25vd25FcnJvciBvbiBvcGVuKCknKTtcbiAgICAgICAgICAgIHJldHVybiB0cnlPcGVuREIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJhY2UoW1xuICAgICAgICBvcGVuQ2FuY2VsbGVyLFxuICAgICAgICAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgPyBEZXhpZVByb21pc2UucmVzb2x2ZSgpIDogaWRiUmVhZHkoKSkudGhlbih0cnlPcGVuREIpXG4gICAgXSkudGhlbigoKSA9PiB7XG4gICAgICAgIHRocm93SWZDYW5jZWxsZWQoKTtcbiAgICAgICAgc3RhdGUub25SZWFkeUJlaW5nRmlyZWQgPSBbXTtcbiAgICAgICAgcmV0dXJuIERleGllUHJvbWlzZS5yZXNvbHZlKHZpcCgoKSA9PiBkYi5vbi5yZWFkeS5maXJlKGRiLnZpcCkpKS50aGVuKGZ1bmN0aW9uIGZpcmVSZW1haW5kZXJzKCkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVtYWluZGVycyA9IHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkLnJlZHVjZShwcm9taXNhYmxlQ2hhaW4sIG5vcCk7XG4gICAgICAgICAgICAgICAgc3RhdGUub25SZWFkeUJlaW5nRmlyZWQgPSBbXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUodmlwKCgpID0+IHJlbWFpbmRlcnMoZGIudmlwKSkpLnRoZW4oZmlyZVJlbWFpbmRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgc3RhdGUub25SZWFkeUJlaW5nRmlyZWQgPSBudWxsO1xuICAgICAgICBzdGF0ZS5pc0JlaW5nT3BlbmVkID0gZmFsc2U7XG4gICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiBkYjtcbiAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICBzdGF0ZS5kYk9wZW5FcnJvciA9IGVycjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHVwZ3JhZGVUcmFuc2FjdGlvbiAmJiB1cGdyYWRlVHJhbnNhY3Rpb24uYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHsgfVxuICAgICAgICBpZiAob3BlbkNhbmNlbGxlciA9PT0gc3RhdGUub3BlbkNhbmNlbGxlcikge1xuICAgICAgICAgICAgZGIuX2Nsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlcnIpO1xuICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICBzdGF0ZS5vcGVuQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICByZXNvbHZlRGJSZWFkeSgpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBhd2FpdEl0ZXJhdG9yKGl0ZXJhdG9yKSB7XG4gICAgdmFyIGNhbGxOZXh0ID0gcmVzdWx0ID0+IGl0ZXJhdG9yLm5leHQocmVzdWx0KSwgZG9UaHJvdyA9IGVycm9yID0+IGl0ZXJhdG9yLnRocm93KGVycm9yKSwgb25TdWNjZXNzID0gc3RlcChjYWxsTmV4dCksIG9uRXJyb3IgPSBzdGVwKGRvVGhyb3cpO1xuICAgIGZ1bmN0aW9uIHN0ZXAoZ2V0TmV4dCkge1xuICAgICAgICByZXR1cm4gKHZhbCkgPT4ge1xuICAgICAgICAgICAgdmFyIG5leHQgPSBnZXROZXh0KHZhbCksIHZhbHVlID0gbmV4dC52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0LmRvbmUgPyB2YWx1ZSA6XG4gICAgICAgICAgICAgICAgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUudGhlbiAhPT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICAgICAgICAgIGlzQXJyYXkodmFsdWUpID8gUHJvbWlzZS5hbGwodmFsdWUpLnRoZW4ob25TdWNjZXNzLCBvbkVycm9yKSA6IG9uU3VjY2Vzcyh2YWx1ZSkgOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS50aGVuKG9uU3VjY2Vzcywgb25FcnJvcikpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gc3RlcChjYWxsTmV4dCkoKTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdFRyYW5zYWN0aW9uQXJncyhtb2RlLCBfdGFibGVBcmdzXywgc2NvcGVGdW5jKSB7XG4gICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmIChpIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiVG9vIGZldyBhcmd1bWVudHNcIik7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoaSAtIDEpO1xuICAgIHdoaWxlICgtLWkpXG4gICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIHNjb3BlRnVuYyA9IGFyZ3MucG9wKCk7XG4gICAgdmFyIHRhYmxlcyA9IGZsYXR0ZW4oYXJncyk7XG4gICAgcmV0dXJuIFttb2RlLCB0YWJsZXMsIHNjb3BlRnVuY107XG59XG5mdW5jdGlvbiBlbnRlclRyYW5zYWN0aW9uU2NvcGUoZGIsIG1vZGUsIHN0b3JlTmFtZXMsIHBhcmVudFRyYW5zYWN0aW9uLCBzY29wZUZ1bmMpIHtcbiAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgY29uc3QgdHJhbnNsZXNzID0gUFNELnRyYW5zbGVzcyB8fCBQU0Q7XG4gICAgICAgIGNvbnN0IHRyYW5zID0gZGIuX2NyZWF0ZVRyYW5zYWN0aW9uKG1vZGUsIHN0b3JlTmFtZXMsIGRiLl9kYlNjaGVtYSwgcGFyZW50VHJhbnNhY3Rpb24pO1xuICAgICAgICBjb25zdCB6b25lUHJvcHMgPSB7XG4gICAgICAgICAgICB0cmFuczogdHJhbnMsXG4gICAgICAgICAgICB0cmFuc2xlc3M6IHRyYW5zbGVzc1xuICAgICAgICB9O1xuICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIHRyYW5zLmlkYnRyYW5zID0gcGFyZW50VHJhbnNhY3Rpb24uaWRidHJhbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRyYW5zLmNyZWF0ZSgpO1xuICAgICAgICAgICAgICAgIGRiLl9zdGF0ZS5QUjEzOThfbWF4TG9vcCA9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXgubmFtZSA9PT0gZXJybmFtZXMuSW52YWxpZFN0YXRlICYmIGRiLmlzT3BlbigpICYmIC0tZGIuX3N0YXRlLlBSMTM5OF9tYXhMb29wID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RleGllOiBOZWVkIHRvIHJlb3BlbiBkYicpO1xuICAgICAgICAgICAgICAgICAgICBkYi5fY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRiLm9wZW4oKS50aGVuKCgpID0+IGVudGVyVHJhbnNhY3Rpb25TY29wZShkYiwgbW9kZSwgc3RvcmVOYW1lcywgbnVsbCwgc2NvcGVGdW5jKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjb3BlRnVuY0lzQXN5bmMgPSBpc0FzeW5jRnVuY3Rpb24oc2NvcGVGdW5jKTtcbiAgICAgICAgaWYgKHNjb3BlRnVuY0lzQXN5bmMpIHtcbiAgICAgICAgICAgIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJldHVyblZhbHVlO1xuICAgICAgICBjb25zdCBwcm9taXNlRm9sbG93ZWQgPSBEZXhpZVByb21pc2UuZm9sbG93KCgpID0+IHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gc2NvcGVGdW5jLmNhbGwodHJhbnMsIHRyYW5zKTtcbiAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzY29wZUZ1bmNJc0FzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWNyZW1lbnRvciA9IGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzLmJpbmQobnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlLnRoZW4oZGVjcmVtZW50b3IsIGRlY3JlbWVudG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJldHVyblZhbHVlLm5leHQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHJldHVyblZhbHVlLnRocm93ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gYXdhaXRJdGVyYXRvcihyZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB6b25lUHJvcHMpO1xuICAgICAgICByZXR1cm4gKHJldHVyblZhbHVlICYmIHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgIERleGllUHJvbWlzZS5yZXNvbHZlKHJldHVyblZhbHVlKS50aGVuKHggPT4gdHJhbnMuYWN0aXZlID9cbiAgICAgICAgICAgICAgICB4XG4gICAgICAgICAgICAgICAgOiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuUHJlbWF0dXJlQ29tbWl0KFwiVHJhbnNhY3Rpb24gY29tbWl0dGVkIHRvbyBlYXJseS4gU2VlIGh0dHA6Ly9iaXQubHkvMmtkY2tNblwiKSkpXG4gICAgICAgICAgICA6IHByb21pc2VGb2xsb3dlZC50aGVuKCgpID0+IHJldHVyblZhbHVlKSkudGhlbih4ID0+IHtcbiAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbilcbiAgICAgICAgICAgICAgICB0cmFucy5fcmVzb2x2ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zLl9jb21wbGV0aW9uLnRoZW4oKCkgPT4geCk7XG4gICAgICAgIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgdHJhbnMuX3JlamVjdChlKTtcbiAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBwYWQoYSwgdmFsdWUsIGNvdW50KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gaXNBcnJheShhKSA/IGEuc2xpY2UoKSA6IFthXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyArK2kpXG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY3JlYXRlVmlydHVhbEluZGV4TWlkZGxld2FyZShkb3duKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZG93bixcbiAgICAgICAgdGFibGUodGFibGVOYW1lKSB7XG4gICAgICAgICAgICBjb25zdCB0YWJsZSA9IGRvd24udGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IHsgc2NoZW1hIH0gPSB0YWJsZTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4TG9va3VwID0ge307XG4gICAgICAgICAgICBjb25zdCBhbGxWaXJ0dWFsSW5kZXhlcyA9IFtdO1xuICAgICAgICAgICAgZnVuY3Rpb24gYWRkVmlydHVhbEluZGV4ZXMoa2V5UGF0aCwga2V5VGFpbCwgbG93TGV2ZWxJbmRleCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleVBhdGhBbGlhcyA9IGdldEtleVBhdGhBbGlhcyhrZXlQYXRoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleExpc3QgPSAoaW5kZXhMb29rdXBba2V5UGF0aEFsaWFzXSA9IGluZGV4TG9va3VwW2tleVBhdGhBbGlhc10gfHwgW10pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleUxlbmd0aCA9IGtleVBhdGggPT0gbnVsbCA/IDAgOiB0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycgPyAxIDoga2V5UGF0aC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNWaXJ0dWFsID0ga2V5VGFpbCA+IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlydHVhbEluZGV4ID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5sb3dMZXZlbEluZGV4LFxuICAgICAgICAgICAgICAgICAgICBpc1ZpcnR1YWwsXG4gICAgICAgICAgICAgICAgICAgIGtleVRhaWwsXG4gICAgICAgICAgICAgICAgICAgIGtleUxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFjdEtleTogZ2V0S2V5RXh0cmFjdG9yKGtleVBhdGgpLFxuICAgICAgICAgICAgICAgICAgICB1bmlxdWU6ICFpc1ZpcnR1YWwgJiYgbG93TGV2ZWxJbmRleC51bmlxdWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGluZGV4TGlzdC5wdXNoKHZpcnR1YWxJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKCF2aXJ0dWFsSW5kZXguaXNQcmltYXJ5S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbFZpcnR1YWxJbmRleGVzLnB1c2godmlydHVhbEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGtleUxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmlydHVhbEtleVBhdGggPSBrZXlMZW5ndGggPT09IDIgP1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5UGF0aFswXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlQYXRoLnNsaWNlKDAsIGtleUxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBhZGRWaXJ0dWFsSW5kZXhlcyh2aXJ0dWFsS2V5UGF0aCwga2V5VGFpbCArIDEsIGxvd0xldmVsSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmRleExpc3Quc29ydCgoYSwgYikgPT4gYS5rZXlUYWlsIC0gYi5rZXlUYWlsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlydHVhbEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJpbWFyeUtleSA9IGFkZFZpcnR1YWxJbmRleGVzKHNjaGVtYS5wcmltYXJ5S2V5LmtleVBhdGgsIDAsIHNjaGVtYS5wcmltYXJ5S2V5KTtcbiAgICAgICAgICAgIGluZGV4TG9va3VwW1wiOmlkXCJdID0gW3ByaW1hcnlLZXldO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBzY2hlbWEuaW5kZXhlcykge1xuICAgICAgICAgICAgICAgIGFkZFZpcnR1YWxJbmRleGVzKGluZGV4LmtleVBhdGgsIDAsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmRCZXN0SW5kZXgoa2V5UGF0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGluZGV4TG9va3VwW2dldEtleVBhdGhBbGlhcyhrZXlQYXRoKV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCAmJiByZXN1bHRbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiB0cmFuc2xhdGVSYW5nZShyYW5nZSwga2V5VGFpbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHJhbmdlLnR5cGUgPT09IDEgID9cbiAgICAgICAgICAgICAgICAgICAgICAgIDIgIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGxvd2VyOiBwYWQocmFuZ2UubG93ZXIsIHJhbmdlLmxvd2VyT3BlbiA/IGRvd24uTUFYX0tFWSA6IGRvd24uTUlOX0tFWSwga2V5VGFpbCksXG4gICAgICAgICAgICAgICAgICAgIGxvd2VyT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdXBwZXI6IHBhZChyYW5nZS51cHBlciwgcmFuZ2UudXBwZXJPcGVuID8gZG93bi5NSU5fS0VZIDogZG93bi5NQVhfS0VZLCBrZXlUYWlsKSxcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJPcGVuOiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZVJlcXVlc3QocmVxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSByZXEucXVlcnkuaW5kZXg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4LmlzVmlydHVhbCA/IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucmVxLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogdHJhbnNsYXRlUmFuZ2UocmVxLnF1ZXJ5LnJhbmdlLCBpbmRleC5rZXlUYWlsKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSA6IHJlcTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAuLi50YWJsZSxcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uc2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICBwcmltYXJ5S2V5LFxuICAgICAgICAgICAgICAgICAgICBpbmRleGVzOiBhbGxWaXJ0dWFsSW5kZXhlcyxcbiAgICAgICAgICAgICAgICAgICAgZ2V0SW5kZXhCeUtleVBhdGg6IGZpbmRCZXN0SW5kZXhcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvdW50KHJlcSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUuY291bnQodHJhbnNsYXRlUmVxdWVzdChyZXEpKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHF1ZXJ5KHJlcSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUucXVlcnkodHJhbnNsYXRlUmVxdWVzdChyZXEpKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9wZW5DdXJzb3IocmVxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsga2V5VGFpbCwgaXNWaXJ0dWFsLCBrZXlMZW5ndGggfSA9IHJlcS5xdWVyeS5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZpcnR1YWwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUub3BlbkN1cnNvcihyZXEpO1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVWaXJ0dWFsQ3Vyc29yKGN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2NvbnRpbnVlKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSAhPSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKHBhZChrZXksIHJlcS5yZXZlcnNlID8gZG93bi5NQVhfS0VZIDogZG93bi5NSU5fS0VZLCBrZXlUYWlsKSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEudW5pcXVlID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZShjdXJzb3Iua2V5LnNsaWNlKDAsIGtleUxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHJlcS5yZXZlcnNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBkb3duLk1JTl9LRVlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGRvd24uTUFYX0tFWSwga2V5VGFpbCkpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmlydHVhbEN1cnNvciA9IE9iamVjdC5jcmVhdGUoY3Vyc29yLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU6IHsgdmFsdWU6IF9jb250aW51ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlUHJpbWFyeUtleToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZShrZXksIHByaW1hcnlLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZVByaW1hcnlLZXkocGFkKGtleSwgZG93bi5NQVhfS0VZLCBrZXlUYWlsKSwgcHJpbWFyeUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlLZXk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnNvci5wcmltYXJ5S2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gY3Vyc29yLmtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlMZW5ndGggPT09IDEgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleVswXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5LnNsaWNlKDAsIGtleUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJzb3IudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2aXJ0dWFsQ3Vyc29yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZS5vcGVuQ3Vyc29yKHRyYW5zbGF0ZVJlcXVlc3QocmVxKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGN1cnNvciA9PiBjdXJzb3IgJiYgY3JlYXRlVmlydHVhbEN1cnNvcihjdXJzb3IpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH07XG59XG5jb25zdCB2aXJ0dWFsSW5kZXhNaWRkbGV3YXJlID0ge1xuICAgIHN0YWNrOiBcImRiY29yZVwiLFxuICAgIG5hbWU6IFwiVmlydHVhbEluZGV4TWlkZGxld2FyZVwiLFxuICAgIGxldmVsOiAxLFxuICAgIGNyZWF0ZTogY3JlYXRlVmlydHVhbEluZGV4TWlkZGxld2FyZVxufTtcblxuZnVuY3Rpb24gZ2V0T2JqZWN0RGlmZihhLCBiLCBydiwgcHJmeCkge1xuICAgIHJ2ID0gcnYgfHwge307XG4gICAgcHJmeCA9IHByZnggfHwgJyc7XG4gICAga2V5cyhhKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgIGlmICghaGFzT3duKGIsIHByb3ApKSB7XG4gICAgICAgICAgICBydltwcmZ4ICsgcHJvcF0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYXAgPSBhW3Byb3BdLCBicCA9IGJbcHJvcF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFwID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYnAgPT09ICdvYmplY3QnICYmIGFwICYmIGJwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXBUeXBlTmFtZSA9IHRvU3RyaW5nVGFnKGFwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBicFR5cGVOYW1lID0gdG9TdHJpbmdUYWcoYnApO1xuICAgICAgICAgICAgICAgIGlmIChhcFR5cGVOYW1lICE9PSBicFR5cGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ2W3ByZnggKyBwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFwVHlwZU5hbWUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldE9iamVjdERpZmYoYXAsIGJwLCBydiwgcHJmeCArIHByb3AgKyAnLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhcCAhPT0gYnApIHtcbiAgICAgICAgICAgICAgICAgICAgcnZbcHJmeCArIHByb3BdID0gYltwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhcCAhPT0gYnApXG4gICAgICAgICAgICAgICAgcnZbcHJmeCArIHByb3BdID0gYltwcm9wXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGtleXMoYikuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICBpZiAoIWhhc093bihhLCBwcm9wKSkge1xuICAgICAgICAgICAgcnZbcHJmeCArIHByb3BdID0gYltwcm9wXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBydjtcbn1cblxuZnVuY3Rpb24gZ2V0RWZmZWN0aXZlS2V5cyhwcmltYXJ5S2V5LCByZXEpIHtcbiAgICBpZiAocmVxLnR5cGUgPT09ICdkZWxldGUnKVxuICAgICAgICByZXR1cm4gcmVxLmtleXM7XG4gICAgcmV0dXJuIHJlcS5rZXlzIHx8IHJlcS52YWx1ZXMubWFwKHByaW1hcnlLZXkuZXh0cmFjdEtleSk7XG59XG5cbmNvbnN0IGhvb2tzTWlkZGxld2FyZSA9IHtcbiAgICBzdGFjazogXCJkYmNvcmVcIixcbiAgICBuYW1lOiBcIkhvb2tzTWlkZGxld2FyZVwiLFxuICAgIGxldmVsOiAyLFxuICAgIGNyZWF0ZTogKGRvd25Db3JlKSA9PiAoe1xuICAgICAgICAuLi5kb3duQ29yZSxcbiAgICAgICAgdGFibGUodGFibGVOYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBkb3duVGFibGUgPSBkb3duQ29yZS50YWJsZSh0YWJsZU5hbWUpO1xuICAgICAgICAgICAgY29uc3QgeyBwcmltYXJ5S2V5IH0gPSBkb3duVGFibGUuc2NoZW1hO1xuICAgICAgICAgICAgY29uc3QgdGFibGVNaWRkbGV3YXJlID0ge1xuICAgICAgICAgICAgICAgIC4uLmRvd25UYWJsZSxcbiAgICAgICAgICAgICAgICBtdXRhdGUocmVxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGR4VHJhbnMgPSBQU0QudHJhbnM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGVsZXRpbmcsIGNyZWF0aW5nLCB1cGRhdGluZyB9ID0gZHhUcmFucy50YWJsZSh0YWJsZU5hbWUpLmhvb2s7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocmVxLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FkZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNyZWF0aW5nLmZpcmUgPT09IG5vcClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR4VHJhbnMuX3Byb21pc2UoJ3JlYWR3cml0ZScsICgpID0+IGFkZFB1dE9yRGVsZXRlKHJlcSksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncHV0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3JlYXRpbmcuZmlyZSA9PT0gbm9wICYmIHVwZGF0aW5nLmZpcmUgPT09IG5vcClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR4VHJhbnMuX3Byb21pc2UoJ3JlYWR3cml0ZScsICgpID0+IGFkZFB1dE9yRGVsZXRlKHJlcSksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGVsZXRlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVsZXRpbmcuZmlyZSA9PT0gbm9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHhUcmFucy5fcHJvbWlzZSgncmVhZHdyaXRlJywgKCkgPT4gYWRkUHV0T3JEZWxldGUocmVxKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdkZWxldGVSYW5nZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGV0aW5nLmZpcmUgPT09IG5vcClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR4VHJhbnMuX3Byb21pc2UoJ3JlYWR3cml0ZScsICgpID0+IGRlbGV0ZVJhbmdlKHJlcSksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb3duVGFibGUubXV0YXRlKHJlcSk7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGFkZFB1dE9yRGVsZXRlKHJlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZHhUcmFucyA9IFBTRC50cmFucztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSByZXEua2V5cyB8fCBnZXRFZmZlY3RpdmVLZXlzKHByaW1hcnlLZXksIHJlcSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWtleXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5cyBtaXNzaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxID0gcmVxLnR5cGUgPT09ICdhZGQnIHx8IHJlcS50eXBlID09PSAncHV0JyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyAuLi5yZXEsIGtleXMgfSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyAuLi5yZXEgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXEudHlwZSAhPT0gJ2RlbGV0ZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnZhbHVlcyA9IFsuLi5yZXEudmFsdWVzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXEua2V5cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEua2V5cyA9IFsuLi5yZXEua2V5c107XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RXhpc3RpbmdWYWx1ZXMoZG93blRhYmxlLCByZXEsIGtleXMpLnRoZW4oZXhpc3RpbmdWYWx1ZXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRleHRzID0ga2V5cy5tYXAoKGtleSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ1ZhbHVlID0gZXhpc3RpbmdWYWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IHsgb25lcnJvcjogbnVsbCwgb25zdWNjZXNzOiBudWxsIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXEudHlwZSA9PT0gJ2RlbGV0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0aW5nLmZpcmUuY2FsbChjdHgsIGtleSwgZXhpc3RpbmdWYWx1ZSwgZHhUcmFucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVxLnR5cGUgPT09ICdhZGQnIHx8IGV4aXN0aW5nVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJhdGVkUHJpbWFyeUtleSA9IGNyZWF0aW5nLmZpcmUuY2FsbChjdHgsIGtleSwgcmVxLnZhbHVlc1tpXSwgZHhUcmFucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09IG51bGwgJiYgZ2VuZXJhdGVkUHJpbWFyeUtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gZ2VuZXJhdGVkUHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEua2V5c1tpXSA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXByaW1hcnlLZXkub3V0Ym91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKHJlcS52YWx1ZXNbaV0sIHByaW1hcnlLZXkua2V5UGF0aCwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvYmplY3REaWZmID0gZ2V0T2JqZWN0RGlmZihleGlzdGluZ1ZhbHVlLCByZXEudmFsdWVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFkZGl0aW9uYWxDaGFuZ2VzID0gdXBkYXRpbmcuZmlyZS5jYWxsKGN0eCwgb2JqZWN0RGlmZiwga2V5LCBleGlzdGluZ1ZhbHVlLCBkeFRyYW5zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGRpdGlvbmFsQ2hhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RlZFZhbHVlID0gcmVxLnZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhhZGRpdGlvbmFsQ2hhbmdlcykuZm9yRWFjaChrZXlQYXRoID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc093bihyZXF1ZXN0ZWRWYWx1ZSwga2V5UGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RlZFZhbHVlW2tleVBhdGhdID0gYWRkaXRpb25hbENoYW5nZXNba2V5UGF0aF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRCeUtleVBhdGgocmVxdWVzdGVkVmFsdWUsIGtleVBhdGgsIGFkZGl0aW9uYWxDaGFuZ2VzW2tleVBhdGhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvd25UYWJsZS5tdXRhdGUocmVxKS50aGVuKCh7IGZhaWx1cmVzLCByZXN1bHRzLCBudW1GYWlsdXJlcywgbGFzdFJlc3VsdCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJpbUtleSA9IHJlc3VsdHMgPyByZXN1bHRzW2ldIDoga2V5c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNvbnRleHRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByaW1LZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5vbmVycm9yICYmIGN0eC5vbmVycm9yKGZhaWx1cmVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5vbnN1Y2Nlc3MgJiYgY3R4Lm9uc3VjY2VzcyhyZXEudHlwZSA9PT0gJ3B1dCcgJiYgZXhpc3RpbmdWYWx1ZXNbaV0gP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEudmFsdWVzW2ldIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbUtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZmFpbHVyZXMsIHJlc3VsdHMsIG51bUZhaWx1cmVzLCBsYXN0UmVzdWx0IH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0cy5mb3JFYWNoKGN0eCA9PiBjdHgub25lcnJvciAmJiBjdHgub25lcnJvcihlcnJvcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZGVsZXRlUmFuZ2UocmVxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVsZXRlTmV4dENodW5rKHJlcS50cmFucywgcmVxLnJhbmdlLCAxMDAwMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZGVsZXRlTmV4dENodW5rKHRyYW5zLCByYW5nZSwgbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb3duVGFibGUucXVlcnkoeyB0cmFucywgdmFsdWVzOiBmYWxzZSwgcXVlcnk6IHsgaW5kZXg6IHByaW1hcnlLZXksIHJhbmdlIH0sIGxpbWl0IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHsgcmVzdWx0IH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkUHV0T3JEZWxldGUoeyB0eXBlOiAnZGVsZXRlJywga2V5czogcmVzdWx0LCB0cmFucyB9KS50aGVuKHJlcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXMubnVtRmFpbHVyZXMgPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoIDwgbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGZhaWx1cmVzOiBbXSwgbnVtRmFpbHVyZXM6IDAsIGxhc3RSZXN1bHQ6IHVuZGVmaW5lZCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZU5leHRDaHVuayh0cmFucywgeyAuLi5yYW5nZSwgbG93ZXI6IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0sIGxvd2VyT3BlbjogdHJ1ZSB9LCBsaW1pdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0YWJsZU1pZGRsZXdhcmU7XG4gICAgICAgIH0sXG4gICAgfSlcbn07XG5mdW5jdGlvbiBnZXRFeGlzdGluZ1ZhbHVlcyh0YWJsZSwgcmVxLCBlZmZlY3RpdmVLZXlzKSB7XG4gICAgcmV0dXJuIHJlcS50eXBlID09PSBcImFkZFwiXG4gICAgICAgID8gUHJvbWlzZS5yZXNvbHZlKFtdKVxuICAgICAgICA6IHRhYmxlLmdldE1hbnkoeyB0cmFuczogcmVxLnRyYW5zLCBrZXlzOiBlZmZlY3RpdmVLZXlzLCBjYWNoZTogXCJpbW11dGFibGVcIiB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0RnJvbVRyYW5zYWN0aW9uQ2FjaGUoa2V5cywgY2FjaGUsIGNsb25lKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKCFjYWNoZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoY2FjaGUua2V5cy5sZW5ndGggPCBrZXlzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgY2FjaGUua2V5cy5sZW5ndGggJiYgaiA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChjbXAoY2FjaGUua2V5c1tpXSwga2V5c1tqXSkgIT09IDApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjbG9uZSA/IGRlZXBDbG9uZShjYWNoZS52YWx1ZXNbaV0pIDogY2FjaGUudmFsdWVzW2ldKTtcbiAgICAgICAgICAgICsrajtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0ga2V5cy5sZW5ndGggPyByZXN1bHQgOiBudWxsO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuY29uc3QgY2FjaGVFeGlzdGluZ1ZhbHVlc01pZGRsZXdhcmUgPSB7XG4gICAgc3RhY2s6IFwiZGJjb3JlXCIsXG4gICAgbGV2ZWw6IC0xLFxuICAgIGNyZWF0ZTogKGNvcmUpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRhYmxlOiAodGFibGVOYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGUgPSBjb3JlLnRhYmxlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4udGFibGUsXG4gICAgICAgICAgICAgICAgICAgIGdldE1hbnk6IChyZXEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVxLmNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLmdldE1hbnkocmVxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlZFJlc3VsdCA9IGdldEZyb21UcmFuc2FjdGlvbkNhY2hlKHJlcS5rZXlzLCByZXEudHJhbnNbXCJfY2FjaGVcIl0sIHJlcS5jYWNoZSA9PT0gXCJjbG9uZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGV4aWVQcm9taXNlLnJlc29sdmUoY2FjaGVkUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZS5nZXRNYW55KHJlcSkudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnRyYW5zW1wiX2NhY2hlXCJdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzOiByZXEua2V5cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiByZXEuY2FjaGUgPT09IFwiY2xvbmVcIiA/IGRlZXBDbG9uZShyZXMpIDogcmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBtdXRhdGU6IChyZXEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXEudHlwZSAhPT0gXCJhZGRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEudHJhbnNbXCJfY2FjaGVcIl0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLm11dGF0ZShyZXEpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG59O1xuXG5mdW5jdGlvbiBpc0VtcHR5UmFuZ2Uobm9kZSkge1xuICAgIHJldHVybiAhKFwiZnJvbVwiIGluIG5vZGUpO1xufVxuY29uc3QgUmFuZ2VTZXQgPSBmdW5jdGlvbiAoZnJvbU9yVHJlZSwgdG8pIHtcbiAgICBpZiAodGhpcykge1xuICAgICAgICBleHRlbmQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IHsgZDogMSwgZnJvbTogZnJvbU9yVHJlZSwgdG86IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gdG8gOiBmcm9tT3JUcmVlIH0gOiB7IGQ6IDAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBydiA9IG5ldyBSYW5nZVNldCgpO1xuICAgICAgICBpZiAoZnJvbU9yVHJlZSAmJiAoXCJkXCIgaW4gZnJvbU9yVHJlZSkpIHtcbiAgICAgICAgICAgIGV4dGVuZChydiwgZnJvbU9yVHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgIH1cbn07XG5wcm9wcyhSYW5nZVNldC5wcm90b3R5cGUsIHtcbiAgICBhZGQocmFuZ2VTZXQpIHtcbiAgICAgICAgbWVyZ2VSYW5nZXModGhpcywgcmFuZ2VTZXQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGFkZEtleShrZXkpIHtcbiAgICAgICAgYWRkUmFuZ2UodGhpcywga2V5LCBrZXkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGFkZEtleXMoa2V5cykge1xuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZFJhbmdlKHRoaXMsIGtleSwga2V5KSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgW2l0ZXJhdG9yU3ltYm9sXSgpIHtcbiAgICAgICAgcmV0dXJuIGdldFJhbmdlU2V0SXRlcmF0b3IodGhpcyk7XG4gICAgfVxufSk7XG5mdW5jdGlvbiBhZGRSYW5nZSh0YXJnZXQsIGZyb20sIHRvKSB7XG4gICAgY29uc3QgZGlmZiA9IGNtcChmcm9tLCB0byk7XG4gICAgaWYgKGlzTmFOKGRpZmYpKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGRpZmYgPiAwKVxuICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCk7XG4gICAgaWYgKGlzRW1wdHlSYW5nZSh0YXJnZXQpKVxuICAgICAgICByZXR1cm4gZXh0ZW5kKHRhcmdldCwgeyBmcm9tLCB0bywgZDogMSB9KTtcbiAgICBjb25zdCBsZWZ0ID0gdGFyZ2V0Lmw7XG4gICAgY29uc3QgcmlnaHQgPSB0YXJnZXQucjtcbiAgICBpZiAoY21wKHRvLCB0YXJnZXQuZnJvbSkgPCAwKSB7XG4gICAgICAgIGxlZnRcbiAgICAgICAgICAgID8gYWRkUmFuZ2UobGVmdCwgZnJvbSwgdG8pXG4gICAgICAgICAgICA6ICh0YXJnZXQubCA9IHsgZnJvbSwgdG8sIGQ6IDEsIGw6IG51bGwsIHI6IG51bGwgfSk7XG4gICAgICAgIHJldHVybiByZWJhbGFuY2UodGFyZ2V0KTtcbiAgICB9XG4gICAgaWYgKGNtcChmcm9tLCB0YXJnZXQudG8pID4gMCkge1xuICAgICAgICByaWdodFxuICAgICAgICAgICAgPyBhZGRSYW5nZShyaWdodCwgZnJvbSwgdG8pXG4gICAgICAgICAgICA6ICh0YXJnZXQuciA9IHsgZnJvbSwgdG8sIGQ6IDEsIGw6IG51bGwsIHI6IG51bGwgfSk7XG4gICAgICAgIHJldHVybiByZWJhbGFuY2UodGFyZ2V0KTtcbiAgICB9XG4gICAgaWYgKGNtcChmcm9tLCB0YXJnZXQuZnJvbSkgPCAwKSB7XG4gICAgICAgIHRhcmdldC5mcm9tID0gZnJvbTtcbiAgICAgICAgdGFyZ2V0LmwgPSBudWxsO1xuICAgICAgICB0YXJnZXQuZCA9IHJpZ2h0ID8gcmlnaHQuZCArIDEgOiAxO1xuICAgIH1cbiAgICBpZiAoY21wKHRvLCB0YXJnZXQudG8pID4gMCkge1xuICAgICAgICB0YXJnZXQudG8gPSB0bztcbiAgICAgICAgdGFyZ2V0LnIgPSBudWxsO1xuICAgICAgICB0YXJnZXQuZCA9IHRhcmdldC5sID8gdGFyZ2V0LmwuZCArIDEgOiAxO1xuICAgIH1cbiAgICBjb25zdCByaWdodFdhc0N1dE9mZiA9ICF0YXJnZXQucjtcbiAgICBpZiAobGVmdCAmJiAhdGFyZ2V0LmwpIHtcbiAgICAgICAgbWVyZ2VSYW5nZXModGFyZ2V0LCBsZWZ0KTtcbiAgICB9XG4gICAgaWYgKHJpZ2h0ICYmIHJpZ2h0V2FzQ3V0T2ZmKSB7XG4gICAgICAgIG1lcmdlUmFuZ2VzKHRhcmdldCwgcmlnaHQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1lcmdlUmFuZ2VzKHRhcmdldCwgbmV3U2V0KSB7XG4gICAgZnVuY3Rpb24gX2FkZFJhbmdlU2V0KHRhcmdldCwgeyBmcm9tLCB0bywgbCwgciB9KSB7XG4gICAgICAgIGFkZFJhbmdlKHRhcmdldCwgZnJvbSwgdG8pO1xuICAgICAgICBpZiAobClcbiAgICAgICAgICAgIF9hZGRSYW5nZVNldCh0YXJnZXQsIGwpO1xuICAgICAgICBpZiAocilcbiAgICAgICAgICAgIF9hZGRSYW5nZVNldCh0YXJnZXQsIHIpO1xuICAgIH1cbiAgICBpZiAoIWlzRW1wdHlSYW5nZShuZXdTZXQpKVxuICAgICAgICBfYWRkUmFuZ2VTZXQodGFyZ2V0LCBuZXdTZXQpO1xufVxuZnVuY3Rpb24gcmFuZ2VzT3ZlcmxhcChyYW5nZVNldDEsIHJhbmdlU2V0Mikge1xuICAgIGNvbnN0IGkxID0gZ2V0UmFuZ2VTZXRJdGVyYXRvcihyYW5nZVNldDIpO1xuICAgIGxldCBuZXh0UmVzdWx0MSA9IGkxLm5leHQoKTtcbiAgICBpZiAobmV4dFJlc3VsdDEuZG9uZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBhID0gbmV4dFJlc3VsdDEudmFsdWU7XG4gICAgY29uc3QgaTIgPSBnZXRSYW5nZVNldEl0ZXJhdG9yKHJhbmdlU2V0MSk7XG4gICAgbGV0IG5leHRSZXN1bHQyID0gaTIubmV4dChhLmZyb20pO1xuICAgIGxldCBiID0gbmV4dFJlc3VsdDIudmFsdWU7XG4gICAgd2hpbGUgKCFuZXh0UmVzdWx0MS5kb25lICYmICFuZXh0UmVzdWx0Mi5kb25lKSB7XG4gICAgICAgIGlmIChjbXAoYi5mcm9tLCBhLnRvKSA8PSAwICYmIGNtcChiLnRvLCBhLmZyb20pID49IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY21wKGEuZnJvbSwgYi5mcm9tKSA8IDBcbiAgICAgICAgICAgID8gKGEgPSAobmV4dFJlc3VsdDEgPSBpMS5uZXh0KGIuZnJvbSkpLnZhbHVlKVxuICAgICAgICAgICAgOiAoYiA9IChuZXh0UmVzdWx0MiA9IGkyLm5leHQoYS5mcm9tKSkudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRSYW5nZVNldEl0ZXJhdG9yKG5vZGUpIHtcbiAgICBsZXQgc3RhdGUgPSBpc0VtcHR5UmFuZ2Uobm9kZSkgPyBudWxsIDogeyBzOiAwLCBuOiBub2RlIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dChrZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleVByb3ZpZGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICB3aGlsZSAoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0YXRlLnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUucyA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5UHJvdmlkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhdGUubi5sICYmIGNtcChrZXksIHN0YXRlLm4uZnJvbSkgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHsgdXA6IHN0YXRlLCBuOiBzdGF0ZS5uLmwsIHM6IDEgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGF0ZS5uLmwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0geyB1cDogc3RhdGUsIG46IHN0YXRlLm4ubCwgczogMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgha2V5UHJvdmlkZWQgfHwgY21wKGtleSwgc3RhdGUubi50bykgPD0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogc3RhdGUubiwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLm4ucikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnMgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0geyB1cDogc3RhdGUsIG46IHN0YXRlLm4uciwgczogMCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLnVwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gcmViYWxhbmNlKHRhcmdldCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgZGlmZiA9ICgoKF9hID0gdGFyZ2V0LnIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kKSB8fCAwKSAtICgoKF9iID0gdGFyZ2V0LmwpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kKSB8fCAwKTtcbiAgICBjb25zdCByID0gZGlmZiA+IDEgPyBcInJcIiA6IGRpZmYgPCAtMSA/IFwibFwiIDogXCJcIjtcbiAgICBpZiAocikge1xuICAgICAgICBjb25zdCBsID0gciA9PT0gXCJyXCIgPyBcImxcIiA6IFwiclwiO1xuICAgICAgICBjb25zdCByb290Q2xvbmUgPSB7IC4uLnRhcmdldCB9O1xuICAgICAgICBjb25zdCBvbGRSb290UmlnaHQgPSB0YXJnZXRbcl07XG4gICAgICAgIHRhcmdldC5mcm9tID0gb2xkUm9vdFJpZ2h0LmZyb207XG4gICAgICAgIHRhcmdldC50byA9IG9sZFJvb3RSaWdodC50bztcbiAgICAgICAgdGFyZ2V0W3JdID0gb2xkUm9vdFJpZ2h0W3JdO1xuICAgICAgICByb290Q2xvbmVbcl0gPSBvbGRSb290UmlnaHRbbF07XG4gICAgICAgIHRhcmdldFtsXSA9IHJvb3RDbG9uZTtcbiAgICAgICAgcm9vdENsb25lLmQgPSBjb21wdXRlRGVwdGgocm9vdENsb25lKTtcbiAgICB9XG4gICAgdGFyZ2V0LmQgPSBjb21wdXRlRGVwdGgodGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVEZXB0aCh7IHIsIGwgfSkge1xuICAgIHJldHVybiAociA/IChsID8gTWF0aC5tYXgoci5kLCBsLmQpIDogci5kKSA6IGwgPyBsLmQgOiAwKSArIDE7XG59XG5cbmNvbnN0IG9ic2VydmFiaWxpdHlNaWRkbGV3YXJlID0ge1xuICAgIHN0YWNrOiBcImRiY29yZVwiLFxuICAgIGxldmVsOiAwLFxuICAgIGNyZWF0ZTogKGNvcmUpID0+IHtcbiAgICAgICAgY29uc3QgZGJOYW1lID0gY29yZS5zY2hlbWEubmFtZTtcbiAgICAgICAgY29uc3QgRlVMTF9SQU5HRSA9IG5ldyBSYW5nZVNldChjb3JlLk1JTl9LRVksIGNvcmUuTUFYX0tFWSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jb3JlLFxuICAgICAgICAgICAgdGFibGU6ICh0YWJsZU5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGNvcmUudGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNjaGVtYSB9ID0gdGFibGU7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwcmltYXJ5S2V5IH0gPSBzY2hlbWE7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBleHRyYWN0S2V5LCBvdXRib3VuZCB9ID0gcHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZUNsb25lID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi50YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRlOiAocmVxKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFucyA9IHJlcS50cmFucztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG11dGF0ZWRQYXJ0cyA9IHRyYW5zLm11dGF0ZWRQYXJ0cyB8fCAodHJhbnMubXV0YXRlZFBhcnRzID0ge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2V0UmFuZ2VTZXQgPSAoaW5kZXhOYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFydCA9IGBpZGI6Ly8ke2RiTmFtZX0vJHt0YWJsZU5hbWV9LyR7aW5kZXhOYW1lfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChtdXRhdGVkUGFydHNbcGFydF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG11dGF0ZWRQYXJ0c1twYXJ0XSA9IG5ldyBSYW5nZVNldCgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGtSYW5nZVNldCA9IGdldFJhbmdlU2V0KFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVsc1JhbmdlU2V0ID0gZ2V0UmFuZ2VTZXQoXCI6ZGVsc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdHlwZSB9ID0gcmVxO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IFtrZXlzLCBuZXdPYmpzXSA9IHJlcS50eXBlID09PSBcImRlbGV0ZVJhbmdlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFtyZXEucmFuZ2VdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiByZXEudHlwZSA9PT0gXCJkZWxldGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFtyZXEua2V5c11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiByZXEudmFsdWVzLmxlbmd0aCA8IDUwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFtbXSwgcmVxLnZhbHVlc11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogW107XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRDYWNoZSA9IHJlcS50cmFuc1tcIl9jYWNoZVwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZS5tdXRhdGUocmVxKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShrZXlzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gXCJkZWxldGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXMgPSByZXMucmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGtSYW5nZVNldC5hZGRLZXlzKGtleXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRPYmpzID0gZ2V0RnJvbVRyYW5zYWN0aW9uQ2FjaGUoa2V5cywgb2xkQ2FjaGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9sZE9ianMgJiYgdHlwZSAhPT0gXCJhZGRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0LmFkZEtleXMoa2V5cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9sZE9ianMgfHwgbmV3T2Jqcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tBZmZlY3RlZEluZGV4ZXMoZ2V0UmFuZ2VTZXQsIHNjaGVtYSwgb2xkT2JqcywgbmV3T2Jqcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IHsgZnJvbToga2V5cy5sb3dlciwgdG86IGtleXMudXBwZXIgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0LmFkZChyYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBrUmFuZ2VTZXQuYWRkKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBrUmFuZ2VTZXQuYWRkKEZVTExfUkFOR0UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXQuYWRkKEZVTExfUkFOR0UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWEuaW5kZXhlcy5mb3JFYWNoKGlkeCA9PiBnZXRSYW5nZVNldChpZHgubmFtZSkuYWRkKEZVTExfUkFOR0UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgZ2V0UmFuZ2UgPSAoeyBxdWVyeTogeyBpbmRleCwgcmFuZ2UgfSwgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgUmFuZ2VTZXQoKF9hID0gcmFuZ2UubG93ZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvcmUuTUlOX0tFWSwgKF9iID0gcmFuZ2UudXBwZXIpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGNvcmUuTUFYX0tFWSksXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWFkU3Vic2NyaWJlcnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogKHJlcSkgPT4gW3ByaW1hcnlLZXksIG5ldyBSYW5nZVNldChyZXEua2V5KV0sXG4gICAgICAgICAgICAgICAgICAgIGdldE1hbnk6IChyZXEpID0+IFtwcmltYXJ5S2V5LCBuZXcgUmFuZ2VTZXQoKS5hZGRLZXlzKHJlcS5rZXlzKV0sXG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiBnZXRSYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IGdldFJhbmdlLFxuICAgICAgICAgICAgICAgICAgICBvcGVuQ3Vyc29yOiBnZXRSYW5nZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGtleXMocmVhZFN1YnNjcmliZXJzKS5mb3JFYWNoKG1ldGhvZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRhYmxlQ2xvbmVbbWV0aG9kXSA9IGZ1bmN0aW9uIChyZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc3Vic2NyIH0gPSBQU0Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic2NyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2V0UmFuZ2VTZXQgPSAoaW5kZXhOYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnQgPSBgaWRiOi8vJHtkYk5hbWV9LyR7dGFibGVOYW1lfS8ke2luZGV4TmFtZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHN1YnNjcltwYXJ0XSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHN1YnNjcltwYXJ0XSA9IG5ldyBSYW5nZVNldCgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwa1JhbmdlU2V0ID0gZ2V0UmFuZ2VTZXQoXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVsc1JhbmdlU2V0ID0gZ2V0UmFuZ2VTZXQoXCI6ZGVsc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbcXVlcmllZEluZGV4LCBxdWVyaWVkUmFuZ2VzXSA9IHJlYWRTdWJzY3JpYmVyc1ttZXRob2RdKHJlcSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0UmFuZ2VTZXQocXVlcmllZEluZGV4Lm5hbWUgfHwgXCJcIikuYWRkKHF1ZXJpZWRSYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcXVlcmllZEluZGV4LmlzUHJpbWFyeUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSBcImNvdW50XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldC5hZGQoRlVMTF9SQU5HRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlzUHJvbWlzZSA9IG1ldGhvZCA9PT0gXCJxdWVyeVwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0Ym91bmQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEudmFsdWVzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGUucXVlcnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5yZXEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGVbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwicXVlcnlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0Ym91bmQgJiYgcmVxLnZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleXNQcm9taXNlLnRoZW4oKHsgcmVzdWx0OiByZXN1bHRpbmdLZXlzIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwa1JhbmdlU2V0LmFkZEtleXMocmVzdWx0aW5nS2V5cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBLZXlzID0gcmVxLnZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZXMucmVzdWx0Lm1hcChleHRyYWN0S2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiByZXMucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGtSYW5nZVNldC5hZGRLZXlzKHBLZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldC5hZGRLZXlzKHBLZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtZXRob2QgPT09IFwib3BlbkN1cnNvclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnNvciA9IHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2FudFZhbHVlcyA9IHJlcS52YWx1ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoY3Vyc29yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuY3JlYXRlKGN1cnNvciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXQuYWRkS2V5KGN1cnNvci5wcmltYXJ5S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJzb3Iua2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeUtleToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwa2V5ID0gY3Vyc29yLnByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXQuYWRkS2V5KHBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBrZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YW50VmFsdWVzICYmIHBrUmFuZ2VTZXQuYWRkS2V5KGN1cnNvci5wcmltYXJ5S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJzb3IudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlW21ldGhvZF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFibGVDbG9uZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbn07XG5mdW5jdGlvbiB0cmFja0FmZmVjdGVkSW5kZXhlcyhnZXRSYW5nZVNldCwgc2NoZW1hLCBvbGRPYmpzLCBuZXdPYmpzKSB7XG4gICAgZnVuY3Rpb24gYWRkQWZmZWN0ZWRJbmRleChpeCkge1xuICAgICAgICBjb25zdCByYW5nZVNldCA9IGdldFJhbmdlU2V0KGl4Lm5hbWUgfHwgXCJcIik7XG4gICAgICAgIGZ1bmN0aW9uIGV4dHJhY3RLZXkob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqICE9IG51bGwgPyBpeC5leHRyYWN0S2V5KG9iaikgOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFkZEtleU9yS2V5cyA9IChrZXkpID0+IGl4Lm11bHRpRW50cnkgJiYgaXNBcnJheShrZXkpXG4gICAgICAgICAgICA/IGtleS5mb3JFYWNoKGtleSA9PiByYW5nZVNldC5hZGRLZXkoa2V5KSlcbiAgICAgICAgICAgIDogcmFuZ2VTZXQuYWRkS2V5KGtleSk7XG4gICAgICAgIChvbGRPYmpzIHx8IG5ld09ianMpLmZvckVhY2goKF8sIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9sZEtleSA9IG9sZE9ianMgJiYgZXh0cmFjdEtleShvbGRPYmpzW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0tleSA9IG5ld09ianMgJiYgZXh0cmFjdEtleShuZXdPYmpzW2ldKTtcbiAgICAgICAgICAgIGlmIChjbXAob2xkS2V5LCBuZXdLZXkpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9sZEtleSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBhZGRLZXlPcktleXMob2xkS2V5KTtcbiAgICAgICAgICAgICAgICBpZiAobmV3S2V5ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGFkZEtleU9yS2V5cyhuZXdLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2NoZW1hLmluZGV4ZXMuZm9yRWFjaChhZGRBZmZlY3RlZEluZGV4KTtcbn1cblxuY2xhc3MgRGV4aWUkMSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9taWRkbGV3YXJlcyA9IHt9O1xuICAgICAgICB0aGlzLnZlcm5vID0gMDtcbiAgICAgICAgY29uc3QgZGVwcyA9IERleGllJDEuZGVwZW5kZW5jaWVzO1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGFkZG9uczogRGV4aWUkMS5hZGRvbnMsXG4gICAgICAgICAgICBhdXRvT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgIGluZGV4ZWREQjogZGVwcy5pbmRleGVkREIsXG4gICAgICAgICAgICBJREJLZXlSYW5nZTogZGVwcy5JREJLZXlSYW5nZSxcbiAgICAgICAgICAgIC4uLm9wdGlvbnNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZGVwcyA9IHtcbiAgICAgICAgICAgIGluZGV4ZWREQjogb3B0aW9ucy5pbmRleGVkREIsXG4gICAgICAgICAgICBJREJLZXlSYW5nZTogb3B0aW9ucy5JREJLZXlSYW5nZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7IGFkZG9ucywgfSA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuX2RiU2NoZW1hID0ge307XG4gICAgICAgIHRoaXMuX3ZlcnNpb25zID0gW107XG4gICAgICAgIHRoaXMuX3N0b3JlTmFtZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fYWxsVGFibGVzID0ge307XG4gICAgICAgIHRoaXMuaWRiZGIgPSBudWxsO1xuICAgICAgICB0aGlzLl9ub3ZpcCA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICAgICAgZGJPcGVuRXJyb3I6IG51bGwsXG4gICAgICAgICAgICBpc0JlaW5nT3BlbmVkOiBmYWxzZSxcbiAgICAgICAgICAgIG9uUmVhZHlCZWluZ0ZpcmVkOiBudWxsLFxuICAgICAgICAgICAgb3BlbkNvbXBsZXRlOiBmYWxzZSxcbiAgICAgICAgICAgIGRiUmVhZHlSZXNvbHZlOiBub3AsXG4gICAgICAgICAgICBkYlJlYWR5UHJvbWlzZTogbnVsbCxcbiAgICAgICAgICAgIGNhbmNlbE9wZW46IG5vcCxcbiAgICAgICAgICAgIG9wZW5DYW5jZWxsZXI6IG51bGwsXG4gICAgICAgICAgICBhdXRvU2NoZW1hOiB0cnVlLFxuICAgICAgICAgICAgUFIxMzk4X21heExvb3A6IDNcbiAgICAgICAgfTtcbiAgICAgICAgc3RhdGUuZGJSZWFkeVByb21pc2UgPSBuZXcgRGV4aWVQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgc3RhdGUuZGJSZWFkeVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RhdGUub3BlbkNhbmNlbGxlciA9IG5ldyBEZXhpZVByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgc3RhdGUuY2FuY2VsT3BlbiA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMub24gPSBFdmVudHModGhpcywgXCJwb3B1bGF0ZVwiLCBcImJsb2NrZWRcIiwgXCJ2ZXJzaW9uY2hhbmdlXCIsIFwiY2xvc2VcIiwgeyByZWFkeTogW3Byb21pc2FibGVDaGFpbiwgbm9wXSB9KTtcbiAgICAgICAgdGhpcy5vbi5yZWFkeS5zdWJzY3JpYmUgPSBvdmVycmlkZSh0aGlzLm9uLnJlYWR5LnN1YnNjcmliZSwgc3Vic2NyaWJlID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoc3Vic2NyaWJlciwgYlN0aWNreSkgPT4ge1xuICAgICAgICAgICAgICAgIERleGllJDEudmlwKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLm9wZW5Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5kYk9wZW5FcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZXhpZVByb21pc2UucmVzb2x2ZSgpLnRoZW4oc3Vic2NyaWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYlN0aWNreSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUub25SZWFkeUJlaW5nRmlyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkLnB1c2goc3Vic2NyaWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYlN0aWNreSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJTdGlja3kpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlKGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYi5vbi5yZWFkeS51bnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGIub24ucmVhZHkudW5zdWJzY3JpYmUodW5zdWJzY3JpYmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5Db2xsZWN0aW9uID0gY3JlYXRlQ29sbGVjdGlvbkNvbnN0cnVjdG9yKHRoaXMpO1xuICAgICAgICB0aGlzLlRhYmxlID0gY3JlYXRlVGFibGVDb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgdGhpcy5UcmFuc2FjdGlvbiA9IGNyZWF0ZVRyYW5zYWN0aW9uQ29uc3RydWN0b3IodGhpcyk7XG4gICAgICAgIHRoaXMuVmVyc2lvbiA9IGNyZWF0ZVZlcnNpb25Db25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgdGhpcy5XaGVyZUNsYXVzZSA9IGNyZWF0ZVdoZXJlQ2xhdXNlQ29uc3RydWN0b3IodGhpcyk7XG4gICAgICAgIHRoaXMub24oXCJ2ZXJzaW9uY2hhbmdlXCIsIGV2ID0+IHtcbiAgICAgICAgICAgIGlmIChldi5uZXdWZXJzaW9uID4gMClcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEFub3RoZXIgY29ubmVjdGlvbiB3YW50cyB0byB1cGdyYWRlIGRhdGFiYXNlICcke3RoaXMubmFtZX0nLiBDbG9zaW5nIGRiIG5vdyB0byByZXN1bWUgdGhlIHVwZ3JhZGUuYCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBBbm90aGVyIGNvbm5lY3Rpb24gd2FudHMgdG8gZGVsZXRlIGRhdGFiYXNlICcke3RoaXMubmFtZX0nLiBDbG9zaW5nIGRiIG5vdyB0byByZXN1bWUgdGhlIGRlbGV0ZSByZXF1ZXN0LmApO1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbihcImJsb2NrZWRcIiwgZXYgPT4ge1xuICAgICAgICAgICAgaWYgKCFldi5uZXdWZXJzaW9uIHx8IGV2Lm5ld1ZlcnNpb24gPCBldi5vbGRWZXJzaW9uKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRGV4aWUuZGVsZXRlKCcke3RoaXMubmFtZX0nKSB3YXMgYmxvY2tlZGApO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVXBncmFkZSAnJHt0aGlzLm5hbWV9JyBibG9ja2VkIGJ5IG90aGVyIGNvbm5lY3Rpb24gaG9sZGluZyB2ZXJzaW9uICR7ZXYub2xkVmVyc2lvbiAvIDEwfWApO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbWF4S2V5ID0gZ2V0TWF4S2V5KG9wdGlvbnMuSURCS2V5UmFuZ2UpO1xuICAgICAgICB0aGlzLl9jcmVhdGVUcmFuc2FjdGlvbiA9IChtb2RlLCBzdG9yZU5hbWVzLCBkYnNjaGVtYSwgcGFyZW50VHJhbnNhY3Rpb24pID0+IG5ldyB0aGlzLlRyYW5zYWN0aW9uKG1vZGUsIHN0b3JlTmFtZXMsIGRic2NoZW1hLCB0aGlzLl9vcHRpb25zLmNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eSwgcGFyZW50VHJhbnNhY3Rpb24pO1xuICAgICAgICB0aGlzLl9maXJlT25CbG9ja2VkID0gZXYgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbihcImJsb2NrZWRcIikuZmlyZShldik7XG4gICAgICAgICAgICBjb25uZWN0aW9uc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoYyA9PiBjLm5hbWUgPT09IHRoaXMubmFtZSAmJiBjICE9PSB0aGlzICYmICFjLl9zdGF0ZS52Y0ZpcmVkKVxuICAgICAgICAgICAgICAgIC5tYXAoYyA9PiBjLm9uKFwidmVyc2lvbmNoYW5nZVwiKS5maXJlKGV2KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXNlKHZpcnR1YWxJbmRleE1pZGRsZXdhcmUpO1xuICAgICAgICB0aGlzLnVzZShob29rc01pZGRsZXdhcmUpO1xuICAgICAgICB0aGlzLnVzZShvYnNlcnZhYmlsaXR5TWlkZGxld2FyZSk7XG4gICAgICAgIHRoaXMudXNlKGNhY2hlRXhpc3RpbmdWYWx1ZXNNaWRkbGV3YXJlKTtcbiAgICAgICAgdGhpcy52aXAgPSBPYmplY3QuY3JlYXRlKHRoaXMsIHsgX3ZpcDogeyB2YWx1ZTogdHJ1ZSB9IH0pO1xuICAgICAgICBhZGRvbnMuZm9yRWFjaChhZGRvbiA9PiBhZGRvbih0aGlzKSk7XG4gICAgfVxuICAgIHZlcnNpb24odmVyc2lvbk51bWJlcikge1xuICAgICAgICBpZiAoaXNOYU4odmVyc2lvbk51bWJlcikgfHwgdmVyc2lvbk51bWJlciA8IDAuMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlR5cGUoYEdpdmVuIHZlcnNpb24gaXMgbm90IGEgcG9zaXRpdmUgbnVtYmVyYCk7XG4gICAgICAgIHZlcnNpb25OdW1iZXIgPSBNYXRoLnJvdW5kKHZlcnNpb25OdW1iZXIgKiAxMCkgLyAxMDtcbiAgICAgICAgaWYgKHRoaXMuaWRiZGIgfHwgdGhpcy5fc3RhdGUuaXNCZWluZ09wZW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlNjaGVtYShcIkNhbm5vdCBhZGQgdmVyc2lvbiB3aGVuIGRhdGFiYXNlIGlzIG9wZW5cIik7XG4gICAgICAgIHRoaXMudmVybm8gPSBNYXRoLm1heCh0aGlzLnZlcm5vLCB2ZXJzaW9uTnVtYmVyKTtcbiAgICAgICAgY29uc3QgdmVyc2lvbnMgPSB0aGlzLl92ZXJzaW9ucztcbiAgICAgICAgdmFyIHZlcnNpb25JbnN0YW5jZSA9IHZlcnNpb25zLmZpbHRlcih2ID0+IHYuX2NmZy52ZXJzaW9uID09PSB2ZXJzaW9uTnVtYmVyKVswXTtcbiAgICAgICAgaWYgKHZlcnNpb25JbnN0YW5jZSlcbiAgICAgICAgICAgIHJldHVybiB2ZXJzaW9uSW5zdGFuY2U7XG4gICAgICAgIHZlcnNpb25JbnN0YW5jZSA9IG5ldyB0aGlzLlZlcnNpb24odmVyc2lvbk51bWJlcik7XG4gICAgICAgIHZlcnNpb25zLnB1c2godmVyc2lvbkluc3RhbmNlKTtcbiAgICAgICAgdmVyc2lvbnMuc29ydChsb3dlclZlcnNpb25GaXJzdCk7XG4gICAgICAgIHZlcnNpb25JbnN0YW5jZS5zdG9yZXMoe30pO1xuICAgICAgICB0aGlzLl9zdGF0ZS5hdXRvU2NoZW1hID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB2ZXJzaW9uSW5zdGFuY2U7XG4gICAgfVxuICAgIF93aGVuUmVhZHkoZm4pIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlkYmRiICYmICh0aGlzLl9zdGF0ZS5vcGVuQ29tcGxldGUgfHwgUFNELmxldFRocm91Z2ggfHwgdGhpcy5fdmlwKSkgPyBmbigpIDogbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUub3BlbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZCh0aGlzLl9zdGF0ZS5kYk9wZW5FcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGF0ZS5pc0JlaW5nT3BlbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9vcHRpb25zLmF1dG9PcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm9wZW4oKS5jYXRjaChub3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc3RhdGUuZGJSZWFkeVByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KS50aGVuKGZuKTtcbiAgICB9XG4gICAgdXNlKHsgc3RhY2ssIGNyZWF0ZSwgbGV2ZWwsIG5hbWUgfSkge1xuICAgICAgICBpZiAobmFtZSlcbiAgICAgICAgICAgIHRoaXMudW51c2UoeyBzdGFjaywgbmFtZSB9KTtcbiAgICAgICAgY29uc3QgbWlkZGxld2FyZXMgPSB0aGlzLl9taWRkbGV3YXJlc1tzdGFja10gfHwgKHRoaXMuX21pZGRsZXdhcmVzW3N0YWNrXSA9IFtdKTtcbiAgICAgICAgbWlkZGxld2FyZXMucHVzaCh7IHN0YWNrLCBjcmVhdGUsIGxldmVsOiBsZXZlbCA9PSBudWxsID8gMTAgOiBsZXZlbCwgbmFtZSB9KTtcbiAgICAgICAgbWlkZGxld2FyZXMuc29ydCgoYSwgYikgPT4gYS5sZXZlbCAtIGIubGV2ZWwpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdW51c2UoeyBzdGFjaywgbmFtZSwgY3JlYXRlIH0pIHtcbiAgICAgICAgaWYgKHN0YWNrICYmIHRoaXMuX21pZGRsZXdhcmVzW3N0YWNrXSkge1xuICAgICAgICAgICAgdGhpcy5fbWlkZGxld2FyZXNbc3RhY2tdID0gdGhpcy5fbWlkZGxld2FyZXNbc3RhY2tdLmZpbHRlcihtdyA9PiBjcmVhdGUgPyBtdy5jcmVhdGUgIT09IGNyZWF0ZSA6XG4gICAgICAgICAgICAgICAgbmFtZSA/IG13Lm5hbWUgIT09IG5hbWUgOlxuICAgICAgICAgICAgICAgICAgICBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9wZW4oKSB7XG4gICAgICAgIHJldHVybiBkZXhpZU9wZW4odGhpcyk7XG4gICAgfVxuICAgIF9jbG9zZSgpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgY29uc3QgaWR4ID0gY29ubmVjdGlvbnMuaW5kZXhPZih0aGlzKTtcbiAgICAgICAgaWYgKGlkeCA+PSAwKVxuICAgICAgICAgICAgY29ubmVjdGlvbnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIGlmICh0aGlzLmlkYmRiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuaWRiZGIuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIHRoaXMuX25vdmlwLmlkYmRiID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5kYlJlYWR5UHJvbWlzZSA9IG5ldyBEZXhpZVByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5kYlJlYWR5UmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgICAgICBzdGF0ZS5vcGVuQ2FuY2VsbGVyID0gbmV3IERleGllUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5jYW5jZWxPcGVuID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuX2Nsb3NlKCk7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgIHRoaXMuX29wdGlvbnMuYXV0b09wZW4gPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuZGJPcGVuRXJyb3IgPSBuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZCgpO1xuICAgICAgICBpZiAoc3RhdGUuaXNCZWluZ09wZW5lZClcbiAgICAgICAgICAgIHN0YXRlLmNhbmNlbE9wZW4oc3RhdGUuZGJPcGVuRXJyb3IpO1xuICAgIH1cbiAgICBkZWxldGUoKSB7XG4gICAgICAgIGNvbnN0IGhhc0FyZ3VtZW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkb0RlbGV0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgdmFyIHJlcSA9IHRoaXMuX2RlcHMuaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKHRoaXMubmFtZSk7XG4gICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHdyYXAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBfb25EYXRhYmFzZURlbGV0ZWQodGhpcy5fZGVwcywgdGhpcy5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgcmVxLm9uYmxvY2tlZCA9IHRoaXMuX2ZpcmVPbkJsb2NrZWQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGhhc0FyZ3VtZW50cylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJBcmd1bWVudHMgbm90IGFsbG93ZWQgaW4gZGIuZGVsZXRlKClcIik7XG4gICAgICAgICAgICBpZiAoc3RhdGUuaXNCZWluZ09wZW5lZCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLmRiUmVhZHlQcm9taXNlLnRoZW4oZG9EZWxldGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9EZWxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJhY2tlbmREQigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWRiZGI7XG4gICAgfVxuICAgIGlzT3BlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWRiZGIgIT09IG51bGw7XG4gICAgfVxuICAgIGhhc0JlZW5DbG9zZWQoKSB7XG4gICAgICAgIGNvbnN0IGRiT3BlbkVycm9yID0gdGhpcy5fc3RhdGUuZGJPcGVuRXJyb3I7XG4gICAgICAgIHJldHVybiBkYk9wZW5FcnJvciAmJiAoZGJPcGVuRXJyb3IubmFtZSA9PT0gJ0RhdGFiYXNlQ2xvc2VkJyk7XG4gICAgfVxuICAgIGhhc0ZhaWxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLmRiT3BlbkVycm9yICE9PSBudWxsO1xuICAgIH1cbiAgICBkeW5hbWljYWxseU9wZW5lZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLmF1dG9TY2hlbWE7XG4gICAgfVxuICAgIGdldCB0YWJsZXMoKSB7XG4gICAgICAgIHJldHVybiBrZXlzKHRoaXMuX2FsbFRhYmxlcykubWFwKG5hbWUgPT4gdGhpcy5fYWxsVGFibGVzW25hbWVdKTtcbiAgICB9XG4gICAgdHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBleHRyYWN0VHJhbnNhY3Rpb25BcmdzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2FjdGlvbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgX3RyYW5zYWN0aW9uKG1vZGUsIHRhYmxlcywgc2NvcGVGdW5jKSB7XG4gICAgICAgIGxldCBwYXJlbnRUcmFuc2FjdGlvbiA9IFBTRC50cmFucztcbiAgICAgICAgaWYgKCFwYXJlbnRUcmFuc2FjdGlvbiB8fCBwYXJlbnRUcmFuc2FjdGlvbi5kYiAhPT0gdGhpcyB8fCBtb2RlLmluZGV4T2YoJyEnKSAhPT0gLTEpXG4gICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgIGNvbnN0IG9ubHlJZkNvbXBhdGlibGUgPSBtb2RlLmluZGV4T2YoJz8nKSAhPT0gLTE7XG4gICAgICAgIG1vZGUgPSBtb2RlLnJlcGxhY2UoJyEnLCAnJykucmVwbGFjZSgnPycsICcnKTtcbiAgICAgICAgbGV0IGlkYk1vZGUsIHN0b3JlTmFtZXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdG9yZU5hbWVzID0gdGFibGVzLm1hcCh0YWJsZSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHN0b3JlTmFtZSA9IHRhYmxlIGluc3RhbmNlb2YgdGhpcy5UYWJsZSA/IHRhYmxlLm5hbWUgOiB0YWJsZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0b3JlTmFtZSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIHRhYmxlIGFyZ3VtZW50IHRvIERleGllLnRyYW5zYWN0aW9uKCkuIE9ubHkgVGFibGUgb3IgU3RyaW5nIGFyZSBhbGxvd2VkXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZU5hbWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChtb2RlID09IFwiclwiIHx8IG1vZGUgPT09IFJFQURPTkxZKVxuICAgICAgICAgICAgICAgIGlkYk1vZGUgPSBSRUFET05MWTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG1vZGUgPT0gXCJyd1wiIHx8IG1vZGUgPT0gUkVBRFdSSVRFKVxuICAgICAgICAgICAgICAgIGlkYk1vZGUgPSBSRUFEV1JJVEU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiSW52YWxpZCB0cmFuc2FjdGlvbiBtb2RlOiBcIiArIG1vZGUpO1xuICAgICAgICAgICAgaWYgKHBhcmVudFRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudFRyYW5zYWN0aW9uLm1vZGUgPT09IFJFQURPTkxZICYmIGlkYk1vZGUgPT09IFJFQURXUklURSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob25seUlmQ29tcGF0aWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50VHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlN1YlRyYW5zYWN0aW9uKFwiQ2Fubm90IGVudGVyIGEgc3ViLXRyYW5zYWN0aW9uIHdpdGggUkVBRFdSSVRFIG1vZGUgd2hlbiBwYXJlbnQgdHJhbnNhY3Rpb24gaXMgUkVBRE9OTFlcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZU5hbWVzLmZvckVhY2goc3RvcmVOYW1lID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbiAmJiBwYXJlbnRUcmFuc2FjdGlvbi5zdG9yZU5hbWVzLmluZGV4T2Yoc3RvcmVOYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob25seUlmQ29tcGF0aWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU3ViVHJhbnNhY3Rpb24oXCJUYWJsZSBcIiArIHN0b3JlTmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBub3QgaW5jbHVkZWQgaW4gcGFyZW50IHRyYW5zYWN0aW9uLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvbmx5SWZDb21wYXRpYmxlICYmIHBhcmVudFRyYW5zYWN0aW9uICYmICFwYXJlbnRUcmFuc2FjdGlvbi5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50VHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudFRyYW5zYWN0aW9uID9cbiAgICAgICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbi5fcHJvbWlzZShudWxsLCAoXywgcmVqZWN0KSA9PiB7IHJlamVjdChlKTsgfSkgOlxuICAgICAgICAgICAgICAgIHJlamVjdGlvbihlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbnRlclRyYW5zYWN0aW9uID0gZW50ZXJUcmFuc2FjdGlvblNjb3BlLmJpbmQobnVsbCwgdGhpcywgaWRiTW9kZSwgc3RvcmVOYW1lcywgcGFyZW50VHJhbnNhY3Rpb24sIHNjb3BlRnVuYyk7XG4gICAgICAgIHJldHVybiAocGFyZW50VHJhbnNhY3Rpb24gP1xuICAgICAgICAgICAgcGFyZW50VHJhbnNhY3Rpb24uX3Byb21pc2UoaWRiTW9kZSwgZW50ZXJUcmFuc2FjdGlvbiwgXCJsb2NrXCIpIDpcbiAgICAgICAgICAgIFBTRC50cmFucyA/XG4gICAgICAgICAgICAgICAgdXNlUFNEKFBTRC50cmFuc2xlc3MsICgpID0+IHRoaXMuX3doZW5SZWFkeShlbnRlclRyYW5zYWN0aW9uKSkgOlxuICAgICAgICAgICAgICAgIHRoaXMuX3doZW5SZWFkeShlbnRlclRyYW5zYWN0aW9uKSk7XG4gICAgfVxuICAgIHRhYmxlKHRhYmxlTmFtZSkge1xuICAgICAgICBpZiAoIWhhc093bih0aGlzLl9hbGxUYWJsZXMsIHRhYmxlTmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRUYWJsZShgVGFibGUgJHt0YWJsZU5hbWV9IGRvZXMgbm90IGV4aXN0YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsbFRhYmxlc1t0YWJsZU5hbWVdO1xuICAgIH1cbn1cblxuY29uc3Qgc3ltYm9sT2JzZXJ2YWJsZSA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJvYnNlcnZhYmxlXCIgaW4gU3ltYm9sXG4gICAgPyBTeW1ib2wub2JzZXJ2YWJsZVxuICAgIDogXCJAQG9ic2VydmFibGVcIjtcbmNsYXNzIE9ic2VydmFibGUge1xuICAgIGNvbnN0cnVjdG9yKHN1YnNjcmliZSkge1xuICAgICAgICB0aGlzLl9zdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgfVxuICAgIHN1YnNjcmliZSh4LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmliZSgheCB8fCB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geyBuZXh0OiB4LCBlcnJvciwgY29tcGxldGUgfSA6IHgpO1xuICAgIH1cbiAgICBbc3ltYm9sT2JzZXJ2YWJsZV0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZXh0ZW5kT2JzZXJ2YWJpbGl0eVNldCh0YXJnZXQsIG5ld1NldCkge1xuICAgIGtleXMobmV3U2V0KS5mb3JFYWNoKHBhcnQgPT4ge1xuICAgICAgICBjb25zdCByYW5nZVNldCA9IHRhcmdldFtwYXJ0XSB8fCAodGFyZ2V0W3BhcnRdID0gbmV3IFJhbmdlU2V0KCkpO1xuICAgICAgICBtZXJnZVJhbmdlcyhyYW5nZVNldCwgbmV3U2V0W3BhcnRdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBsaXZlUXVlcnkocXVlcmllcikge1xuICAgIGxldCBoYXNWYWx1ZSA9IGZhbHNlO1xuICAgIGxldCBjdXJyZW50VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlKChvYnNlcnZlcikgPT4ge1xuICAgICAgICBjb25zdCBzY29wZUZ1bmNJc0FzeW5jID0gaXNBc3luY0Z1bmN0aW9uKHF1ZXJpZXIpO1xuICAgICAgICBmdW5jdGlvbiBleGVjdXRlKHN1YnNjcikge1xuICAgICAgICAgICAgaWYgKHNjb3BlRnVuY0lzQXN5bmMpIHtcbiAgICAgICAgICAgICAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXhlYyA9ICgpID0+IG5ld1Njb3BlKHF1ZXJpZXIsIHsgc3Vic2NyLCB0cmFuczogbnVsbCB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJ2ID0gUFNELnRyYW5zXG4gICAgICAgICAgICAgICAgP1xuICAgICAgICAgICAgICAgICAgICB1c2VQU0QoUFNELnRyYW5zbGVzcywgZXhlYylcbiAgICAgICAgICAgICAgICA6IGV4ZWMoKTtcbiAgICAgICAgICAgIGlmIChzY29wZUZ1bmNJc0FzeW5jKSB7XG4gICAgICAgICAgICAgICAgcnYudGhlbihkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cywgZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICB9XG4gICAgICAgIGxldCBjbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGFjY3VtTXV0cyA9IHt9O1xuICAgICAgICBsZXQgY3VycmVudE9icyA9IHt9O1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB7XG4gICAgICAgICAgICBnZXQgY2xvc2VkKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjbG9zZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5zdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGdsb2JhbEV2ZW50cy5zdG9yYWdlbXV0YXRlZC51bnN1YnNjcmliZShtdXRhdGlvbkxpc3RlbmVyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIG9ic2VydmVyLnN0YXJ0ICYmIG9ic2VydmVyLnN0YXJ0KHN1YnNjcmlwdGlvbik7XG4gICAgICAgIGxldCBxdWVyeWluZyA9IGZhbHNlLCBzdGFydGVkTGlzdGVuaW5nID0gZmFsc2U7XG4gICAgICAgIGZ1bmN0aW9uIHNob3VsZE5vdGlmeSgpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXlzKGN1cnJlbnRPYnMpLnNvbWUoKGtleSkgPT4gYWNjdW1NdXRzW2tleV0gJiYgcmFuZ2VzT3ZlcmxhcChhY2N1bU11dHNba2V5XSwgY3VycmVudE9ic1trZXldKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbXV0YXRpb25MaXN0ZW5lciA9IChwYXJ0cykgPT4ge1xuICAgICAgICAgICAgZXh0ZW5kT2JzZXJ2YWJpbGl0eVNldChhY2N1bU11dHMsIHBhcnRzKTtcbiAgICAgICAgICAgIGlmIChzaG91bGROb3RpZnkoKSkge1xuICAgICAgICAgICAgICAgIGRvUXVlcnkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZG9RdWVyeSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChxdWVyeWluZyB8fCBjbG9zZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgYWNjdW1NdXRzID0ge307XG4gICAgICAgICAgICBjb25zdCBzdWJzY3IgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IGV4ZWN1dGUoc3Vic2NyKTtcbiAgICAgICAgICAgIGlmICghc3RhcnRlZExpc3RlbmluZykge1xuICAgICAgICAgICAgICAgIGdsb2JhbEV2ZW50cyhERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSwgbXV0YXRpb25MaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgc3RhcnRlZExpc3RlbmluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWVyeWluZyA9IHRydWU7XG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUocmV0KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBoYXNWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY3VycmVudFZhbHVlID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIHF1ZXJ5aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3NlZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGROb3RpZnkoKSkge1xuICAgICAgICAgICAgICAgICAgICBkb1F1ZXJ5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhY2N1bU11dHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE9icyA9IHN1YnNjcjtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCAmJiBvYnNlcnZlci5uZXh0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIHF1ZXJ5aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvciAmJiBvYnNlcnZlci5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGRvUXVlcnkoKTtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICB9KTtcbiAgICBvYnNlcnZhYmxlLmhhc1ZhbHVlID0gKCkgPT4gaGFzVmFsdWU7XG4gICAgb2JzZXJ2YWJsZS5nZXRWYWx1ZSA9ICgpID0+IGN1cnJlbnRWYWx1ZTtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZTtcbn1cblxubGV0IGRvbURlcHM7XG50cnkge1xuICAgIGRvbURlcHMgPSB7XG4gICAgICAgIGluZGV4ZWREQjogX2dsb2JhbC5pbmRleGVkREIgfHwgX2dsb2JhbC5tb3pJbmRleGVkREIgfHwgX2dsb2JhbC53ZWJraXRJbmRleGVkREIgfHwgX2dsb2JhbC5tc0luZGV4ZWREQixcbiAgICAgICAgSURCS2V5UmFuZ2U6IF9nbG9iYWwuSURCS2V5UmFuZ2UgfHwgX2dsb2JhbC53ZWJraXRJREJLZXlSYW5nZVxuICAgIH07XG59XG5jYXRjaCAoZSkge1xuICAgIGRvbURlcHMgPSB7IGluZGV4ZWREQjogbnVsbCwgSURCS2V5UmFuZ2U6IG51bGwgfTtcbn1cblxuY29uc3QgRGV4aWUgPSBEZXhpZSQxO1xucHJvcHMoRGV4aWUsIHtcbiAgICAuLi5mdWxsTmFtZUV4Y2VwdGlvbnMsXG4gICAgZGVsZXRlKGRhdGFiYXNlTmFtZSkge1xuICAgICAgICBjb25zdCBkYiA9IG5ldyBEZXhpZShkYXRhYmFzZU5hbWUsIHsgYWRkb25zOiBbXSB9KTtcbiAgICAgICAgcmV0dXJuIGRiLmRlbGV0ZSgpO1xuICAgIH0sXG4gICAgZXhpc3RzKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZXhpZShuYW1lLCB7IGFkZG9uczogW10gfSkub3BlbigpLnRoZW4oZGIgPT4ge1xuICAgICAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KS5jYXRjaCgnTm9TdWNoRGF0YWJhc2VFcnJvcicsICgpID0+IGZhbHNlKTtcbiAgICB9LFxuICAgIGdldERhdGFiYXNlTmFtZXMoY2IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXREYXRhYmFzZU5hbWVzKERleGllLmRlcGVuZGVuY2llcykudGhlbihjYik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLk1pc3NpbmdBUEkoKSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRlZmluZUNsYXNzKCkge1xuICAgICAgICBmdW5jdGlvbiBDbGFzcyhjb250ZW50KSB7XG4gICAgICAgICAgICBleHRlbmQodGhpcywgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENsYXNzO1xuICAgIH0sXG4gICAgaWdub3JlVHJhbnNhY3Rpb24oc2NvcGVGdW5jKSB7XG4gICAgICAgIHJldHVybiBQU0QudHJhbnMgP1xuICAgICAgICAgICAgdXNlUFNEKFBTRC50cmFuc2xlc3MsIHNjb3BlRnVuYykgOlxuICAgICAgICAgICAgc2NvcGVGdW5jKCk7XG4gICAgfSxcbiAgICB2aXAsXG4gICAgYXN5bmM6IGZ1bmN0aW9uIChnZW5lcmF0b3JGbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgcnYgPSBhd2FpdEl0ZXJhdG9yKGdlbmVyYXRvckZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgICAgIGlmICghcnYgfHwgdHlwZW9mIHJ2LnRoZW4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZShydik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgc3Bhd246IGZ1bmN0aW9uIChnZW5lcmF0b3JGbiwgYXJncywgdGhpeikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJ2ID0gYXdhaXRJdGVyYXRvcihnZW5lcmF0b3JGbi5hcHBseSh0aGl6LCBhcmdzIHx8IFtdKSk7XG4gICAgICAgICAgICBpZiAoIXJ2IHx8IHR5cGVvZiBydi50aGVuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIHJldHVybiBEZXhpZVByb21pc2UucmVzb2x2ZShydik7XG4gICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGN1cnJlbnRUcmFuc2FjdGlvbjoge1xuICAgICAgICBnZXQ6ICgpID0+IFBTRC50cmFucyB8fCBudWxsXG4gICAgfSxcbiAgICB3YWl0Rm9yOiBmdW5jdGlvbiAocHJvbWlzZU9yRnVuY3Rpb24sIG9wdGlvbmFsVGltZW91dCkge1xuICAgICAgICBjb25zdCBwcm9taXNlID0gRGV4aWVQcm9taXNlLnJlc29sdmUodHlwZW9mIHByb21pc2VPckZ1bmN0aW9uID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgIERleGllLmlnbm9yZVRyYW5zYWN0aW9uKHByb21pc2VPckZ1bmN0aW9uKSA6XG4gICAgICAgICAgICBwcm9taXNlT3JGdW5jdGlvbilcbiAgICAgICAgICAgIC50aW1lb3V0KG9wdGlvbmFsVGltZW91dCB8fCA2MDAwMCk7XG4gICAgICAgIHJldHVybiBQU0QudHJhbnMgP1xuICAgICAgICAgICAgUFNELnRyYW5zLndhaXRGb3IocHJvbWlzZSkgOlxuICAgICAgICAgICAgcHJvbWlzZTtcbiAgICB9LFxuICAgIFByb21pc2U6IERleGllUHJvbWlzZSxcbiAgICBkZWJ1Zzoge1xuICAgICAgICBnZXQ6ICgpID0+IGRlYnVnLFxuICAgICAgICBzZXQ6IHZhbHVlID0+IHtcbiAgICAgICAgICAgIHNldERlYnVnKHZhbHVlLCB2YWx1ZSA9PT0gJ2RleGllJyA/ICgpID0+IHRydWUgOiBkZXhpZVN0YWNrRnJhbWVGaWx0ZXIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBkZXJpdmU6IGRlcml2ZSxcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBwcm9wczogcHJvcHMsXG4gICAgb3ZlcnJpZGU6IG92ZXJyaWRlLFxuICAgIEV2ZW50czogRXZlbnRzLFxuICAgIG9uOiBnbG9iYWxFdmVudHMsXG4gICAgbGl2ZVF1ZXJ5LFxuICAgIGV4dGVuZE9ic2VydmFiaWxpdHlTZXQsXG4gICAgZ2V0QnlLZXlQYXRoOiBnZXRCeUtleVBhdGgsXG4gICAgc2V0QnlLZXlQYXRoOiBzZXRCeUtleVBhdGgsXG4gICAgZGVsQnlLZXlQYXRoOiBkZWxCeUtleVBhdGgsXG4gICAgc2hhbGxvd0Nsb25lOiBzaGFsbG93Q2xvbmUsXG4gICAgZGVlcENsb25lOiBkZWVwQ2xvbmUsXG4gICAgZ2V0T2JqZWN0RGlmZjogZ2V0T2JqZWN0RGlmZixcbiAgICBjbXAsXG4gICAgYXNhcDogYXNhcCQxLFxuICAgIG1pbktleTogbWluS2V5LFxuICAgIGFkZG9uczogW10sXG4gICAgY29ubmVjdGlvbnM6IGNvbm5lY3Rpb25zLFxuICAgIGVycm5hbWVzOiBlcnJuYW1lcyxcbiAgICBkZXBlbmRlbmNpZXM6IGRvbURlcHMsXG4gICAgc2VtVmVyOiBERVhJRV9WRVJTSU9OLFxuICAgIHZlcnNpb246IERFWElFX1ZFUlNJT04uc3BsaXQoJy4nKVxuICAgICAgICAubWFwKG4gPT4gcGFyc2VJbnQobikpXG4gICAgICAgIC5yZWR1Y2UoKHAsIGMsIGkpID0+IHAgKyAoYyAvIE1hdGgucG93KDEwLCBpICogMikpKSxcbn0pO1xuRGV4aWUubWF4S2V5ID0gZ2V0TWF4S2V5KERleGllLmRlcGVuZGVuY2llcy5JREJLZXlSYW5nZSk7XG5cbmlmICh0eXBlb2YgZGlzcGF0Y2hFdmVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZ2xvYmFsRXZlbnRzKERFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FLCB1cGRhdGVkUGFydHMgPT4ge1xuICAgICAgICBpZiAoIXByb3BhZ2F0aW5nTG9jYWxseSkge1xuICAgICAgICAgICAgbGV0IGV2ZW50O1xuICAgICAgICAgICAgaWYgKGlzSUVPckVkZ2UpIHtcbiAgICAgICAgICAgICAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgICAgICAgICAgIGV2ZW50LmluaXRDdXN0b21FdmVudChTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUsIHRydWUsIHRydWUsIHVwZGF0ZWRQYXJ0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBldmVudCA9IG5ldyBDdXN0b21FdmVudChTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUsIHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiB1cGRhdGVkUGFydHNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3BhZ2F0aW5nTG9jYWxseSA9IHRydWU7XG4gICAgICAgICAgICBkaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIHByb3BhZ2F0aW5nTG9jYWxseSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUsICh7IGRldGFpbCB9KSA9PiB7XG4gICAgICAgIGlmICghcHJvcGFnYXRpbmdMb2NhbGx5KSB7XG4gICAgICAgICAgICBwcm9wYWdhdGVMb2NhbGx5KGRldGFpbCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHByb3BhZ2F0ZUxvY2FsbHkodXBkYXRlUGFydHMpIHtcbiAgICBsZXQgd2FzTWUgPSBwcm9wYWdhdGluZ0xvY2FsbHk7XG4gICAgdHJ5IHtcbiAgICAgICAgcHJvcGFnYXRpbmdMb2NhbGx5ID0gdHJ1ZTtcbiAgICAgICAgZ2xvYmFsRXZlbnRzLnN0b3JhZ2VtdXRhdGVkLmZpcmUodXBkYXRlUGFydHMpO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgcHJvcGFnYXRpbmdMb2NhbGx5ID0gd2FzTWU7XG4gICAgfVxufVxubGV0IHByb3BhZ2F0aW5nTG9jYWxseSA9IGZhbHNlO1xuXG5pZiAodHlwZW9mIEJyb2FkY2FzdENoYW5uZWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc3QgYmMgPSBuZXcgQnJvYWRjYXN0Q2hhbm5lbChTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUpO1xuICAgIGlmICh0eXBlb2YgYmMudW5yZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYmMudW5yZWYoKTtcbiAgICB9XG4gICAgZ2xvYmFsRXZlbnRzKERFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FLCAoY2hhbmdlZFBhcnRzKSA9PiB7XG4gICAgICAgIGlmICghcHJvcGFnYXRpbmdMb2NhbGx5KSB7XG4gICAgICAgICAgICBiYy5wb3N0TWVzc2FnZShjaGFuZ2VkUGFydHMpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgYmMub25tZXNzYWdlID0gKGV2KSA9PiB7XG4gICAgICAgIGlmIChldi5kYXRhKVxuICAgICAgICAgICAgcHJvcGFnYXRlTG9jYWxseShldi5kYXRhKTtcbiAgICB9O1xufVxuZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZ2xvYmFsRXZlbnRzKERFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FLCAoY2hhbmdlZFBhcnRzKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIXByb3BhZ2F0aW5nTG9jYWxseSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbG9jYWxTdG9yYWdlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyaWc6IE1hdGgucmFuZG9tKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkUGFydHMsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxmWydjbGllbnRzJ10gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIFsuLi5zZWxmWydjbGllbnRzJ10ubWF0Y2hBbGwoeyBpbmNsdWRlVW5jb250cm9sbGVkOiB0cnVlIH0pXS5mb3JFYWNoKChjbGllbnQpID0+IGNsaWVudC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkUGFydHMsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ3N0b3JhZ2UnLCAoZXYpID0+IHtcbiAgICAgICAgICAgIGlmIChldi5rZXkgPT09IFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGV2Lm5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgcHJvcGFnYXRlTG9jYWxseShkYXRhLmNoYW5nZWRQYXJ0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBzd0NvbnRhaW5lciA9IHNlbGYuZG9jdW1lbnQgJiYgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXI7XG4gICAgaWYgKHN3Q29udGFpbmVyKSB7XG4gICAgICAgIHN3Q29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBwcm9wYWdhdGVNZXNzYWdlTG9jYWxseSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcHJvcGFnYXRlTWVzc2FnZUxvY2FsbHkoeyBkYXRhIH0pIHtcbiAgICBpZiAoZGF0YSAmJiBkYXRhLnR5cGUgPT09IFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSkge1xuICAgICAgICBwcm9wYWdhdGVMb2NhbGx5KGRhdGEuY2hhbmdlZFBhcnRzKTtcbiAgICB9XG59XG5cbkRleGllUHJvbWlzZS5yZWplY3Rpb25NYXBwZXIgPSBtYXBFcnJvcjtcbnNldERlYnVnKGRlYnVnLCBkZXhpZVN0YWNrRnJhbWVGaWx0ZXIpO1xuXG5leHBvcnQgeyBEZXhpZSQxIGFzIERleGllLCBSYW5nZVNldCwgRGV4aWUkMSBhcyBkZWZhdWx0LCBsaXZlUXVlcnksIG1lcmdlUmFuZ2VzLCByYW5nZXNPdmVybGFwIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXhpZS5tanMubWFwXG4iXSwibmFtZXMiOlsiX2dsb2JhbCIsImdsb2JhbFRoaXMiLCJzZWxmIiwid2luZG93IiwiZ2xvYmFsIiwia2V5cyIsIk9iamVjdCIsImlzQXJyYXkiLCJBcnJheSIsIlByb21pc2UiLCJleHRlbmQiLCJvYmoiLCJleHRlbnNpb24iLCJmb3JFYWNoIiwia2V5IiwiZ2V0UHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsIl9oYXNPd24iLCJoYXNPd25Qcm9wZXJ0eSIsImhhc093biIsInByb3AiLCJjYWxsIiwicHJvcHMiLCJwcm90byIsIlJlZmxlY3QiLCJvd25LZXlzIiwic2V0UHJvcCIsImRlZmluZVByb3BlcnR5IiwiZnVuY3Rpb25PckdldFNldCIsIm9wdGlvbnMiLCJnZXQiLCJzZXQiLCJjb25maWd1cmFibGUiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiZGVyaXZlIiwiQ2hpbGQiLCJmcm9tIiwiUGFyZW50IiwicHJvdG90eXBlIiwiY3JlYXRlIiwiYmluZCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldFByb3BlcnR5RGVzY3JpcHRvciIsInBkIiwiX3NsaWNlIiwic2xpY2UiLCJhcmdzIiwic3RhcnQiLCJlbmQiLCJvdmVycmlkZSIsIm9yaWdGdW5jIiwib3ZlcnJpZGVkRmFjdG9yeSIsImFzc2VydCIsImIiLCJFcnJvciIsImFzYXAkMSIsImZuIiwic2V0SW1tZWRpYXRlIiwic2V0VGltZW91dCIsImFycmF5VG9PYmplY3QiLCJhcnJheSIsImV4dHJhY3RvciIsInJlZHVjZSIsInJlc3VsdCIsIml0ZW0iLCJpIiwibmFtZUFuZFZhbHVlIiwidHJ5Q2F0Y2giLCJvbmVycm9yIiwiYXBwbHkiLCJleCIsImdldEJ5S2V5UGF0aCIsImtleVBhdGgiLCJydiIsImwiLCJsZW5ndGgiLCJ2YWwiLCJwdXNoIiwicGVyaW9kIiwiaW5kZXhPZiIsImlubmVyT2JqIiwic3Vic3RyIiwidW5kZWZpbmVkIiwic2V0QnlLZXlQYXRoIiwiaXNGcm96ZW4iLCJjdXJyZW50S2V5UGF0aCIsInJlbWFpbmluZ0tleVBhdGgiLCJpc05hTiIsInBhcnNlSW50Iiwic3BsaWNlIiwiZGVsQnlLZXlQYXRoIiwibWFwIiwia3AiLCJzaGFsbG93Q2xvbmUiLCJtIiwiY29uY2F0IiwiZmxhdHRlbiIsImEiLCJpbnRyaW5zaWNUeXBlTmFtZXMiLCJzcGxpdCIsIm51bSIsInQiLCJmaWx0ZXIiLCJpbnRyaW5zaWNUeXBlcyIsIngiLCJjaXJjdWxhclJlZnMiLCJkZWVwQ2xvbmUiLCJhbnkiLCJXZWFrTWFwIiwiaW5uZXJEZWVwQ2xvbmUiLCJjb25zdHJ1Y3RvciIsInRvU3RyaW5nIiwidG9TdHJpbmdUYWciLCJvIiwiaXRlcmF0b3JTeW1ib2wiLCJTeW1ib2wiLCJpdGVyYXRvciIsImdldEl0ZXJhdG9yT2YiLCJOT19DSEFSX0FSUkFZIiwiZ2V0QXJyYXlPZiIsImFycmF5TGlrZSIsIml0IiwiYXJndW1lbnRzIiwibmV4dCIsImRvbmUiLCJpc0FzeW5jRnVuY3Rpb24iLCJkZWJ1ZyIsImxvY2F0aW9uIiwidGVzdCIsImhyZWYiLCJzZXREZWJ1ZyIsImxpYnJhcnlGaWx0ZXIiLCJORUVEU19USFJPV19GT1JfU1RBQ0siLCJzdGFjayIsImdldEVycm9yV2l0aFN0YWNrIiwiZSIsInByZXR0eVN0YWNrIiwiZXhjZXB0aW9uIiwibnVtSWdub3JlZEZyYW1lcyIsIm5hbWUiLCJtZXNzYWdlIiwiZnJhbWUiLCJqb2luIiwiZGV4aWVFcnJvck5hbWVzIiwiaWRiRG9tRXJyb3JOYW1lcyIsImVycm9yTGlzdCIsImRlZmF1bHRUZXh0cyIsIlZlcnNpb25DaGFuZ2VkIiwiRGF0YWJhc2VDbG9zZWQiLCJBYm9ydCIsIlRyYW5zYWN0aW9uSW5hY3RpdmUiLCJNaXNzaW5nQVBJIiwiRGV4aWVFcnJvciIsIm1zZyIsIl9lIiwiX3N0YWNrIiwiZ2V0TXVsdGlFcnJvck1lc3NhZ2UiLCJmYWlsdXJlcyIsInYiLCJzIiwiTW9kaWZ5RXJyb3IiLCJzdWNjZXNzQ291bnQiLCJmYWlsZWRLZXlzIiwiQnVsa0Vycm9yIiwicG9zIiwiZmFpbHVyZXNCeVBvcyIsImVycm5hbWVzIiwiQmFzZUV4Y2VwdGlvbiIsImV4Y2VwdGlvbnMiLCJmdWxsTmFtZSIsIm1zZ09ySW5uZXIiLCJpbm5lciIsIlN5bnRheCIsIlN5bnRheEVycm9yIiwiVHlwZSIsIlR5cGVFcnJvciIsIlJhbmdlIiwiUmFuZ2VFcnJvciIsImV4Y2VwdGlvbk1hcCIsIm1hcEVycm9yIiwiZG9tRXJyb3IiLCJmdWxsTmFtZUV4Y2VwdGlvbnMiLCJub3AiLCJtaXJyb3IiLCJwdXJlRnVuY3Rpb25DaGFpbiIsImYxIiwiZjIiLCJjYWxsQm90aCIsIm9uMSIsIm9uMiIsImhvb2tDcmVhdGluZ0NoYWluIiwicmVzIiwib25zdWNjZXNzIiwicmVzMiIsImhvb2tEZWxldGluZ0NoYWluIiwiaG9va1VwZGF0aW5nQ2hhaW4iLCJtb2RpZmljYXRpb25zIiwicmV2ZXJzZVN0b3BwYWJsZUV2ZW50Q2hhaW4iLCJwcm9taXNhYmxlQ2hhaW4iLCJ0aGVuIiwidGhpeiIsIklOVEVSTkFMIiwiTE9OR19TVEFDS1NfQ0xJUF9MSU1JVCIsIk1BWF9MT05HX1NUQUNLUyIsIlpPTkVfRUNIT19MSU1JVCIsInJlc29sdmVkTmF0aXZlUHJvbWlzZSIsIm5hdGl2ZVByb21pc2VQcm90byIsInJlc29sdmVkR2xvYmFsUHJvbWlzZSIsImdsb2JhbFAiLCJyZXNvbHZlIiwiY3J5cHRvIiwic3VidGxlIiwibmF0aXZlUCIsImRpZ2VzdCIsIlVpbnQ4QXJyYXkiLCJuYXRpdmVQcm9taXNlVGhlbiIsIk5hdGl2ZVByb21pc2UiLCJwYXRjaEdsb2JhbFByb21pc2UiLCJzdGFja19iZWluZ19nZW5lcmF0ZWQiLCJzY2hlZHVsZVBoeXNpY2FsVGljayIsInBoeXNpY2FsVGljayIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJoaWRkZW5EaXYiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJvYnNlcnZlIiwiYXR0cmlidXRlcyIsInNldEF0dHJpYnV0ZSIsImFzYXAiLCJjYWxsYmFjayIsIm1pY3JvdGlja1F1ZXVlIiwibmVlZHNOZXdQaHlzaWNhbFRpY2siLCJpc091dHNpZGVNaWNyb1RpY2siLCJ1bmhhbmRsZWRFcnJvcnMiLCJyZWplY3RpbmdFcnJvcnMiLCJjdXJyZW50RnVsZmlsbGVyIiwicmVqZWN0aW9uTWFwcGVyIiwiZ2xvYmFsUFNEIiwiaWQiLCJyZWYiLCJ1bmhhbmRsZWRzIiwib251bmhhbmRsZWQiLCJnbG9iYWxFcnJvciIsInBncCIsImVudiIsImZpbmFsaXplIiwidWgiLCJQU0QiLCJudW1TY2hlZHVsZWRDYWxscyIsInRpY2tGaW5hbGl6ZXJzIiwiRGV4aWVQcm9taXNlIiwiX2xpc3RlbmVycyIsIm9udW5jYXRjaGVkIiwiX2xpYiIsInBzZCIsIl9QU0QiLCJfc3RhY2tIb2xkZXIiLCJfcHJldiIsIl9udW1QcmV2IiwiX3N0YXRlIiwiX3ZhbHVlIiwiaGFuZGxlUmVqZWN0aW9uIiwiZXhlY3V0ZVByb21pc2VUYXNrIiwidGhlblByb3AiLCJtaWNyb1Rhc2tJZCIsInRvdGFsRWNob2VzIiwib25GdWxmaWxsZWQiLCJvblJlamVjdGVkIiwicG9zc2libGVBd2FpdCIsImNsZWFudXAiLCJkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cyIsInJlamVjdCIsInByb3BhZ2F0ZVRvTGlzdGVuZXIiLCJMaXN0ZW5lciIsIm5hdGl2ZUF3YWl0Q29tcGF0aWJsZVdyYXAiLCJsaW5rVG9QcmV2aW91c1Byb21pc2UiLCJfdGhlbiIsImNhdGNoIiwidHlwZSIsImhhbmRsZXIiLCJlcnIiLCJQcm9taXNlUmVqZWN0IiwiZmluYWxseSIsIm9uRmluYWxseSIsInN0YWNrcyIsImdldFN0YWNrIiwidGltZW91dCIsIm1zIiwiSW5maW5pdHkiLCJoYW5kbGUiLCJUaW1lb3V0IiwiY2xlYXJUaW1lb3V0Iiwic25hcFNob3QiLCJ6b25lIiwiYWxsIiwidmFsdWVzIiwib25Qb3NzaWJsZVBhcmFsbGVsbEFzeW5jIiwicmVtYWluaW5nIiwicmFjZSIsIm5ld1BTRCIsIm5ld1Njb3BlIiwidXNlUFNEIiwic2NoZWR1bGVyIiwiZm9sbG93Iiwiem9uZVByb3BzIiwicnVuX2F0X2VuZF9vZl90aGlzX29yX25leHRfcGh5c2ljYWxfdGljayIsImFsbFNldHRsZWQiLCJwb3NzaWJsZVByb21pc2VzIiwicmVzdWx0cyIsInAiLCJzdGF0dXMiLCJyZWFzb24iLCJBZ2dyZWdhdGVFcnJvciIsImZhaWx1cmUiLCJwcm9taXNlIiwic2hvdWxkRXhlY3V0ZVRpY2siLCJiZWdpbk1pY3JvVGlja1Njb3BlIiwicHJvcGFnYXRlQWxsTGlzdGVuZXJzIiwiZW5kTWljcm9UaWNrU2NvcGUiLCJfcHJvbWlzZSIsIm9yaWdQcm9wIiwiYWRkUG9zc2libHlVbmhhbmRsZWRFcnJvciIsImxpc3RlbmVycyIsImxlbiIsImZpbmFsaXplUGh5c2ljYWxUaWNrIiwibGlzdGVuZXIiLCJjYiIsImNhbGxMaXN0ZW5lciIsInJldCIsIm1hcmtFcnJvckFzSGFuZGxlZCIsImxpbWl0IiwiZXJyb3JOYW1lIiwicHJldiIsIm51bVByZXYiLCJ3YXNSb290RXhlYyIsImNhbGxiYWNrcyIsInVuaGFuZGxlZEVycnMiLCJmaW5hbGl6ZXJzIiwiZmluYWxpemVyIiwic29tZSIsIndyYXAiLCJlcnJvckNhdGNoZXIiLCJvdXRlclNjb3BlIiwic3dpdGNoVG9ab25lIiwidGFzayIsImF3YWl0cyIsImVjaG9lcyIsInRhc2tDb3VudGVyIiwiem9uZVN0YWNrIiwiem9uZUVjaG9lcyIsInpvbmVfaWRfY291bnRlciIsImExIiwiYTIiLCJwYXJlbnQiLCJnbG9iYWxFbnYiLCJQcm9taXNlUHJvcCIsIm50aGVuIiwiZ2V0UGF0Y2hlZFByb21pc2VUaGVuIiwiZ3RoZW4iLCJpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cyIsInBvc3NpYmxlUHJvbWlzZSIsInJlamVjdGlvbiIsInpvbmVFbnRlckVjaG8iLCJ0YXJnZXRab25lIiwiem9uZUxlYXZlRWNobyIsInBvcCIsImJFbnRlcmluZ1pvbmUiLCJjdXJyZW50Wm9uZSIsImVucXVldWVOYXRpdmVNaWNyb1Rhc2siLCJHbG9iYWxQcm9taXNlIiwidGFyZ2V0RW52IiwiYTMiLCJqb2IiLCJvdXRlclpvbmUiLCJvcmlnVGhlbiIsIm9uUmVzb2x2ZWQiLCJVTkhBTkRMRURSRUpFQ1RJT04iLCJldmVudCIsImV2ZW50RGF0YSIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJkaXNwYXRjaEV2ZW50IiwiUHJvbWlzZVJlamVjdGlvbkV2ZW50Iiwib251bmhhbmRsZWRyZWplY3Rpb24iLCJfIiwiZGVmYXVsdFByZXZlbnRlZCIsImNvbnNvbGUiLCJ3YXJuIiwidGVtcFRyYW5zYWN0aW9uIiwiZGIiLCJtb2RlIiwic3RvcmVOYW1lcyIsImlkYmRiIiwib3BlbkNvbXBsZXRlIiwibGV0VGhyb3VnaCIsIl92aXAiLCJkYk9wZW5FcnJvciIsImlzQmVpbmdPcGVuZWQiLCJfb3B0aW9ucyIsImF1dG9PcGVuIiwib3BlbiIsImRiUmVhZHlQcm9taXNlIiwidHJhbnMiLCJfY3JlYXRlVHJhbnNhY3Rpb24iLCJfZGJTY2hlbWEiLCJQUjEzOThfbWF4TG9vcCIsIkludmFsaWRTdGF0ZSIsImlzT3BlbiIsIl9jbG9zZSIsIl9jb21wbGV0aW9uIiwiREVYSUVfVkVSU0lPTiIsIm1heFN0cmluZyIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIm1pbktleSIsIklOVkFMSURfS0VZX0FSR1VNRU5UIiwiU1RSSU5HX0VYUEVDVEVEIiwiY29ubmVjdGlvbnMiLCJpc0lFT3JFZGdlIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaGFzSUVEZWxldGVPYmplY3RTdG9yZUJ1ZyIsImhhbmdzT25EZWxldGVMYXJnZUtleVJhbmdlIiwiZGV4aWVTdGFja0ZyYW1lRmlsdGVyIiwiREJOQU1FU19EQiIsIlJFQURPTkxZIiwiUkVBRFdSSVRFIiwiY29tYmluZSIsImZpbHRlcjEiLCJmaWx0ZXIyIiwiQW55UmFuZ2UiLCJsb3dlciIsImxvd2VyT3BlbiIsInVwcGVyIiwidXBwZXJPcGVuIiwid29ya2Fyb3VuZEZvclVuZGVmaW5lZFByaW1LZXkiLCJUYWJsZSIsIl90cmFucyIsIndyaXRlTG9ja2VkIiwiX3R4IiwidGFibGVOYW1lIiwiY2hlY2tUYWJsZUluVHJhbnNhY3Rpb24iLCJzY2hlbWEiLCJOb3RGb3VuZCIsImlkYnRyYW5zIiwidHJhbnNsZXNzIiwia2V5T3JDcml0Iiwid2hlcmUiLCJmaXJzdCIsImNvcmUiLCJob29rIiwicmVhZGluZyIsImZpcmUiLCJpbmRleE9yQ3JpdCIsIldoZXJlQ2xhdXNlIiwia2V5UGF0aHMiLCJlcXVhbHMiLCJjb21wb3VuZEluZGV4IiwiaW5kZXhlcyIsInByaW1LZXkiLCJpeCIsImNvbXBvdW5kIiwiZXZlcnkiLCJzb3J0IiwiX21heEtleSIsImtleVBhdGhzSW5WYWxpZE9yZGVyIiwiSlNPTiIsInN0cmluZ2lmeSIsImlkeEJ5TmFtZSIsImlkYiIsIl9kZXBzIiwiaW5kZXhlZERCIiwiY21wIiwiaWR4IiwiZmlsdGVyRnVuY3Rpb24iLCJwcmV2SW5kZXgiLCJwcmV2RmlsdGVyRm4iLCJpbmRleCIsIm11bHRpIiwidG9Db2xsZWN0aW9uIiwiYW5kIiwiY291bnQiLCJ0aGVuU2hvcnRjdXQiLCJvZmZzZXQiLCJudW1Sb3dzIiwiZWFjaCIsInRvQXJyYXkiLCJDb2xsZWN0aW9uIiwib3JkZXJCeSIsInJldmVyc2UiLCJtYXBUb0NsYXNzIiwibWFwcGVkQ2xhc3MiLCJyZWFkSG9vayIsInVuc3Vic2NyaWJlIiwiZGVmaW5lQ2xhc3MiLCJDbGFzcyIsImNvbnRlbnQiLCJhZGQiLCJhdXRvIiwib2JqVG9BZGQiLCJtdXRhdGUiLCJudW1GYWlsdXJlcyIsImxhc3RSZXN1bHQiLCJ1cGRhdGUiLCJrZXlPck9iamVjdCIsIkludmFsaWRBcmd1bWVudCIsIl9hIiwibW9kaWZ5IiwicHV0IiwiZGVsZXRlIiwiY2xlYXIiLCJyYW5nZSIsImJ1bGtHZXQiLCJnZXRNYW55IiwiYnVsa0FkZCIsIm9iamVjdHMiLCJrZXlzT3JPcHRpb25zIiwid2FudFJlc3VsdHMiLCJhbGxLZXlzIiwibnVtT2JqZWN0cyIsIm9iamVjdHNUb0FkZCIsImJ1bGtQdXQiLCJvYmplY3RzVG9QdXQiLCJidWxrRGVsZXRlIiwibnVtS2V5cyIsIkV2ZW50cyIsImN0eCIsImV2cyIsImV2ZW50TmFtZSIsInN1YnNjcmliZXIiLCJzdWJzY3JpYmUiLCJhZGRFdmVudFR5cGUiLCJjaGFpbkZ1bmN0aW9uIiwiZGVmYXVsdEZ1bmN0aW9uIiwiYWRkQ29uZmlndXJlZEV2ZW50cyIsImNvbnRleHQiLCJzdWJzY3JpYmVycyIsImNmZyIsImZpcmVFdmVudCIsIm1ha2VDbGFzc0NvbnN0cnVjdG9yIiwiY3JlYXRlVGFibGVDb25zdHJ1Y3RvciIsInRhYmxlU2NoZW1hIiwiX2FsbFRhYmxlcyIsImlzUGxhaW5LZXlSYW5nZSIsImlnbm9yZUxpbWl0RmlsdGVyIiwiYWxnb3JpdGhtIiwib3IiLCJqdXN0TGltaXQiLCJyZXBsYXlGaWx0ZXIiLCJhZGRGaWx0ZXIiLCJhZGRSZXBsYXlGaWx0ZXIiLCJmYWN0b3J5IiwiaXNMaW1pdEZpbHRlciIsImN1cnIiLCJhZGRNYXRjaEZpbHRlciIsImlzTWF0Y2giLCJnZXRJbmRleE9yU3RvcmUiLCJjb3JlU2NoZW1hIiwiaXNQcmltS2V5IiwicHJpbWFyeUtleSIsImdldEluZGV4QnlLZXlQYXRoIiwiU2NoZW1hIiwib3BlbkN1cnNvciIsImNvcmVUYWJsZSIsImtleXNPbmx5IiwiZGlyIiwidW5pcXVlIiwicXVlcnkiLCJpdGVyIiwiY29yZVRyYW5zIiwiaXRlcmF0ZSIsInZhbHVlTWFwcGVyIiwidW5pb24iLCJjdXJzb3IiLCJhZHZhbmNlIiwic3RvcCIsImZhaWwiLCJfaXRlcmF0ZSIsImN1cnNvclByb21pc2UiLCJtYXBwZWRGbiIsImMiLCJ3cmFwcGVkRm4iLCJjb250aW51ZSIsImFkdmFuY2VyIiwidGEiLCJ0YiIsIk5hTiIsImNvbXBhcmVVaW50OEFycmF5cyIsImdldFVpbnQ4QXJyYXkiLCJjb21wYXJlQXJyYXlzIiwiYWwiLCJibCIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwidHNUYWciLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsIl9yZWFkIiwiX2N0eCIsImVycm9yIiwidGFibGUiLCJfd3JpdGUiLCJfYWRkQWxnb3JpdGhtIiwiY2xvbmUiLCJyYXciLCJNYXRoIiwibWluIiwic29ydEJ5IiwicGFydHMiLCJsYXN0UGFydCIsImxhc3RJbmRleCIsImdldHZhbCIsIm9yZGVyIiwic29ydGVyIiwiYVZhbCIsImJWYWwiLCJvZmZzZXRMZWZ0Iiwicm93c0xlZnQiLCJ1bnRpbCIsImJJbmNsdWRlU3RvcEVudHJ5IiwibGFzdCIsImluZGV4TmFtZSIsIl9vbmRpcmVjdGlvbmNoYW5nZSIsImRlc2MiLCJlYWNoS2V5IiwiZWFjaFVuaXF1ZUtleSIsImVhY2hQcmltYXJ5S2V5IiwicHJpbWFyeUtleXMiLCJ1bmlxdWVLZXlzIiwiZmlyc3RLZXkiLCJsYXN0S2V5IiwiZGlzdGluY3QiLCJzdHJLZXkiLCJmb3VuZCIsImNoYW5nZXMiLCJtb2RpZnllciIsImFueXRoaW5nTW9kaWZpZWQiLCJvdXRib3VuZCIsImV4dHJhY3RLZXkiLCJtb2RpZnlDaHVua1NpemUiLCJ0b3RhbEZhaWx1cmVzIiwiYXBwbHlNdXRhdGVSZXN1bHQiLCJleHBlY3RlZENvdW50IiwibmV4dENodW5rIiwiY2FjaGUiLCJhZGRWYWx1ZXMiLCJwdXRWYWx1ZXMiLCJwdXRLZXlzIiwiZGVsZXRlS2V5cyIsIm9yaWdWYWx1ZSIsImNyaXRlcmlhIiwiZGVsZXRlQ2FsbGJhY2siLCJjaGFuZ2VTcGVjIiwiY29yZVJhbmdlIiwiY3JlYXRlQ29sbGVjdGlvbkNvbnN0cnVjdG9yIiwid2hlcmVDbGF1c2UiLCJrZXlSYW5nZUdlbmVyYXRvciIsImtleVJhbmdlIiwid2hlcmVDdHgiLCJyZWFkaW5nSG9vayIsInNpbXBsZUNvbXBhcmUiLCJzaW1wbGVDb21wYXJlUmV2ZXJzZSIsImNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlIiwiVCIsImNvbGxlY3Rpb24iLCJlbXB0eUNvbGxlY3Rpb24iLCJyYW5nZUVxdWFsIiwidXBwZXJGYWN0b3J5IiwidG9VcHBlckNhc2UiLCJ0b0xvd2VyQ2FzZSIsImxvd2VyRmFjdG9yeSIsIm5leHRDYXNpbmciLCJsb3dlcktleSIsInVwcGVyTmVlZGxlIiwibG93ZXJOZWVkbGUiLCJsbHAiLCJsd3JLZXlDaGFyIiwiYWRkSWdub3JlQ2FzZUFsZ29yaXRobSIsIm1hdGNoIiwibmVlZGxlcyIsInN1ZmZpeCIsImNvbXBhcmUiLCJ1cHBlck5lZWRsZXMiLCJsb3dlck5lZWRsZXMiLCJkaXJlY3Rpb24iLCJuZXh0S2V5U3VmZml4IiwibmVlZGxlc0xlbiIsImluaXREaXJlY3Rpb24iLCJuZWVkbGVCb3VuZHMiLCJuZWVkbGUiLCJuYiIsImNyZWF0ZVJhbmdlIiwiZmlyc3RQb3NzaWJsZU5lZWRsZSIsImxvd2VzdFBvc3NpYmxlQ2FzaW5nIiwiY2FzaW5nIiwiYmV0d2VlbiIsImluY2x1ZGVMb3dlciIsImluY2x1ZGVVcHBlciIsIl9jbXAiLCJhYm92ZSIsImFib3ZlT3JFcXVhbCIsImJlbG93IiwiYmVsb3dPckVxdWFsIiwic3RhcnRzV2l0aCIsInN0ciIsInN0YXJ0c1dpdGhJZ25vcmVDYXNlIiwiZXF1YWxzSWdub3JlQ2FzZSIsImFueU9mSWdub3JlQ2FzZSIsInN0YXJ0c1dpdGhBbnlPZklnbm9yZUNhc2UiLCJuIiwiYW55T2YiLCJfYXNjZW5kaW5nIiwiX2Rlc2NlbmRpbmciLCJub3RFcXVhbCIsImluQW55UmFuZ2UiLCJpbmNsdWRlTG93ZXJzIiwiaW5jbHVkZVVwcGVycyIsIm5vbmVPZiIsInJhbmdlcyIsImFzY2VuZGluZyIsImRlc2NlbmRpbmciLCJfbWluIiwibWF4IiwiX21heCIsImFkZFJhbmdlIiwibmV3UmFuZ2UiLCJzb3J0RGlyZWN0aW9uIiwicmFuZ2VTb3J0ZXIiLCJyYW5nZVBvcyIsImtleUlzQmV5b25kQ3VycmVudEVudHJ5Iiwia2V5SXNCZWZvcmVDdXJyZW50RW50cnkiLCJrZXlXaXRoaW5DdXJyZW50UmFuZ2UiLCJjaGVja0tleSIsInN0YXJ0c1dpdGhBbnlPZiIsImNyZWF0ZVdoZXJlQ2xhdXNlQ29uc3RydWN0b3IiLCJvckNvbGxlY3Rpb24iLCJfSURCS2V5UmFuZ2UiLCJJREJLZXlSYW5nZSIsImV2ZW50UmVqZWN0SGFuZGxlciIsInByZXZlbnREZWZhdWx0IiwidGFyZ2V0Iiwic3RvcFByb3BhZ2F0aW9uIiwiREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUiLCJTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUiLCJnbG9iYWxFdmVudHMiLCJUcmFuc2FjdGlvbiIsIl9sb2NrIiwiX3JlY3Vsb2NrIiwibG9ja093bmVyRm9yIiwiX3VubG9jayIsIl9ibG9ja2VkRnVuY3MiLCJfbG9ja2VkIiwiZm5BbmRQU0QiLCJzaGlmdCIsIk9wZW5GYWlsZWQiLCJhY3RpdmUiLCJ0cmFuc2FjdGlvbiIsImR1cmFiaWxpdHkiLCJjaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHkiLCJldiIsIl9yZWplY3QiLCJvbmFib3J0Iiwib24iLCJvbmNvbXBsZXRlIiwiX3Jlc29sdmUiLCJzdG9yYWdlbXV0YXRlZCIsImJXcml0ZUxvY2siLCJSZWFkT25seSIsIl9yb290Iiwid2FpdEZvciIsInByb21pc2VMaWtlIiwicm9vdCIsIl93YWl0aW5nRm9yIiwiX3dhaXRpbmdRdWV1ZSIsInN0b3JlIiwib2JqZWN0U3RvcmUiLCJzcGluIiwiX3NwaW5Db3VudCIsImN1cnJlbnRXYWl0UHJvbWlzZSIsImFib3J0IiwibWVtb2l6ZWRUYWJsZXMiLCJfbWVtb2l6ZWRUYWJsZXMiLCJ0cmFuc2FjdGlvbkJvdW5kVGFibGUiLCJjcmVhdGVUcmFuc2FjdGlvbkNvbnN0cnVjdG9yIiwiZGJzY2hlbWEiLCJjb21wbGV0ZSIsIndhc0FjdGl2ZSIsImNyZWF0ZUluZGV4U3BlYyIsInNyYyIsIm5hbWVGcm9tS2V5UGF0aCIsImNyZWF0ZVRhYmxlU2NoZW1hIiwic2FmYXJpTXVsdGlTdG9yZUZpeCIsImdldE1heEtleSIsIklkYktleVJhbmdlIiwib25seSIsImdldEtleUV4dHJhY3RvciIsImdldFNpbmdsZVBhdGhLZXlFeHRyYWN0b3IiLCJhcnJheWlmeSIsIl9pZF9jb3VudGVyIiwiZ2V0S2V5UGF0aEFsaWFzIiwiY3JlYXRlREJDb3JlIiwidG1wVHJhbnMiLCJleHRyYWN0U2NoZW1hIiwidGFibGVzIiwib2JqZWN0U3RvcmVOYW1lcyIsImF1dG9JbmNyZW1lbnQiLCJpbmRleEJ5S2V5UGF0aCIsImlzUHJpbWFyeUtleSIsImluZGV4TmFtZXMiLCJtdWx0aUVudHJ5IiwiaGFzR2V0QWxsIiwibWFrZUlEQktleVJhbmdlIiwiaWRiUmFuZ2UiLCJ1cHBlckJvdW5kIiwibG93ZXJCb3VuZCIsImJvdW5kIiwiY3JlYXRlRGJDb3JlVGFibGUiLCJpc0FkZE9yUHV0IiwicmVxIiwicmVxcyIsImVycm9ySGFuZGxlciIsImFyZ3MxIiwiYXJnczIiLCJzb3VyY2UiLCJvcGVuS2V5Q3Vyc29yIiwiX19faWQiLCJfY3Vyc29yQ29udGludWUiLCJfY3Vyc29yQ29udGludWVQcmltYXJ5S2V5IiwiY29udGludWVQcmltYXJ5S2V5IiwiX2N1cnNvckFkdmFuY2UiLCJkb1Rocm93Q3Vyc29ySXNOb3RTdGFydGVkIiwiZG9UaHJvd0N1cnNvcklzU3RvcHBlZCIsImdvdE9uZSIsIml0ZXJhdGlvblByb21pc2UiLCJyZXNvbHZlSXRlcmF0aW9uIiwicmVqZWN0SXRlcmF0aW9uIiwiZ3VhcmRlZENhbGxiYWNrIiwicmVxdWVzdCIsIm5vbkluZmluaXRMaW1pdCIsImlkYktleVJhbmdlIiwiZ2V0QWxsIiwiZ2V0QWxsS2V5cyIsImtleUNvdW50IiwiY2FsbGJhY2tDb3VudCIsInN1Y2Nlc3NIYW5kbGVyIiwiX3BvcyIsInRhYmxlTWFwIiwiTUlOX0tFWSIsIk1BWF9LRVkiLCJjcmVhdGVNaWRkbGV3YXJlU3RhY2siLCJzdGFja0ltcGwiLCJtaWRkbGV3YXJlcyIsImRvd24iLCJjcmVhdGVNaWRkbGV3YXJlU3RhY2tzIiwiZGJjb3JlIiwiZ2VuZXJhdGVNaWRkbGV3YXJlU3RhY2tzIiwiX25vdmlwIiwiX21pZGRsZXdhcmVzIiwidGJsIiwic2V0QXBpT25QbGFjZSIsIm9ianMiLCJ0YWJsZU5hbWVzIiwicHJvcERlc2MiLCJlbnVtZXJhYmxlIiwicmVtb3ZlVGFibGVzQXBpIiwibG93ZXJWZXJzaW9uRmlyc3QiLCJfY2ZnIiwidmVyc2lvbiIsInJ1blVwZ3JhZGVycyIsIm9sZFZlcnNpb24iLCJpZGJVcGdyYWRlVHJhbnMiLCJnbG9iYWxTY2hlbWEiLCJfc3RvcmVOYW1lcyIsInJlamVjdFRyYW5zYWN0aW9uIiwiY3JlYXRlVGFibGUiLCJwb3B1bGF0ZSIsInVwZGF0ZVRhYmxlc0FuZEluZGV4ZXMiLCJxdWV1ZSIsInZlcnNpb25zIiwiX3ZlcnNpb25zIiwiYnVpbGRHbG9iYWxTY2hlbWEiLCJhbnlDb250ZW50VXBncmFkZXJIYXNSdW4iLCJ2ZXJzVG9SdW4iLCJvbGRTY2hlbWEiLCJuZXdTY2hlbWEiLCJhZGp1c3RUb0V4aXN0aW5nSW5kZXhOYW1lcyIsImRpZmYiLCJnZXRTY2hlbWFEaWZmIiwidHVwbGUiLCJjaGFuZ2UiLCJyZWNyZWF0ZSIsIlVwZ3JhZGUiLCJhZGRJbmRleCIsImRlbGV0ZUluZGV4IiwiZGVsIiwiaWR4TmFtZSIsImNvbnRlbnRVcGdyYWRlIiwidXBncmFkZVNjaGVtYSIsImNvbnRlbnRVcGdyYWRlSXNBc3luYyIsInJldHVyblZhbHVlIiwicHJvbWlzZUZvbGxvd2VkIiwiZGVjcmVtZW50b3IiLCJkZWxldGVSZW1vdmVkVGFibGVzIiwicnVuUXVldWUiLCJjcmVhdGVNaXNzaW5nVGFibGVzIiwib2xkRGVmIiwibmV3RGVmIiwiZGVmIiwib2xkSW5kZXhlcyIsIm5ld0luZGV4ZXMiLCJvbGRJZHgiLCJuZXdJZHgiLCJjcmVhdGVPYmplY3RTdG9yZSIsImNvbnRhaW5zIiwic3RvcmVOYW1lIiwiZGVsZXRlT2JqZWN0U3RvcmUiLCJjcmVhdGVJbmRleCIsImRiU3RvcmVOYW1lcyIsImoiLCJpZGJpbmRleCIsInJlYWRHbG9iYWxTY2hlbWEiLCJ2ZXJubyIsInZlcmlmeUluc3RhbGxlZFNjaGVtYSIsImluc3RhbGxlZFNjaGVtYSIsImNoIiwiX2hhc0dldEFsbCIsImRleGllTmFtZSIsImluZGV4U3BlYyIsIldvcmtlckdsb2JhbFNjb3BlIiwicGFyc2VJbmRleFN5bnRheCIsInByaW1LZXlBbmRJbmRleGVzIiwiaW5kZXhOdW0iLCJ0cmltIiwicmVwbGFjZSIsIlZlcnNpb24iLCJfcGFyc2VTdG9yZXNTcGVjIiwic3RvcmVzIiwib3V0U2NoZW1hIiwic3RvcmVzU291cmNlIiwic3RvcmVzU3BlYyIsInVwZ3JhZGUiLCJ1cGdyYWRlRnVuY3Rpb24iLCJjcmVhdGVWZXJzaW9uQ29uc3RydWN0b3IiLCJ2ZXJzaW9uTnVtYmVyIiwiZ2V0RGJOYW1lc1RhYmxlIiwiZGJOYW1lc0RCIiwiRGV4aWUkMSIsImFkZG9ucyIsImRibmFtZXMiLCJoYXNEYXRhYmFzZXNOYXRpdmUiLCJkYXRhYmFzZXMiLCJnZXREYXRhYmFzZU5hbWVzIiwiaW5mb3MiLCJpbmZvIiwiX29uRGF0YWJhc2VDcmVhdGVkIiwiX29uRGF0YWJhc2VEZWxldGVkIiwidmlwIiwiaWRiUmVhZHkiLCJpc1NhZmFyaSIsInVzZXJBZ2VudERhdGEiLCJpbnRlcnZhbElkIiwidHJ5SWRiIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiZGV4aWVPcGVuIiwic3RhdGUiLCJvcGVuQ2FuY2VsbGVyIiwidGhyb3dJZkNhbmNlbGxlZCIsInJlc29sdmVEYlJlYWR5IiwiZGJSZWFkeVJlc29sdmUiLCJ1cGdyYWRlVHJhbnNhY3Rpb24iLCJ3YXNDcmVhdGVkIiwidHJ5T3BlbkRCIiwiZGJOYW1lIiwiYXV0b1NjaGVtYSIsInJvdW5kIiwib25ibG9ja2VkIiwiX2ZpcmVPbkJsb2NrZWQiLCJvbnVwZ3JhZGVuZWVkZWQiLCJhbGxvd0VtcHR5REIiLCJjbG9zZSIsImRlbHJlcSIsImRlbGV0ZURhdGFiYXNlIiwiTm9TdWNoRGF0YWJhc2UiLCJvbGRWZXIiLCJwb3ciLCJvbnZlcnNpb25jaGFuZ2UiLCJ2Y0ZpcmVkIiwib25jbG9zZSIsIm9uUmVhZHlCZWluZ0ZpcmVkIiwicmVhZHkiLCJmaXJlUmVtYWluZGVycyIsInJlbWFpbmRlcnMiLCJhd2FpdEl0ZXJhdG9yIiwiY2FsbE5leHQiLCJkb1Rocm93IiwidGhyb3ciLCJvblN1Y2Nlc3MiLCJzdGVwIiwib25FcnJvciIsImdldE5leHQiLCJleHRyYWN0VHJhbnNhY3Rpb25BcmdzIiwiX3RhYmxlQXJnc18iLCJzY29wZUZ1bmMiLCJlbnRlclRyYW5zYWN0aW9uU2NvcGUiLCJwYXJlbnRUcmFuc2FjdGlvbiIsInNjb3BlRnVuY0lzQXN5bmMiLCJQcmVtYXR1cmVDb21taXQiLCJwYWQiLCJjcmVhdGVWaXJ0dWFsSW5kZXhNaWRkbGV3YXJlIiwiaW5kZXhMb29rdXAiLCJhbGxWaXJ0dWFsSW5kZXhlcyIsImFkZFZpcnR1YWxJbmRleGVzIiwia2V5VGFpbCIsImxvd0xldmVsSW5kZXgiLCJrZXlQYXRoQWxpYXMiLCJpbmRleExpc3QiLCJrZXlMZW5ndGgiLCJpc1ZpcnR1YWwiLCJ2aXJ0dWFsSW5kZXgiLCJ2aXJ0dWFsS2V5UGF0aCIsImZpbmRCZXN0SW5kZXgiLCJ0cmFuc2xhdGVSYW5nZSIsInRyYW5zbGF0ZVJlcXVlc3QiLCJjcmVhdGVWaXJ0dWFsQ3Vyc29yIiwiX2NvbnRpbnVlIiwidmlydHVhbEN1cnNvciIsInZpcnR1YWxJbmRleE1pZGRsZXdhcmUiLCJsZXZlbCIsImdldE9iamVjdERpZmYiLCJwcmZ4IiwiYXAiLCJicCIsImFwVHlwZU5hbWUiLCJicFR5cGVOYW1lIiwiZ2V0RWZmZWN0aXZlS2V5cyIsImhvb2tzTWlkZGxld2FyZSIsImRvd25Db3JlIiwiZG93blRhYmxlIiwidGFibGVNaWRkbGV3YXJlIiwiZHhUcmFucyIsImRlbGV0aW5nIiwiY3JlYXRpbmciLCJ1cGRhdGluZyIsImFkZFB1dE9yRGVsZXRlIiwiZGVsZXRlUmFuZ2UiLCJnZXRFeGlzdGluZ1ZhbHVlcyIsImV4aXN0aW5nVmFsdWVzIiwiY29udGV4dHMiLCJleGlzdGluZ1ZhbHVlIiwiZ2VuZXJhdGVkUHJpbWFyeUtleSIsIm9iamVjdERpZmYiLCJhZGRpdGlvbmFsQ2hhbmdlcyIsInJlcXVlc3RlZFZhbHVlIiwiZGVsZXRlTmV4dENodW5rIiwiZWZmZWN0aXZlS2V5cyIsImdldEZyb21UcmFuc2FjdGlvbkNhY2hlIiwiY2FjaGVFeGlzdGluZ1ZhbHVlc01pZGRsZXdhcmUiLCJjYWNoZWRSZXN1bHQiLCJpc0VtcHR5UmFuZ2UiLCJub2RlIiwiUmFuZ2VTZXQiLCJmcm9tT3JUcmVlIiwidG8iLCJkIiwicmFuZ2VTZXQiLCJtZXJnZVJhbmdlcyIsImFkZEtleSIsImFkZEtleXMiLCJnZXRSYW5nZVNldEl0ZXJhdG9yIiwibGVmdCIsInJpZ2h0IiwiciIsInJlYmFsYW5jZSIsInJpZ2h0V2FzQ3V0T2ZmIiwibmV3U2V0IiwiX2FkZFJhbmdlU2V0IiwicmFuZ2VzT3ZlcmxhcCIsInJhbmdlU2V0MSIsInJhbmdlU2V0MiIsImkxIiwibmV4dFJlc3VsdDEiLCJpMiIsIm5leHRSZXN1bHQyIiwia2V5UHJvdmlkZWQiLCJ1cCIsIl9iIiwicm9vdENsb25lIiwib2xkUm9vdFJpZ2h0IiwiY29tcHV0ZURlcHRoIiwib2JzZXJ2YWJpbGl0eU1pZGRsZXdhcmUiLCJGVUxMX1JBTkdFIiwidGFibGVDbG9uZSIsIm11dGF0ZWRQYXJ0cyIsImdldFJhbmdlU2V0IiwicGFydCIsInBrUmFuZ2VTZXQiLCJkZWxzUmFuZ2VTZXQiLCJuZXdPYmpzIiwib2xkQ2FjaGUiLCJvbGRPYmpzIiwidHJhY2tBZmZlY3RlZEluZGV4ZXMiLCJnZXRSYW5nZSIsInJlYWRTdWJzY3JpYmVycyIsIm1ldGhvZCIsInN1YnNjciIsInF1ZXJpZWRJbmRleCIsInF1ZXJpZWRSYW5nZXMiLCJrZXlzUHJvbWlzZSIsInJlc3VsdGluZ0tleXMiLCJwS2V5cyIsIndhbnRWYWx1ZXMiLCJwa2V5IiwiYWRkQWZmZWN0ZWRJbmRleCIsImFkZEtleU9yS2V5cyIsIm9sZEtleSIsIm5ld0tleSIsImRlcHMiLCJkZXBlbmRlbmNpZXMiLCJjYW5jZWxPcGVuIiwiYlN0aWNreSIsIm5ld1ZlcnNpb24iLCJ1c2UiLCJhZGRvbiIsInZlcnNpb25JbnN0YW5jZSIsIl93aGVuUmVhZHkiLCJ1bnVzZSIsIm13IiwiaGFzQXJndW1lbnRzIiwiZG9EZWxldGUiLCJiYWNrZW5kREIiLCJoYXNCZWVuQ2xvc2VkIiwiaGFzRmFpbGVkIiwiZHluYW1pY2FsbHlPcGVuZWQiLCJfdHJhbnNhY3Rpb24iLCJvbmx5SWZDb21wYXRpYmxlIiwiaWRiTW9kZSIsIlN1YlRyYW5zYWN0aW9uIiwiZW50ZXJUcmFuc2FjdGlvbiIsIkludmFsaWRUYWJsZSIsInN5bWJvbE9ic2VydmFibGUiLCJvYnNlcnZhYmxlIiwiT2JzZXJ2YWJsZSIsIl9zdWJzY3JpYmUiLCJleHRlbmRPYnNlcnZhYmlsaXR5U2V0IiwibGl2ZVF1ZXJ5IiwicXVlcmllciIsImhhc1ZhbHVlIiwiY3VycmVudFZhbHVlIiwib2JzZXJ2ZXIiLCJleGVjdXRlIiwiZXhlYyIsImNsb3NlZCIsImFjY3VtTXV0cyIsImN1cnJlbnRPYnMiLCJzdWJzY3JpcHRpb24iLCJtdXRhdGlvbkxpc3RlbmVyIiwicXVlcnlpbmciLCJzdGFydGVkTGlzdGVuaW5nIiwic2hvdWxkTm90aWZ5IiwiZG9RdWVyeSIsImdldFZhbHVlIiwiZG9tRGVwcyIsIm1vekluZGV4ZWREQiIsIndlYmtpdEluZGV4ZWREQiIsIm1zSW5kZXhlZERCIiwid2Via2l0SURCS2V5UmFuZ2UiLCJEZXhpZSIsImRhdGFiYXNlTmFtZSIsImV4aXN0cyIsImlnbm9yZVRyYW5zYWN0aW9uIiwiYXN5bmMiLCJnZW5lcmF0b3JGbiIsInNwYXduIiwiY3VycmVudFRyYW5zYWN0aW9uIiwicHJvbWlzZU9yRnVuY3Rpb24iLCJvcHRpb25hbFRpbWVvdXQiLCJzZW1WZXIiLCJtYXhLZXkiLCJhZGRFdmVudExpc3RlbmVyIiwidXBkYXRlZFBhcnRzIiwicHJvcGFnYXRpbmdMb2NhbGx5IiwiaW5pdEN1c3RvbUV2ZW50IiwicHJvcGFnYXRlTG9jYWxseSIsInVwZGF0ZVBhcnRzIiwid2FzTWUiLCJCcm9hZGNhc3RDaGFubmVsIiwiYmMiLCJ1bnJlZiIsImNoYW5nZWRQYXJ0cyIsInBvc3RNZXNzYWdlIiwib25tZXNzYWdlIiwiZGF0YSIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJ0cmlnIiwicmFuZG9tIiwibWF0Y2hBbGwiLCJpbmNsdWRlVW5jb250cm9sbGVkIiwiY2xpZW50IiwicGFyc2UiLCJuZXdWYWx1ZSIsInN3Q29udGFpbmVyIiwic2VydmljZVdvcmtlciIsInByb3BhZ2F0ZU1lc3NhZ2VMb2NhbGx5IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/dexie@3.2.7/node_modules/dexie/dist/modern/dexie.mjs\n");

/***/ })

};
;